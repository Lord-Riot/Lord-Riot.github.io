<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Attacks on Rainbow</title>
    <url>/2022/04/06/Attacks-on-Rainbow/</url>
    <content><![CDATA[<h2 id="attacks-on-rainbow">Attacks on Rainbow</h2>
<p><a href="https://eprint.iacr.org/2020/1343.pdf">paper1</a></p>
<p><a href="https://eprint.iacr.org/2022/214.pdf">paper2</a></p>
<h3 id="uov">UOV</h3>
<h4 id="mqp">MQP</h4>
<p>Multivariate Qudratic Problem.</p>
<p>For <span class="math inline">\(P: \mathbb{F}_q^n \rightarrow \mathbb{F}_q^m\)</span>, known $t ^m_q $, want <span class="math inline">\(s \in \mathbb{F}^n_q , P(s) = t\)</span>.</p>
<p>We often use <span class="math inline">\(F_4/F_5\)</span> or <span class="math inline">\(XL\)</span> these kind of Grobner-basis-like algorithm.</p>
<h4 id="mrp">MRP</h4>
<p>MinRank Problem.</p>
<p>For <span class="math inline">\(n\)</span>-by-<span class="math inline">\(m\)</span> matrices <span class="math inline">\(L_1, \dots, L_k\)</span>, and a target rank <span class="math inline">\(r\)</span>, want a linear combination <span class="math inline">\(\sum_{i=1}^k y_iL_i\)</span> has rank at most <span class="math inline">\(r\)</span>.</p>
<h5 id="wiedemanns-algorihtm">Wiedemann’s Algorihtm</h5>
<p>An algorithm could calculate non-zero kernel vector of matrix.</p>
<h5 id="xl-algorithm">XL Algorithm</h5>
<p>Details in Chinese could be seen <a href="http://www.ecice06.com/CN/10.3969/j.issn.1000-3428.2008.19.053">here</a>.</p>
<p>The key thought of XL Algorithm is to use multiply to generate some same monomials, and take these monomials as independent variables, then use Gaussian elimination like Grobner basis, which is equivalent to Macaulay matrix.</p>
<h4 id="uov-attacks">UOV Attacks</h4>
<h5 id="reconciliation-attack">Reconciliation attack</h5>
<p>The key point is ‘impose <span class="math inline">\(m\)</span> affine constraints on the entries of <span class="math inline">\(\vec{\bf{o}}\)</span>’</p>
<h5 id="kipnis-shamir-attack">Kipnis-Shamir attack</h5>
<p>If <span class="math inline">\(n &gt; 2m\)</span>, the probability <span class="math inline">\(\frac{q-1}{|O|}\)</span> is calculated from follow.</p>
<p>In <span class="math inline">\(O\)</span>, for any vector <span class="math inline">\(\vec{\bf{x}}\)</span>, it could take <span class="math inline">\(q-1\)</span> eigen values <span class="math inline">\(1, 2, \dots, q-1\)</span>.</p>
<h5 id="intersection-attack">Intersection attack</h5>
<p>extension of Kipnis-Shamir attack.</p>
<h4 id="rainbow">Rainbow</h4>
<p>In the first step of calculating trapdoor information, I’m confused that how could we calculate <span class="math inline">\(P(\overline o_1), \overline o_1 \in O_1/O_2\)</span>, <span class="math inline">\(\overline o_1 = \{\vec o_1 + \vec o_2 \ | \ \vec o_2 \in O_2 \}, \vec o_1 \in O_1\)</span>.</p>
<p>Then I connect the context, I think it means that we want <span class="math inline">\(\vec o_1 \in O_1\)</span> which lets <span class="math inline">\(\forall \ \vec o_2 \in O_2\)</span>, <span class="math inline">\(P(\vec v + \vec o_1 + \vec o_2) + W = \vec t + W\)</span>.</p>
<p>The number of constraints is <span class="math inline">\(m - dim W\)</span> because this system lies on <span class="math inline">\(F^m_q/W\)</span>.</p>
<h4 id="rainbow-attacks">Rainbow Attacks</h4>
<h5 id="uov-attack">UOV attack</h5>
<p>use Kipnis-Shamir attack to get <span class="math inline">\(O_2\)</span>, then use <span class="math inline">\(P&#39;(x, ): O_2 \rightarrow W\)</span> to get <span class="math inline">\(W\)</span>, finally use <span class="math inline">\(P(O_1) \in W\)</span> with Kipnis-Shamir attack to get <span class="math inline">\(O_1\)</span>.</p>
<h5 id="minrankhighrank-attack">MinRank/HighRank attack</h5>
<p>According to <span class="math inline">\(rank(M) + nullity(M) = dim(M)\)</span>, the rank of <span class="math inline">\(M_v\)</span> should certainly be <span class="math inline">\(n - nullity(M) \leq n - dim(O_2)\)</span>, because kernel of <span class="math inline">\(O_2\)</span> is in <span class="math inline">\(M_v\)</span>, then <span class="math inline">\(nullity(M) = dim(ker(M)) \geq dim(O_2)\)</span>.</p>
<h5 id="rainbow-band-separation-attack">Rainbow band separation attack</h5>
<p>similar to Reconciliation attack in UOV.</p>
<h5 id="new-attack">New Attack</h5>
<h6 id="simple-attack">Simple Attack</h6>
<ol type="1">
<li><p>build following system to find a vector <span class="math inline">\(\vec o \in O_2\)</span> <span class="math display">\[
 D_x : \mathbb{F}_q^n \rightarrow \mathbb{F}_q^m: y\rightarrow P&#39;(x, y) \\
 B \sim Ker(D_x), D_x(Bx)=0\\
 \left\{ \begin{aligned} 
   D_x(\vec o) = 0 \\ 
   P(\vec o) = 0
   \end{aligned}
   \right.
   \\
 \Rightarrow \tilde P(x) = P(Bx)
 \]</span> ​ For odd characteristic, it’s normal to use XL solve <span class="math inline">\(m\)</span> homogeneous equations in <span class="math inline">\(n-m\)</span> variables.</p>
<p>​ For even characteristic, we have <span class="math inline">\(P&#39;(x, x)= 0\)</span>, because <span class="math inline">\(P&#39;(x, x) = P(2x) - 2P(x)\)</span>, and due to all <span class="math inline">\(p_i(x)\)</span> in <span class="math inline">\(P(x)\)</span> is quadratic, then <span class="math inline">\(P(2x) = 4P(x)\)</span>, so <span class="math inline">\(P&#39;(x, x) = 2P(x)\)</span> which vanishes in characteristic 2. Then <span class="math inline">\(D_x(x) = 0\)</span>, so <span class="math inline">\(x \in ker(D_x)\)</span>.</p>
<p>​ Firstly, I was confused that why then we could get <span class="math inline">\(\exists \tilde x, \forall y, \tilde P(\tilde x + y) = \tilde P(\tilde x) + \tilde P(y)\)</span>, which equals <span class="math inline">\(P&#39;(B\tilde x, By) = 0\)</span>. Because <span class="math inline">\(B\)</span> is a <span class="math inline">\(n \times (n-m)\)</span> matrix, there’s no kernel for it, then there’s no <span class="math inline">\(\tilde x\)</span> let <span class="math inline">\(B \tilde x = 0\)</span>, then how could <span class="math inline">\(P&#39;(B\tilde x, By)\)</span> always be zero. Then I relaized that we could find a <span class="math inline">\(\tilde x\)</span> let <span class="math inline">\(B\tilde x = x\)</span>, then <span class="math inline">\(P&#39;(B\tilde x, By) = P&#39;(x, By) = D_x(By) = 0\)</span>, this works only if <span class="math inline">\(x \in ker(D_x)\)</span>.</p>
<p>​ Then we get <span class="math inline">\(m-1\)</span> homogeneous equations like $p_1(By)a_i -p_i(By) a_1 = 0 $ in <span class="math inline">\(n-m-1\)</span> variables, the complexity has been reduced by this transform.</p></li>
<li><p>use <span class="math inline">\(\vec o\)</span> to complete the attack</p>
<p><span class="math inline">\(V\)</span> as a change of variables here means, for a vector <span class="math inline">\(\vec x = \vec w + \vec x&#39;, \vec w \in W\)</span>, then <span class="math inline">\(V(\vec x) = V(\vec w&#39;) + V(\vec x&#39;)\)</span>, the first <span class="math inline">\(m-o_2\)</span> of <span class="math inline">\(V(w&#39;)\)</span> are zeros.</p>
<p><span class="math inline">\(U\)</span> as a change of variables here means, for a vector <span class="math inline">\((x_0, x_1, \dots, x_n) \in \mathbb{F}_q^n\)</span>, let <span class="math inline">\(\hat x_0 = (x_0, x_1, \dots, x_{n-o_2}, 0, 0, \dots, 0), \hat x_1 = (0, 0, \dots, 0, x_{n-o_2+1}&#39;\)</span>, then <span class="math inline">\(U(x) = \hat x_0 + \hat x_1\)</span>, and <span class="math inline">\(\hat x_1\)</span> is in <span class="math inline">\(O_2\)</span>.</p>
<blockquote>
<p>In general, <span class="math inline">\(V^{-1}\)</span> and <span class="math inline">\(U\)</span> are similar to nullity matrices for <span class="math inline">\(W\)</span> and <span class="math inline">\(O_2\)</span>.</p>
</blockquote>
<p>Knonw the <span class="math inline">\(V\)</span> and <span class="math inline">\(U\)</span> clearly, the left would be clear.</p>
<p><span class="math inline">\(P \cdot U(x) = P(\hat x_0 + \hat x_1) = P&#39;(\hat x_0, \hat x_1) + P(\hat x_0) + P(\hat x_1) = P&#39;(\hat x_0, \hat x_1) + P(\hat x_0)\)</span>, we know that <span class="math inline">\(P&#39;(\hat x_0, \hat x_1) \in W\)</span>, so under <span class="math inline">\(V\)</span>, the first <span class="math inline">\(m-o_2\)</span> which is <span class="math inline">\(F_1(x)\)</span> would only depends on <span class="math inline">\(P(\hat x_0)\)</span>. <span class="math inline">\(\forall\ U(y) \in O_2\)</span>, <span class="math inline">\(U(y) + \hat x_1\)</span> could be taken as <span class="math inline">\(\hat x_1&#39;\)</span>, so <span class="math inline">\(F_1(x+y) = F_1(x)\)</span>.</p>
<p>Then we reduce the problem which is finding <span class="math inline">\(x\)</span> for given <span class="math inline">\(P(x)\)</span> to finding <span class="math inline">\(x\)</span> for given <span class="math inline">\(F_1(x)\)</span>.</p></li>
</ol>
<h6 id="combination-with-rectangular-minrank-attack">Combination with rectangular MinRank attack</h6>
<p>​ Straightly speaking, the combination method put the equation <span class="math inline">\(D_x(\vec o) = 0\)</span> in MinRank system.</p>
<p>​ I recall the MinRank attack here, for matrices like: <span class="math display">\[
L_i = \begin{pmatrix} P&#39;(e_1, e_i) \\ 
\cdots \\  
P&#39;(e_n, e_i)
\end{pmatrix}
\]</span> ​ If there’s a linear combination <span class="math inline">\(o_i\)</span>, let <span class="math inline">\(\sum_{i=1}^n o_iL_i\)</span> has rank at most <span class="math inline">\(dim(W) = o_2\)</span>, if <span class="math inline">\(\vec o \notin O_2\)</span> , the possibility of this event is about <span class="math inline">\(C_n^{n-o_2} * (\frac{1}{n})^{n-o_2}\)</span>, which equals the event that choose random <span class="math inline">\(n\)</span> vectors in <span class="math inline">\(\mathbb{F}_q^n\)</span> with <span class="math inline">\(n-o_2\)</span> linear dependence. Generally, the <span class="math inline">\(\vec o\)</span> is probably in <span class="math inline">\(O_2\)</span>.</p>
<p>​ In combination, for matrices like: <span class="math display">\[
\tilde L_i = \begin{pmatrix} P&#39;(e_1, b_i) \\ 
\cdots \\  
P&#39;(e_n, b_i)
\end{pmatrix}
\]</span> ​ the solution <span class="math inline">\(x_i\)</span> of this MinRank problem satisfies <span class="math inline">\(\sum x_ib_i\)</span> probably in <span class="math inline">\(O_2\)</span>, then the dimension has been reduced to <span class="math inline">\(n-m\)</span>.</p>
]]></content>
      <categories>
        <category>Learning Notes</category>
      </categories>
      <tags>
        <tag>Way to Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>Way to CopperSmith</title>
    <url>/2021/01/06/Way-to-CopperSmith/</url>
    <content><![CDATA[<h2 id="整体思路">整体思路</h2>
<p>利用构造多项式技巧，构造出多项式，形成一个格，然后进行规约，得到较小范数的多项式，然后通过结式求解（有时也有其他办方，比如直接系数gcd，多项式gcd或是Gröbner basis等，May’s origin attack on CRT-RSA就出现了好几种方法）小范数多项式，即可得到原多项式在一定范围下的所有根。本质思想其实就是把有限域上的方程转化到整数域，而转化的界限就是由柯西-施瓦茨不等式给出的。</p>
<h2 id="理论基础">理论基础</h2>
<h3 id="howgrave-grahams-lemma">Howgrave-Graham’s Lemma</h3>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210105163614824.png"></p>
<p>此定理的意义在于，如果找到了符合约束的多项式<span class="math inline">\(h\)</span>，则<span class="math inline">\(h\)</span>在模<span class="math inline">\(N\)</span>上的所有小根也即是<span class="math inline">\(h\)</span>在整数域上的所有小根，也就是说，我们可以将有限域上的多项式转化为整数域上的多项式。</p>
<h3 id="lll">LLL</h3>
<p>即是格基约化，这里的作用即是通过对构造出的特定的格的约化而产生符合约束的多项式<span class="math inline">\(h\)</span>，然后通过结式将多元方程转化成一元方程式，之后解整数域上的一元方程即可。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210119210323145.png"></p>
<p>通过以上事实，可以看到LLL至少可以找到两组满足约束的向量，也就保证了在规定条件下结式有解的可能性。</p>
<h2 id="构造多项式">构造多项式</h2>
<h3 id="jochemsz-may-strategy">Jochemsz-May Strategy</h3>
<h4 id="modular">Modular</h4>
<h5 id="basic-strategy">Basic Strategy</h5>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210105151007107.png"></p>
<p>先算出m及<span class="math inline">\(f_N^m\)</span>，然后使<span class="math inline">\(k\)</span>遍历<span class="math inline">\([0, m]\)</span>，计算<span class="math inline">\(M_k\)</span>，指定<span class="math inline">\(l\)</span> 并根据以下公式，计算多个多项式，构成格基。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210105151153621.png"></p>
<p>例子如下</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210105151232073.png"></p>
<p>这样的构造是为了保证，最终构造的多项式里的每个单项式都是<span class="math inline">\(f_N^m\)</span>中的单项式。</p>
<p>要注意的是，并不是说构造出来的多项式需要严格是以上形式，这只是提供了一种总体构造思想。</p>
<h5 id="extended-strategy">Extended Strategy</h5>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210105160118293.png"></p>
<p>针对某个变量的extended strategy，是为了得到更好的界，有时也可以通过一些关式构造出新的变量用来shift。</p>
<h2 id="相关知识学习">相关知识学习</h2>
<h3 id="gröbner-basis">Gröbner basis</h3>
<h4 id="仿射簇与理想">仿射簇与理想</h4>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210125173538955.png"></p>
<p>可以看到仿射簇是一组多项式公共根的集合。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210125172941690.png"></p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210125173015118.png"></p>
<p>理想与子空间类似，不同的是子空间我们使用标量相乘的线性组合，而理想使用多项式相乘的线性组合。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210125173721623.png"></p>
<p>可以根据一个仿射簇的所有根来定义理想，其内所有多项式的根均包含仿射簇中所有根。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210125174319490.png"></p>
<p>可以根据仿射簇定义理想，同样可以根据理想定义仿射簇，但通过这样的嵌套的结果不一定总是相等。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210125224615811.png"></p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210125230055826.png"></p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210125230151910.png"></p>
<p>多项式间gcd性质与整数基本一致</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210126183324108.png"></p>
<h4 id="序与单项式理想">序与单项式理想</h4>
<p>由于通过总结多项式除法和高斯消元法，意识到‘序’的意义，故这里定义多元单项式的一种比较的序。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210126183642058.png"></p>
<p>同时我们知道定义一个序是好的，当且仅当它不存在无穷递减序列。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210126183819553.png"></p>
<p>这里通过比较向量差的首个非零向量来作为一个序（此即lex order，类似于字符串的字典序比较法）</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210126184446792.png"></p>
<p>考虑到纯字典序有不妥，这里将向量的范数也引入，优先以范数比较，再其次以字典序比较</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210126185425947.png"></p>
<p>也可以定义反向字典序（即从最右边变量开始比较，且最右边小的在前面）</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210128160544093.png"></p>
<p>对于一个多项式，定义诸多概念如上</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210128160939371.png"></p>
<p>于是有朴素的定理如上。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210128171340140.png"></p>
<p>这里定义了多元变量的多项式除法，主要点在于除的对象是一组多项式，具体操作与单元多项式除法类似，通过leading term判断是否结束除法，依次除各个多项式即可。若<span class="math inline">\(f\)</span> 对于<span class="math inline">\(f_1, f_2, \dots,f_s\)</span>做除法余数为0，则<span class="math inline">\(f \in &lt;f_1,\dots,f_s&gt;\)</span>，即<span class="math inline">\(f\)</span>属于由这组多项式生成的理想。于是考虑想找一种好的basis，使得任意多项式除此basis的余数唯一确定。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210128203056552.png"></p>
<p>定义无系数的“单项式理想”，这里建议结合wiki看着理解，单纯概念感觉这里介绍的有点不是很清晰，定义单项式理想的目的是方便刻画Grobner Basis。一个多项式属于一个单项式理想当且仅当它的每个项都可以被此理想的基中的一个项整除。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210129102940414.png"></p>
<p>单项式理想可以有限生成</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210129103005875.png"></p>
<p>定义了单项式理想上的最小基</p>
<h4 id="grobner-basis">Grobner Basis</h4>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210129132431762.png"></p>
<p>定义了由首项生成的理想，需要注意的是<span class="math inline">\(&lt;LT(f_1), \dots,LT(f_s)&gt;\)</span>和<span class="math inline">\(&lt;LT(I)&gt;\)</span></p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210129153325247.png"></p>
<p>关于Grobner Basis存在性的定理</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210129153651691.png"></p>
<p>给出了Grobner Basis的定义</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210129220618047.png"></p>
<p>此即是由Hilbert定理得出的，任意多项式环可以有限生成。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210130182655949.png"></p>
<p>这里表面了在Grobner Basis下余多项式的唯一性，证明仍是标准的反证结合定义即可，这也顺其自然的推出了一个多项式的余多项式为0和其属于理想的等价性。</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210130230114222.png"></p>
<p>定义一个表示对于basis余多项式的表示方法。</p>
<p>Grobner Basis之所以可以用于解多元方程，在于其会将多元分离，即只要方程数量保证，产生的基中变量是依次递增，即从1到n，由此可以依次求解各个方程，得到各个变量，类似于对多项式构成的矩阵做了一个上三角化。</p>
<h2 id="推荐阅读论文">推荐阅读论文</h2>
<ol type="1">
<li><a href="https://link.springer.com/chapter/10.1007/11935230_18">A Strategy for Finding Roots of Multivariate Polynomials with New Applications in Attacking RSA Variants</a></li>
<li><a href="https://www.researchgate.net/publication/221010552_New_attacks_on_RSA_with_small_secret_CRT-exponents">New attacks on RSA with small secret CRT-exponents</a></li>
<li><a href="https://link.springer.com/chapter/10.1007/3-540-44670-2_6">Approximate Integer Common Divisors</a></li>
</ol>
<p>这些论文里出现的参考文献都可以跟进阅读，加深理解。</p>
<h2 id="相关论文勘误">相关论文勘误</h2>
<h3 id="cryptanalysis-of-unbalanced-rsa-with-small-crt-exponent-alexander-may">Cryptanalysis of Unbalanced RSA with Small CRT-Exponent | Alexander May</h3>
<p>在module e的attack中最后的例子矩阵中</p>
<p><img src="/2021/01/06/Way-to-CopperSmith/image-20210122160238781.png"></p>
<p>矩阵第五行，第四列元素错误，应为<span class="math inline">\(eNY^2\)</span>，而非<span class="math inline">\(eN^2Y^2\)</span>，我一开始写代码没套多项式生成，直接搬的矩阵，导致bound严重不符合，最后发现这里多了个N。</p>
]]></content>
      <categories>
        <category>Learning Notes</category>
      </categories>
      <tags>
        <tag>Way to Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>摸鱼Writeup-2</title>
    <url>/2021/03/10/%E6%91%B8%E9%B1%BCWriteup-2/</url>
    <content><![CDATA[<h4 id="ant-x-d3ctf">Ant x D3CTF</h4>
<h5 id="babylattice">BabyLattice</h5>
<p>考虑r很小，有<span class="math inline">\(b m + r= c + k n\)</span>，故构造格</p>
<p><span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 \\ b &amp; 1 &amp; 0 \\ c &amp; 0 &amp; X\end{bmatrix}\]</span></p>
<p>X为放缩因子，目标向量为<span class="math inline">\((k, m, 1)\)</span>时，通过格映射为向量<span class="math inline">\((r, m, X)\)</span>，调整X大小为<span class="math inline">\(2^{300}\)</span>，可成功规约出目标向量，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">n = <span class="number">69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361</span></span><br><span class="line">b = <span class="number">65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196</span></span><br><span class="line">c = <span class="number">64666354938466194052720591810783769030566504653409465121173331362654665231573809234913985758725048071311571549777481776826624728742086174609897160897118750243192791021577348181130302572185911750797457793921069473730039225991755755340927506766395262125949939309337338656431876690470938261261164556850871338570</span></span><br><span class="line"></span><br><span class="line">X = <span class="number">2</span>**<span class="number">300</span></span><br><span class="line">M = Matrix(ZZ, [[n, <span class="number">0</span>, <span class="number">0</span>], [b, <span class="number">1</span>, <span class="number">0</span>], [c, <span class="number">0</span>, X]])</span><br><span class="line"></span><br><span class="line">ML = M.LLL()</span><br><span class="line"></span><br><span class="line">r = int(ML[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">m = int(abs(ML[<span class="number">0</span>][<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">assert</span> (b * m + r) % n == c</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;d3ctf&#123;%s&#125;&#x27;</span> % sha256(int(m).to_bytes(<span class="number">50</span>, <span class="string">&#x27;big&#x27;</span>)).hexdigest())</span><br></pre></td></tr></table></figure>
<h5 id="simplegroup">SimpleGroup</h5>
<p>需要用到第一题中有关n，b的关系式，</p>
<p><span class="math inline">\(b * a11 - a12 \equiv 0 \mod p\)</span></p>
<p><span class="math inline">\(b * a21 - a22 \equiv 0 \mod q\)</span></p>
<p>考虑到a11，a12，a21，a22都很小，可以使用格基规约，但p，q未知（这里我一开始想直接二元Copper，但发现好像bound不太够，懒得想复杂的多项式构造了），考虑将两个式子相乘，展开得到</p>
<p><span class="math display">\[a11 * a21 * b^2 -(a11*a22 + a21*a12) *b  + a12 * a22  = k * n\]</span></p>
<p>构造格如下：</p>
<p><span class="math display">\[\begin{bmatrix} n &amp; 0 &amp; 0 \\ b &amp; 1 &amp; 0 \\ b^2 &amp; 0 &amp; 1\end{bmatrix}\]</span></p>
<p>这里由于a11，a12，a21，a22都非常小，不需要平衡因子，目标向量<span class="math inline">\((k, a11*a22 + a21*a12, -a11 * a21)\)</span>，通过格映射，得到向量<span class="math inline">\((a12 * a22, a11*a22 + a21*a12, -a12 * a22)\)</span>，之后联立方程，即可解除a11，a12，a21，a22，然后即可分解n。</p>
<p>又考虑到$e = e_1 * e_2, e_1 = 36493 ,e_2= 52859 $</p>
<p>对于<span class="math inline">\(m_i\)</span>， 有<span class="math inline">\(c_i \equiv y^{m_i} r_i^{e} \mod n,\quad m \equiv m_1 \mod e_1, \quad m \equiv m_2 \mod e_2\)</span></p>
<p><span class="math inline">\(\Rightarrow c_1 \equiv y^{m_1} (y^{k_1} r^{e_2})^{e_1} \mod n, \quad c_2 \equiv y^{m_1} (y^{k_2} r^{e_1})^{e_2} \mod n\)</span></p>
<p>可以看到由于y已知，<span class="math inline">\(e_1, e_2\)</span> 位数均很小，可以通过分别爆破<span class="math inline">\(m_1, m_2\)</span>（利用<span class="math inline">\(c_1 y^{-m_1}, c_2 y^{-m_2}\)</span> 在<span class="math inline">\(GF(n)\)</span> 上是否是<span class="math inline">\(e_1, e_2\)</span> 次数剩余来判断），之后CRT即可恢复<span class="math inline">\(m_i\)</span>，完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">s, t, _phi</span>):</span></span><br><span class="line">    <span class="keyword">if</span> _phi % t != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> pow(s, _phi//t, n) == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">69804507328197961654128697510310109608046244030437362639637009184945533884294737870524186521509776189989451383438084507903660182212556466321058025788319193059894825570785105388123718921480698851551024108844782091117408753782599961943040695892323702361910107399806150571836786642746371968124465646209366215361</span></span><br><span class="line">b = <span class="number">65473938578022920848984901484624361251869406821863616908777213906525858437236185832214198627510663632409869363143982594947164139220013904654196960829350642413348771918422220404777505345053202159200378935309593802916875681436442734667249049535670986673774487031873808527230023029662915806344014429627710399196</span></span><br><span class="line">y = <span class="number">12064801545723347322936991186738560311049061235541031580807549422258814170771738262264930441670708308259694588963224372530498305648578520552038029773849342206125074212912788823834152785756697757209804475031974445963691941515756901268376267360542656449669715367587909233618109269372332127072063171947435639328</span></span><br><span class="line">e = <span class="number">1928983487</span></span><br><span class="line">C = [<span class="number">63173987757788284988620600191109581820396865828379773315280703314093571300861961873159324234626635582246705378908610341772657840682572386153960342976445563045427986000105931341168525422286612417662391801508953619857648844420751306271090777865836201978470895906780036112804110135446130976275516908136806153488</span>, <span class="number">9763526786754236516067080717710975805995955013877681492195771779269768465872108434027813610978940562101906769209984501196515248675767910499405415921162131390513502065270491854965819776080041506584540996447044249409209699608342257964093713589580983775580171905489797513718769578177025063630080394722500351718</span>, <span class="number">37602000735227732258462226884765737048138920479521815995321941033382094711120810035265327876995207117707635304728511052367297062940325564085193593024741832905771507189762521426736369667607865137900432117426385504101413622851293642219573920971637080154905579082646915297543490131171875075081464735374022745371</span>, <span class="number">1072671768043618032698040622345664216689606325179075270470875647188092538287671951027561894188700732117175202207361845034630743422559130952899064461493359903596018309221581071025635286144053941851624510600383725195476917014535032481197737938329722082022363122585603600777143850326268988298415885565240343957</span>, <span class="number">27796821408982345007197248748277202310092789604135169328103109167649193262824176309353412519763498156841477483757818317945381469765077400076181689745139555466187324921460327576193198145058918081061285618767976454153221256648341316332169223400180283361166887912012807743326710962143011946929516083281306203120</span>, <span class="number">27578857139265869760149251280906035333246393024444009493717159606257881466594628022512140403127178174789296810502616834123420723261733024810610501421455454191654733275226507268803879479462533730695515454997186867769363797096196096976825300792616487723840475500246639213793315097434400920355043141319680299224</span>, <span class="number">29771574667682104634602808909981269404867338382394257360936831559517858873826664867201410081659799334286847985842898792091629138292008512383903137248343194156307703071975381090326280520578349920827357328925184297610245746674712939135025013001878893129144027068837197196517160934998930493581708256039240833145</span>, <span class="number">33576194603243117173665354646070700520263517823066685882273435337247665798346350495639466826097821472152582124503891668755684596123245873216775681469053052037610568862670212856073776960384038120245095140019195900547005026888186973915360493993404372991791346105083429461661784366706770467146420310246467262823</span>, <span class="number">5843375768465467361166168452576092245582688894123491517095586796557653258335684018047406320846455642101431751502161722135934408574660609773328141061123577914919960794180555848119813522996120885320995386856042271846703291295871836092712205058173403525430851695443361660808933971009396237274706384697230238104</span>, <span class="number">61258574367240969784057122450219123953816453759807167817741267194076389100252707986788076240792732730306129067314036402554937862139293741371969020708475839483175856346263848768229357814022084723576192520349994310793246498385086373753553311071932502861084141758640546428958475211765697766922596613007928849964</span>, <span class="number">13558124437758868592198924133563305430225927636261069774349770018130041045454468021737709434182703704611453555980636131119350668691330635012675418568518296882257236341035371057355328669188453984172750580977924222375208440790994249194313841200024395796760938258751149376135149958855550611392962977597279393428</span>]</span><br><span class="line"></span><br><span class="line">e1 = <span class="number">36493</span></span><br><span class="line">e2 = e//e1</span><br><span class="line"></span><br><span class="line">X = <span class="number">1</span></span><br><span class="line">M = Matrix(ZZ, [[n, <span class="number">0</span>, <span class="number">0</span>], [b, X, <span class="number">0</span>], [b ^ <span class="number">2</span>, <span class="number">0</span>, X]])</span><br><span class="line">ML = M.LLL()</span><br><span class="line"></span><br><span class="line"><span class="comment"># a = a11 * a21, b = a11*a22 + a21*a12, c = a12 * a22</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a = 211380743487233628797755584958526337321408979158793229985661</span></span><br><span class="line"><span class="string">b = 1382843159437215516163973075066558157591473749635266665605630</span></span><br><span class="line"><span class="string">c = 1173142580751247504024100371706709782500216511824162516724129</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">a11, a21, a12, a22 = var(&#x27;a11, a21, a12, a22&#x27;)</span></span><br><span class="line"><span class="string">solve([a == a11 * a21, b == a11*a22 + a21*a12, c == a12 * a22], a11, a21, a12, a22)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a11 = <span class="number">1018979931854255696816714991181</span></span><br><span class="line">a12 = <span class="number">1017199123798810531137951821909</span></span><br><span class="line"></span><br><span class="line">p = gcd(b * a11 - a12, n)</span><br><span class="line">q = n//p</span><br><span class="line"><span class="keyword">assert</span> n == p * q</span><br><span class="line"></span><br><span class="line">M = []</span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(len(C))):</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, e1+<span class="number">1</span>):</span><br><span class="line">        tmp = (C[i] * inverse(int(pow(y, m, n)), n)) % n</span><br><span class="line">        <span class="keyword">if</span> check(tmp, e1, phi):</span><br><span class="line">            m1 = m</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, e2+<span class="number">1</span>):</span><br><span class="line">        tmp = (C[i] * inverse(int(pow(y, m, n)), n)) % n</span><br><span class="line">        <span class="keyword">if</span> check(tmp, e2, phi):</span><br><span class="line">            m2 = m</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    tmp_m = CRT([m1, m2], [e1, e2])</span><br><span class="line">    M.append(tmp_m)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;M:&#x27;</span>, M)</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">    flag += M[i] * (e**i)</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(flag))</span><br></pre></td></tr></table></figure>
<h5 id="easycurve">EasyCurve</h5>
<p>这一题有个很大的非预期，就是由于x，y坐标给的较小，可以完全通过hackergame2020中OT的方法来获得完整的一对<span class="math inline">\(x, y\)</span>，由于p-1非常光滑，可以直接在其曲线上使用Pohlig Hellman算法来得到e，从而得到flag。</p>
<p>这里谈下预期解法，是通过一个映射来讲曲线的点映射到GF上，然后构造OT，再在GF上使用Pohlig Hellman求解的，具体得到这个映射的方法很多，我这里讲一种比较简单的求通项得到的方法。</p>
<p>稍作分析可以发现题给曲线其实是一个<span class="math inline">\(GF(p)\)</span> 上的pell方程，即<span class="math inline">\(x^2 \equiv Dy^2 + u^2\)</span>，而pell方程的解可以通过以下方法得到（这里的<span class="math inline">\(x_n\)</span> 即对应<span class="math inline">\((nG)x\)</span>，即n倍点的坐标）</p>
<p><img src="/2021/03/10/%E6%91%B8%E9%B1%BCWriteup-2/image-20210310232854416.png"></p>
<p>对矩阵<span class="math inline">\(\begin{bmatrix} x_1 &amp; Dy_1 \\ y_1 &amp; x_1\end{bmatrix}\)</span>，进行对角化，可以得到其特征值为$ D y + x, -D y + x$，之后求得 <span class="math display">\[
x_n = \frac{(y_1\sqrt D + x_1)^n + (-y_1\sqrt D + x_1)^n}{2 u^{n-1}}
\]</span></p>
<p><span class="math display">\[
y_n = \frac{(y_1\sqrt D + x_1)^n - (-y_1\sqrt D + x_1)^n}{2 \sqrt Du^{n-1}}
\]</span></p>
<p>容易得到 <span class="math display">\[
\frac{x_n - \sqrt D y_n}{ u} = (\frac{x1 - \sqrt D y1}{u}) ^ n
\]</span></p>
<p><span class="math display">\[
\frac{x_n + \sqrt D y_n}{ u} = (\frac{x1 + \sqrt D y1}{u}) ^ n
\]</span></p>
<p>即找到了两个将曲线上点映射到GF的映射 <span class="math display">\[
f: f(x, y) = \frac{x - \sqrt D y}{ u}
\]</span></p>
<p><span class="math display">\[
g: g(x, y) = \frac{x + \sqrt D y}{ u}
\]</span></p>
<p>此时，利用hackergame2020的OT中的技巧，且D已知，对于每一个点，可以得到<span class="math inline">\(x - \sqrt D y\)</span>，得到两组数据后相除，即可得到 <span class="math display">\[
\frac{x_{1n} + \sqrt D y_{1n}}{ x_{2n} + \sqrt D y_{2n}} = (\frac{x1 + \sqrt D y1}{x_1 + \sqrt D y_2}) ^ n
\]</span> 对这两个数通过Pohlig Hellman算法求DLP，即可得到e，从而得到flag，完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> winpwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt, ceil</span><br><span class="line"><span class="keyword">from</span> factordb.factordb <span class="keyword">import</span> FactorDB</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> jacobi</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> nthroot_mod</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> digits, ascii_letters</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">charset = digits + ascii_letters</span><br><span class="line">p = <span class="number">9688074905643914060390149833064012354277254244638141162997888145741631958242340092013958501673928921327767591959476890238698855704376126231923819603296257</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_factor_list</span>(<span class="params">n</span>):</span></span><br><span class="line">    factor = FactorDB(n)</span><br><span class="line">    factor.connect()</span><br><span class="line">    <span class="keyword">return</span> list(factor.get_factor_list())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_factor_list_with_exponent</span>(<span class="params">n, factor_list=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> factor_list:</span><br><span class="line">        factor = FactorDB(n)</span><br><span class="line">        factor.connect()</span><br><span class="line">        factor_list = list(factor.get_factor_list())</span><br><span class="line">    factor_list_with_exponent = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> factor_list:</span><br><span class="line">        <span class="keyword">if</span> factor <span class="keyword">not</span> <span class="keyword">in</span> factor_list_with_exponent.keys():</span><br><span class="line">            factor_list_with_exponent[factor] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            factor_list_with_exponent[factor] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> factor_list_with_exponent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bsgs</span>(<span class="params">g, y, p, upper_bound=None</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> upper_bound:</span><br><span class="line">        upper_bound = p - <span class="number">1</span></span><br><span class="line">    m = int(ceil(sqrt(upper_bound)))</span><br><span class="line">    S = &#123;pow(g, j, p): j <span class="keyword">for</span> j <span class="keyword">in</span> range(m+<span class="number">1</span>)&#125;</span><br><span class="line">    gs = pow(g, (-m) % (p<span class="number">-1</span>), p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">return</span> i * m + S[y]</span><br><span class="line">        y = (y * gs) % p</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCRT</span>(<span class="params">mi, ai</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> (isinstance(mi, list) <span class="keyword">and</span> isinstance(ai, list))</span><br><span class="line">    curm, cura = mi[<span class="number">0</span>], ai[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi[<span class="number">1</span>:], ai[<span class="number">1</span>:]):</span><br><span class="line">        d = int(GCD(curm, m))</span><br><span class="line">        c = a - cura</span><br><span class="line">        <span class="keyword">assert</span> (c % d == <span class="number">0</span>)</span><br><span class="line">        K = c // d * inverse(curm // d, m // d)</span><br><span class="line">        cura += curm * K</span><br><span class="line">        curm = curm * m // d</span><br><span class="line">        cura %= curm</span><br><span class="line">    <span class="keyword">return</span> cura % curm, curm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_n_order</span>(<span class="params">g, p, phi=None, factor_list=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> phi:</span><br><span class="line">        phi = p<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> factor_list:</span><br><span class="line">        factor_list = get_factor_list(phi)</span><br><span class="line">    ord = phi</span><br><span class="line">    new_factor_list = factor_list</span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> factor_list:</span><br><span class="line">        <span class="keyword">if</span> pow(g, ord//factor, p) == <span class="number">1</span>:</span><br><span class="line">            ord //= factor</span><br><span class="line">            new_factor_list.remove(factor)</span><br><span class="line">    <span class="keyword">return</span> ord, get_factor_list_with_exponent(p, new_factor_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pohlig_hellman</span>(<span class="params">g, y, p, ord=None, factor_list=None</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ord:</span><br><span class="line">        ord, factor_list = get_n_order(g, p, factor_list=factor_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        factor_list = get_factor_list_with_exponent(ord)</span><br><span class="line">    prime_order_mod = [<span class="number">0</span>] * len(factor_list)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> enumerate(factor_list.keys()):</span><br><span class="line">        tmp_g = pow(g, ord//factor, p)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(factor_list[factor]):</span><br><span class="line">            tmp_y = (y * inverse(pow(g, prime_order_mod[i], p), p)) % p</span><br><span class="line">            tmp_y = pow(tmp_y, ord//(factor**(j+<span class="number">1</span>)), p)</span><br><span class="line">            pmod = bsgs(tmp_g, tmp_y, p, factor**(j+<span class="number">1</span>))</span><br><span class="line">            prime_order_mod[i] += pmod * (factor**j)</span><br><span class="line">    <span class="keyword">return</span> GCRT([factor**factor_list[factor] <span class="keyword">for</span> factor <span class="keyword">in</span> factor_list.keys()], prime_order_mod)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span>(<span class="params">end, judge</span>):</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> tqdm(charset):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> charset:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> charset:</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> charset:</span><br><span class="line">                    tmp = a + b + c + d</span><br><span class="line">                    <span class="keyword">if</span> sha256((tmp + end).encode()).hexdigest() == judge:</span><br><span class="line">                        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_x_y</span>(<span class="params">s</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;n = &#x27;</span>)</span><br><span class="line">    n = int(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip())</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;e = &#x27;</span>)</span><br><span class="line">    e = int(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip())</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;x0 = &#x27;</span>)</span><br><span class="line">    x0 = int(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip())</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;x1 = &#x27;</span>)</span><br><span class="line">    x1 = int(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip())</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;v = &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    v = pow(-s, e, n) * x1 - x0</span><br><span class="line">    v = (v * inverse(pow(-s, e, n) - <span class="number">1</span>, n)) % n</span><br><span class="line">    io.sendline(str(v))</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;m0_ = &#x27;</span>)</span><br><span class="line">    m0 = int(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip())</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;m1_ = &#x27;</span>)</span><br><span class="line">    m1 = int(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (m0 + m1 * s) % n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># io = remote(&#x27;47.100.50.252&#x27;, 10000)</span></span><br><span class="line">    io = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10015</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;io.recvuntil(&#x27;sha256(XXXX+&#x27;)</span></span><br><span class="line"><span class="string">    have = io.recv(16)</span></span><br><span class="line"><span class="string">    io.recvuntil(&#x27;== &#x27;)</span></span><br><span class="line"><span class="string">    ans = io.recv(64)</span></span><br><span class="line"><span class="string">    io.recvuntil(&#x27;Give me XXXX:&#x27;)</span></span><br><span class="line"><span class="string">    io.sendline(proof_of_work(have, ans))&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;D = &#x27;</span>)</span><br><span class="line">    D = int(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip())</span><br><span class="line">    <span class="keyword">if</span> jacobi(D, p) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    io.close()</span><br><span class="line">a = nthroot_mod(D, <span class="number">2</span>, p)</span><br><span class="line"></span><br><span class="line">Gx = []</span><br><span class="line">kGx = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    Gx.append(get_x_y(a))</span><br><span class="line">    kGx.append(get_x_y(a))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;do you know my e?&#x27;</span>)</span><br><span class="line">    io.sendline(str(<span class="number">0</span>))</span><br><span class="line">    print(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line"></span><br><span class="line">get_x_y(<span class="number">0</span>)</span><br><span class="line">get_x_y(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;do you know my e?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">g = (Gx[<span class="number">0</span>] * inverse(Gx[<span class="number">1</span>], p)) % p</span><br><span class="line">y = (kGx[<span class="number">0</span>] * inverse(kGx[<span class="number">1</span>], p)) % p</span><br><span class="line">print(<span class="string">&#x27;g =&#x27;</span>, g)</span><br><span class="line">print(<span class="string">&#x27;y =&#x27;</span>, y)</span><br><span class="line"></span><br><span class="line">guess = pohlig_hellman(g, y, p)</span><br><span class="line"><span class="keyword">assert</span> pow(g, guess, p) == y</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;guess =&#x27;</span>, guess)</span><br><span class="line">io.sendline(str(guess))</span><br><span class="line">print(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Crypto in CTF</category>
      </categories>
      <tags>
        <tag>Crypto in CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>摸鱼Writeup-3</title>
    <url>/2021/12/13/%E6%91%B8%E9%B1%BCWriteup-3/</url>
    <content><![CDATA[<h4 id="bytectf2021-final">ByteCTF2021 Final</h4>
<h5 id="acyclic-group">acyclic group</h5>
<p>另外几道题没什么说的，这道题比赛的时候折磨了我很久。。。最后几分钟差一点想出来但还是没出。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choices, getrandbits, randint</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> FLAG</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span>() -&gt; bool:</span></span><br><span class="line">    alphabet = string.ascii_letters + string.digits</span><br><span class="line">    nonce = <span class="string">&quot;&quot;</span>.join(choices(alphabet, k=<span class="number">8</span>))</span><br><span class="line">    print(<span class="string">f&#x27;SHA256(&quot;<span class="subst">&#123;nonce&#125;</span>&quot; + ?) starts with &quot;000000&quot;&#x27;</span>)</span><br><span class="line">    message = (nonce + input().strip()).encode()</span><br><span class="line">    <span class="keyword">return</span> sha256(message).digest().hex().startswith(<span class="string">&quot;000000&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_modulus</span>():</span></span><br><span class="line">    primes = [</span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>,</span><br><span class="line">        <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>,</span><br><span class="line">        <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>,</span><br><span class="line">        <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">127</span>, <span class="number">131</span>,</span><br><span class="line">    ]</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    t = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> primes:</span><br><span class="line">        tmp_t = randint(<span class="number">1</span>, <span class="number">16</span>)</span><br><span class="line">        n *= p ** tmp_t</span><br><span class="line">        t.append(tmp_t)</span><br><span class="line">    <span class="keyword">return</span> n, t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>() -&gt; bool:</span></span><br><span class="line">    n, _ = gen_modulus()</span><br><span class="line">    e = randint(<span class="number">1</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            num = input().strip()</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str.isnumeric(num):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        num = int(num)</span><br><span class="line">        <span class="keyword">if</span> num == n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        res = pow(num, e, n)</span><br><span class="line">        print(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    signal.alarm(<span class="number">60</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> proof_of_work():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(<span class="string">&quot;Listen...I have some acyclic groups for you...&quot;</span></span><br><span class="line">          <span class="string">&quot;No noise this time...God bless you get them...&quot;</span>)</span><br><span class="line">    passed = <span class="number">0</span></span><br><span class="line">    T = <span class="number">256</span></span><br><span class="line">    signal.alarm(T)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(T):</span><br><span class="line">        print(<span class="string">&quot;Round&quot;</span>, i)</span><br><span class="line">        <span class="keyword">if</span> test():</span><br><span class="line">            passed += <span class="number">1</span></span><br><span class="line">            print(<span class="string">&quot;GOOD SHOT, MY FRIEND&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;CALM DOWN, MY FRIEND&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> passed &gt; T * <span class="number">0.8</span>:</span><br><span class="line">        print(<span class="string">&quot;CONGRATULATIONS&quot;</span>, FLAG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>可以看到是一个类似oracle的猜数题，可以传两次消息<span class="math inline">\(m_0, m_1\)</span>，然后得到<span class="math inline">\(m_0^e\mod n, m_1^e \mod n\)</span>。而 <span class="math inline">\(n\)</span> 是由一个指定素数集构成的，指数随机生成，于是我最早考虑计算primes所有素数的积<span class="math inline">\(N\)</span>，那么必然有<span class="math inline">\(N | n, n | N^{16}\)</span>，这样传入<span class="math inline">\(k_1N^{k_0}, k_2N^{k_0}\)</span>，得到<span class="math inline">\(c_0, c_1\)</span>，<span class="math inline">\(k_2*c_0 - k_1*c_1\)</span> 必然是n的倍数，再通过一些简单的过滤则有可能得到<span class="math inline">\(n\)</span>，但这样的理论概率极限也就是<span class="math inline">\(0.5\)</span>，而题目需要大于<span class="math inline">\(0.8\)</span>，实验中最多也就到<span class="math inline">\(0.55\)</span>左右。</p>
<p>于是考虑别的想法，找到<span class="math inline">\(N^{16}\)</span> 上的<span class="math inline">\(k_1\)</span> 次根<span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(k_2\)</span>次根 <span class="math inline">\(x_2\)</span>，然后传入<span class="math inline">\(x_1, x_2\)</span>，得到<span class="math inline">\(c_0, c_1\)</span>， 有<span class="math inline">\(c_0^{k_1} - 1 \equiv 0 \mod n, c_1^{k_2} - 1 \equiv 0 \mod n\)</span>， 则可以计算<span class="math inline">\(GCD(c_0^{k_1} - 1, c_1^{k_2} - 1 )\)</span> 来得到n的倍数。当<span class="math inline">\(k_1, k_2\)</span> 取到较大的两个素数时（测试中53，41为最佳），<span class="math inline">\(GCD(c_0^{k_1} - 1, c_1^{k_2} - 1 )\)</span> 中的多余小因子很少，这样结合一些过滤可以稳定到 $ 0.6$ 左右的概率，实验中最高得到182/256次，距离要求仍然相差甚远。</p>
<p>赛后和Hermes聊这题，他用了先验奇数的思想，即先传一个<span class="math inline">\(x_0, x_0 \equiv 2 \mod 3\)</span>，如果返回的<span class="math inline">\(c_0 \equiv 2 \mod 3\)</span> ，那么e为奇数，反之为偶数，如果是奇数，第二个直接传<span class="math inline">\(-x_0 \mod N^{16}\)</span> 即可，这样天然是<span class="math inline">\(0.5+\)</span> 的概率，只需要考虑e为偶数的情况即可。</p>
<p>于是我将这个先验思想与之前的想法结合，由于只有2次根模3上为2，故考虑第一个数传2次根与一个53次根的积，然后根据返回的<span class="math inline">\(c_0\)</span>判断e的奇偶性，如果为奇数则直接得到n，反之使用之前的方法，传入41次根，计算GCD并过滤，这里使用的过滤也很简单，用了一个简单的check函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ez_check</span>(<span class="params">x, tmp_n, tmp_c, index</span>):</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, index):</span><br><span class="line">        <span class="keyword">if</span> pow(x, j, tmp_n) == tmp_c:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>判断现有的n和c是否匹配，虽然不能完全判别正确性，但可以过滤掉一部分n，不加过滤的话，是无法到达0.8的要求的。</p>
<p>于是得到完整的exp（本地测试，非远程）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>,</span><br><span class="line">          <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>,</span><br><span class="line">          <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>,</span><br><span class="line">          <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">109</span>, <span class="number">113</span>, <span class="number">127</span>, <span class="number">131</span>]</span><br><span class="line">N = <span class="number">525896479052627740771371797072411912900610967452630</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ez_check</span>(<span class="params">x, tmp_n, tmp_c, index</span>):</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, index):</span><br><span class="line">        <span class="keyword">if</span> pow(x, j, tmp_n) == tmp_c:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_modulus</span>():</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    t = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> primes:</span><br><span class="line">        tmp_t = randint(<span class="number">1</span>, <span class="number">16</span>)</span><br><span class="line">        n *= p ** tmp_t</span><br><span class="line">        t.append(tmp_t)</span><br><span class="line">    <span class="keyword">return</span> n, t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X53 = <span class="number">16146763596179907622493109012827107483432127255282437968769511754257220353461373199051318700354563705501798111116975423559551919422360373620077135733152834339753566421633318551588422901547881579218520776006792486613397971515271604855586579740039260074131940980987975405945266243817124527776349845008796650597901430324561617712539448004335786983097258035189240029672607297470279777590671871429356611345024068708210664204032378937951457734824660588211295536984531224843323388692707230473974167062051827530633678063778393771712605759122050047549153324446713490868711015327552083786926047655742819801159119820050854801807132456468704631166477801370570144842420484203774449336692121369166894459616914719270555761434836110634387526761779763136974433072352065708061222706777945829022683408311193928882620000000000000001</span></span><br><span class="line">X41 = <span class="number">14433742236573688560360048613517053763200707683208778120848086283299329941013908083365456158136248365405808895787635075734246983533602171353983415139484130546490622760668175853268336625517248976893430593633591158403560983700284581913439756565424800771408850504240484768112546298539809747045454017191685052792871835571611728801542959691013910881345442147407305419751546631888734401332725798315194326822778940702909396121047842327694640911259501609831936278582897452598156308636522732156722313669233126732015453396069197186228360843076869905501365431573710803270781244583676572897758932558706108800668583084492823482604125931433024709087840253930862552870791179735998515105708049484833368876195836038931796305023286562526358223498002848846916276239224031232879423197037204854042451328998802974875960000000000000001</span></span><br><span class="line">X2 = <span class="number">15845692616563450127497208839410301344402316795683874456673644728074297254230460786999608268999620577402794405164458414337023127673742026008021414589602557158573546834697406978953669032292544682264032538283813482564370439284759728142958678735148370476425664417360562433032379231110074243013706826953064966499154160963062921354644984286660194677706265414862607876360639364289269590679134724946975491236100718964941807053660511056670515549359602825507165267329870326738546498444951189947310784787069656189398361340810771090331973605773043378424416612980873234071900022982273879970686574341215845470279225478293269284360469028535434817147966175875953360972917337632136468352618104434531745056493725241600130859431706675615178872943525346567519727470007647885832252355970578673569499720213721708193542519836425781249</span></span><br><span class="line">length = <span class="number">90</span></span><br><span class="line">M = N**<span class="number">16</span></span><br><span class="line">test_length = <span class="number">2049</span></span><br><span class="line">times = <span class="number">0</span></span><br><span class="line">not_times = <span class="number">0</span></span><br><span class="line">pass_times = <span class="number">0</span></span><br><span class="line">t0 = <span class="number">53</span> * <span class="number">2</span></span><br><span class="line">t1 = <span class="number">41</span></span><br><span class="line">x0 = (X2 * X53) % M</span><br><span class="line">x1 = X41</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">256</span>)):</span><br><span class="line">    n, t = gen_modulus()</span><br><span class="line">    e = randint(<span class="number">1</span>, n<span class="number">-1</span>)</span><br><span class="line">    c0 = pow(x0, e, n)</span><br><span class="line">    <span class="keyword">if</span> c0 % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">        c1 = pow(-x0 % M, e, n)</span><br><span class="line">        my_n = c1+c0</span><br><span class="line">        <span class="keyword">assert</span> my_n == n</span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    c1 = pow(x1, e, n)</span><br><span class="line">    tmp0 = pow(c0, t0, M) - <span class="number">1</span></span><br><span class="line">    tmp1 = pow(c1, t1, M) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> tmp0 == <span class="number">0</span>:</span><br><span class="line">        tmp0 = x0 - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> tmp1 == <span class="number">0</span>:</span><br><span class="line">        tmp1 = x1 - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    sn = GCD(tmp0, tmp1)</span><br><span class="line">    my_n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> prime <span class="keyword">in</span> primes:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> sn % prime ** i == <span class="number">0</span> <span class="keyword">and</span> i &lt;= <span class="number">16</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        my_n *= prime ** (i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (ez_check(x0, my_n, c0, t0) <span class="keyword">and</span> ez_check(x1, my_n, c1, t1)):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">2</span>, test_length):</span><br><span class="line">            <span class="keyword">if</span> my_n % l != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            tmp = my_n // l</span><br><span class="line">            <span class="keyword">if</span> ez_check(x0, tmp, c0, t0) <span class="keyword">and</span> ez_check(x1, tmp, c1, t1):</span><br><span class="line">                my_n = tmp</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> my_n == n:</span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ez_check(x0, my_n, c0, t0) <span class="keyword">and</span> ez_check(x1, my_n, c1, t1) <span class="keyword">and</span> my_n != n:</span><br><span class="line">        pass_times += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> tmp0 &lt; n <span class="keyword">or</span> tmp1 &lt; n:</span><br><span class="line">        not_times += <span class="number">1</span></span><br><span class="line">print(<span class="string">&#x27;times: %d&#x27;</span> % times)</span><br></pre></td></tr></table></figure>
<p>运行后发现通过率可以满足题目要求：</p>
<p><img src="/2021/12/13/%E6%91%B8%E9%B1%BCWriteup-3/image-20211213174503734.png"></p>
<p>总体来说这题还是比较有意思的，但是对于为什么两个较大素数根做GCD的小因子很小尚未探究，也期待官方WP有比较好的解释。</p>
]]></content>
      <categories>
        <category>Crypto in CTF</category>
      </categories>
      <tags>
        <tag>Crypto in CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题闲记</title>
    <url>/2020/10/06/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0/</url>
    <content><![CDATA[<p><em>此系列博客主要记录一下一些题的做题想法（各种rz心路历程orz</em></p>
<h4 id="强网杯">强网杯</h4>
<h5 id="proof-for-dice2cry">proof for dice2cry</h5>
<p>本质上即是partial oracle mod 3</p>
<p>根本问题在于对于<span class="math inline">\((3 *m \mod n) \mod 3\)</span>，是否可以根据模数判断m所在区间，即属于<span class="math inline">\((0, \frac{1}{3}n), (\frac{1}{3}n, \frac{2}{3}n), ( \frac{2}{3}n,n)\)</span> 中的哪一个。</p>
<p>case 0：</p>
<p>如果模3的结果为0，那么其实可以很容易的知道<span class="math inline">\(3*m\)</span>并没有被截断，故而属于$ (0, n)$ 区间</p>
<p>case 1/2：</p>
<p>对于模数为1或2的情况，并不存在一定的一一对应的解区间，但对于相同的n，1/2对应的区间是一定的，下面给出第二区间的证明（第三区间类似）：</p>
<p>$m (n, n), (3 *m -n) x ,  x = 1  or  2 $</p>
<p>使用反证法，不妨设</p>
<p><span class="math inline">\(\exists \ m_1, m_2 ,\\\  (3 * m_1 -n) \equiv x_1 \mod 3 , \quad (3 *m_2 -n) \equiv x_2 \mod 3 ,\\\  x_1 \neq x_2\)</span></p>
<p>两式相减得到</p>
<p><span class="math inline">\(\Rightarrow 3 * (m_1 - m_2) \equiv x_3 \mod 3, x_3 \neq 0\)</span></p>
<p>又因为</p>
<p><span class="math inline">\(3 | 3 *(m_1-m_2)\)</span></p>
<p>故<span class="math inline">\(3 * (m_1-m_2) \equiv 0 \mod 3\)</span>，假设错误，命题得证。</p>
<h4 id="安恒8月赛">安恒8月赛</h4>
<p>这次的crypto貌似是shallow，tb还有coin出的。。。确实有水平，比赛的时候只有LCG那个比较有思路，另外俩个有点懵。。感觉这几个题出到月赛有点浪费hh，时间太短，做出来的人并不多</p>
<h5 id="math-stream">math stream</h5>
<p>观察得到LCG的迭代关系为<span class="math inline">\(k_i \equiv a * k_{i-2} + (a + 1) * k_{i-1} + c \mod n\)</span></p>
<p>然而相关参数<span class="math inline">\(n, c, a\)</span> 一个都没给，只给出了301到307这6个生成数据，需要我们预测最后一个数据，发现数列长度<span class="math inline">\(2^{1024}\)</span>，于是考虑可以使用矩阵快速幂（复杂度<span class="math inline">\(O(logn)\)</span>）。</p>
<h6 id="计算通项公式"><del>计算通项公式</del>：</h6>
<p>待定系数x，y，z，则有<span class="math inline">\(k_i - x * k_{i-1} + z * c \equiv y*(k_{i-1} - x * k_{i-2} + z * c) \mod n\)</span></p>
<p>可知：</p>
<p><span class="math inline">\(x + y = a+1 ,\\\  -x * y = a ,\\\  (y-1)* z = 1\)</span></p>
<p>得到：</p>
<p><span class="math inline">\(x = \frac {a + 1 + \sqrt {a^2 + 6a + 1} }{2} ,\\\  y = \frac {a + 1 - \sqrt {a^2 + 6a + 1} }{2} ,\\\  z = \frac {2 }{a - 1 - \sqrt {a^2 + 6a + 1} }\)</span></p>
<p>设<span class="math inline">\(s_i = k_i - x * k_{i-1} + z * c \mod n\)</span>，则可知<span class="math inline">\(s_i\)</span>为<span class="math inline">\(GF(n)\)</span>上的等比数列，</p>
<p>有 <span class="math inline">\(s_{i+2} = y ^ i(k_2 -x * k_1 + z *c) \mod n\)</span>，<span class="math inline">\(k_1, k_2\)</span>即为初始生成的随机种子</p>
<p>有<span class="math inline">\(k_{i+2} = x^i*k_2 + (k_2 -x * k_1 + z *c)*\sum_{j=0}^{i}x^jy^{i-j} - z*c*\sum_{j = 0}^{i-1}x^j\)</span></p>
<p><em>上面是我做题时的错误路线，我一开始以为是纯数列题orz</em></p>
<h6 id="构造格子"><del>构造格子</del></h6>
<p>通过上面的通项公式可以发现，想要将数列的二阶公式降到一阶需要让参数变的异常复杂，故直接使用二阶公式作为来构造格子</p>
<p><span class="math inline">\(k_i \equiv a * k_{i-2} + (a + 1) * k_{i-1} + c \mod n\)</span></p>
<p><span class="math inline">\(\Rightarrow k_i - k_{i-1} \equiv a * (k_{i-2} + k_{i-1}) + c \mod n\)</span></p>
<p><span class="math inline">\(\Rightarrow k_i - k_{i-1} = a * (k_{i-2} + k_{i-1}) + c +T *n, \quad T \in Z\)</span></p>
<p>由于对<span class="math inline">\(a,c, n\)</span> 一无所知，故只能使用四组<span class="math inline">\(k_i - k_{i+1}, k_{i-2} + k_{i-1}\)</span> 构造格子</p>
<p>设<span class="math inline">\(fini_{i} = k_{i+2}-k_{i}, init_i = k_i + k_{i+1}\)</span></p>
<p>则有$fini_i = a * init_i + c + T_i * n $</p>
<p>于是我构造了如下格子：</p>
<p><img src="/2020/10/06/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0/image-20200827101436166.png"></p>
<p>但前四行的最后一列并无法平衡，因为需要找到<span class="math inline">\(B_0, B_1, B_2, B_3\)</span> 使得<span class="math inline">\(\sum_{i=0}^{4}B_i*(fini_i-a*init_i-c) &lt;&lt; min{B_i}\)</span>， 而我们并不知道<span class="math inline">\(a,c\)</span>，构造出这样的<span class="math inline">\(B_i\)</span>，显然是不可能的，但如果我们能求出n，那么只需将对角线上的1替换为n，即可解决问题。</p>
<p>然后在求解n的过程中，我意识到完全不用格子ojz，直接推就能推出来。。。而且将n代入也未能求解。。。</p>
<h6 id="推导求解">推导求解</h6>
<p>由之前推导的<span class="math inline">\(k_i - k_{i-1} \equiv a * (k_{i-2} + k_{i-1}) + c \mod n\)</span></p>
<p>则有 <span class="math inline">\((k_i - k_{i-1}) - (k_{i-1} - k_{i-2}) \equiv a *(k_{i-1} - k_{i-3}) \mod n\)</span></p>
<p>由此，只要知道了n，则可以计算出a，c</p>
<p>根据同模，利用最大公因数来求n</p>
<p>利用$(k_{i-2} - k_{i-4}) * (a *(k_{i-1} - k_{i-3}) n) $</p>
<p>$ (k_{i-1} - k_{i-3}) * (a *(k_{i-2} - k_{i-4}) n) n$</p>
<p>此部分exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_f</span>(<span class="params">k, i</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> len(k) &gt; i<span class="number">-4</span> &gt;= <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> abs((k[i] - <span class="number">2</span> * k[i<span class="number">-1</span>] + k[i<span class="number">-2</span>]) * (k[i<span class="number">-2</span>] - k[i<span class="number">-4</span>]) - (k[i<span class="number">-1</span>] - k[i<span class="number">-3</span>]) * (k[i<span class="number">-1</span>] - <span class="number">2</span> * k[i<span class="number">-2</span>] + k[i<span class="number">-3</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f_1 = get_f(k, <span class="number">4</span>)</span><br><span class="line">f_2 = get_f(k, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">n = gcd(f_1, f_2)</span><br><span class="line">print(<span class="string">&#x27;n = &#x27;</span> + str(n))</span><br><span class="line"><span class="keyword">assert</span> isPrime(n)</span><br><span class="line"></span><br><span class="line">a = ((k[<span class="number">3</span>] - <span class="number">2</span> * k[<span class="number">2</span>] + k[<span class="number">1</span>]) * inverse(k[<span class="number">2</span>] - k[<span class="number">0</span>], n)) % n</span><br><span class="line">print(<span class="string">&#x27;a = &#x27;</span> + str(a))</span><br><span class="line"></span><br><span class="line">c = ((k[<span class="number">2</span>] - k[<span class="number">1</span>]) - a * (k[<span class="number">0</span>] + k[<span class="number">1</span>])) % n</span><br><span class="line">print(<span class="string">&#x27;c = &#x27;</span> + str(c))</span><br></pre></td></tr></table></figure>
<p>这里我起初是想使用最早的通项公式，但是发现，那个方程在模n下无解。。于是只能使用矩阵快速幂来做计算</p>
<p>完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto_tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">target = <span class="number">2</span> ** <span class="number">1024</span></span><br><span class="line">k = </span><br><span class="line"></span><br><span class="line">cipher = </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_f</span>(<span class="params">k, i</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> len(k) &gt; i<span class="number">-4</span> &gt;= <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> abs((k[i] - <span class="number">2</span> * k[i<span class="number">-1</span>] + k[i<span class="number">-2</span>]) * (k[i<span class="number">-2</span>] - k[i<span class="number">-4</span>]) - (k[i<span class="number">-1</span>] - k[i<span class="number">-3</span>]) * (k[i<span class="number">-1</span>] - <span class="number">2</span> * k[i<span class="number">-2</span>] + k[i<span class="number">-3</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f_1 = get_f(k, <span class="number">4</span>)</span><br><span class="line">f_2 = get_f(k, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">n = gcd(f_1, f_2)</span><br><span class="line">print(<span class="string">&#x27;n = &#x27;</span> + str(n))</span><br><span class="line"><span class="keyword">assert</span> isPrime(n)</span><br><span class="line"></span><br><span class="line">a = ((k[<span class="number">3</span>] - <span class="number">2</span> * k[<span class="number">2</span>] + k[<span class="number">1</span>]) * inverse(k[<span class="number">2</span>] - k[<span class="number">0</span>], n)) % n</span><br><span class="line">print(<span class="string">&#x27;a = &#x27;</span> + str(a))</span><br><span class="line"></span><br><span class="line">c = ((k[<span class="number">2</span>] - k[<span class="number">1</span>]) - a * (k[<span class="number">0</span>] + k[<span class="number">1</span>])) % n</span><br><span class="line">print(<span class="string">&#x27;c = &#x27;</span> + str(c))</span><br><span class="line"></span><br><span class="line">initial_stream = [[k[<span class="number">5</span>], k[<span class="number">4</span>], <span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>,    <span class="number">0</span>,    <span class="number">0</span>],</span><br><span class="line">                  [<span class="number">0</span>,    <span class="number">0</span>,    <span class="number">0</span>]]</span><br><span class="line">initial_coefficient = [[a+<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">                       [a,   <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                       [c,   <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final_coefficient = matrix_pow(initial_coefficient, <span class="number">3</span>, target<span class="number">-305</span>, n)</span><br><span class="line">final_stream = matrix_mul(initial_stream, final_coefficient, <span class="number">3</span>, n)</span><br><span class="line">key = int(final_stream[<span class="number">0</span>][<span class="number">1</span>]) % n</span><br><span class="line">flag = cipher ^ key</span><br><span class="line">print(long_to_bytes(flag))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="lattice_trick">Lattice_trick</h5>
<p>本题考查的是利用格来辅助解方程的技巧，题给了两个等式：</p>
<p><span class="math inline">\(p * q = n\)</span></p>
<p><span class="math inline">\(11^{2020} p^2 + 45^{2020}q^2 \equiv m \mod N\)</span></p>
<p>根本的困难在于第二个式子中的因子太大，利用sage无法直接求解模方程，我起初是想通过化简式子或是直接将等式搬到格上，但都没有成功，最终看了badmonkey师傅的exp才意识到可以只利用格子来降低参数，将有限域转化为整数域，再使用sage等工具解方程。</p>
<p>抽象问题为寻找到整数A，使得<span class="math inline">\(a * 11^{2020} p^2 + a*45^{2020}q^2 \equiv b_1p^2 + b_2q^2 \mod N\)</span></p>
<p>且<span class="math inline">\(b_1, b_2\)</span> 较小，此处不难想到可以构造格子，使<span class="math inline">\(b_1, b_2\)</span> 为格子上SVP即可。</p>
<p>我尝试过构造：</p>
<p><img src="/2020/10/06/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0/image-20201007140519927.png"></p>
<p>但由于<span class="math inline">\(11^{2020}\)</span>本身的位数过大，LLL后的GapSVP会直接返回<span class="math inline">\((N, N)\)</span>向量，故需要做一些转换（此处的<span class="math inline">\(11^{-2020}\)</span>为<span class="math inline">\(11^{2020}\)</span>在N上的模逆）：</p>
<p><img src="/2020/10/06/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0/image-20201007140537646.png"></p>
<p>由此即可得到向量<span class="math inline">\((a_1, a_2)\)</span>，有<span class="math inline">\(a * 11^{2020} p^2 + a*45^{2020}q^2 \equiv a_1p^2 + a_2q^2 \mod N\)</span></p>
<p>且 <span class="math inline">\(a = a_1 * 11^{-2020},\quad a_2 \equiv a1 * 11^{-2020}*45^{2020} \mod N\)</span></p>
<p>分析一下p，q的位数，都是512位，故而<span class="math inline">\(p^2 \ or \ q^2\)</span> 的位数也不会超过1024，而求得的<span class="math inline">\(a_1, a_2\)</span>中最大的为1023位，可知<span class="math inline">\(a_1p^2 + a_2q^2\)</span> 最大位数为<span class="math inline">\(1024 + 1 + 1023 = 2048\)</span>，而N的位数为2048，故而只需让k遍历-1到1，必然存在<span class="math inline">\(a_1p^2 + a_2q^2 = k *m + (a_1p^2 + a_2q^2) \% N\)</span></p>
<p>又有：</p>
<p><span class="math inline">\((a_1p^2 + a_2q^2) \% N = ((a_1 * 11^{-2020}) * (11^{2020} p^2 + 45^{2020}q^2) \% N) \% N\)</span></p>
<p>即可与<span class="math inline">\(p * q = n\)</span> 联立求解，完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.all <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = </span><br><span class="line">n,h,N = </span><br><span class="line">c = </span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">h = (h-pow(<span class="number">14</span>, <span class="number">2020</span>, N) * (r**<span class="number">2</span>))%N</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reduce</span>(<span class="params">n,m,h</span>):</span></span><br><span class="line">    inv = (<span class="number">45</span>**<span class="number">2020</span>)*inverse(<span class="number">11</span>**<span class="number">2020</span>,m)</span><br><span class="line">    lattice = Matrix([</span><br><span class="line">        [<span class="number">1</span>,inv],</span><br><span class="line">        [<span class="number">0</span>,m]</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    res = lattice.LLL()</span><br><span class="line">    a1 = int(res[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">    a2 = int(res[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> a1&lt;<span class="number">0</span>:</span><br><span class="line">        a1,a2 = -a1,-a2%m</span><br><span class="line">    print(<span class="string">&#x27;a1 = &#x27;</span> + str(a1))</span><br><span class="line">    print(<span class="string">&#x27;a2 = &#x27;</span> + str(a2))</span><br><span class="line">    </span><br><span class="line">    tmp = int(a1*inverse(<span class="number">11</span>**<span class="number">2020</span>,m)*h)%m</span><br><span class="line">    x = var(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    y = var(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-1</span>,<span class="number">2</span>):</span><br><span class="line">        cur = tmp + i*m</span><br><span class="line">        eq1 = x*y==n</span><br><span class="line">        eq2 = a2*x**<span class="number">2</span> + a1*y**<span class="number">2</span> - cur == <span class="number">0</span></span><br><span class="line">        res = solve([eq1,eq2],x,y, solution_dict=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> len(res) &gt; <span class="number">2</span>:</span><br><span class="line">            print(<span class="string">&quot;Got the solution&quot;</span>)</span><br><span class="line">            print(res[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> int(abs(res[<span class="number">-1</span>][x])), int(abs(res[<span class="number">-1</span>][y]))</span><br><span class="line">        print(<span class="string">&quot;No solution for %d&quot;</span>%i)</span><br><span class="line"></span><br><span class="line">p, q = Reduce(n//r, N ,h)</span><br><span class="line"></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)*(r<span class="number">-1</span>)</span><br><span class="line">d = inverse(e, phi)</span><br><span class="line">c = bytes_to_long(c)</span><br><span class="line">m = pow(c,d,n)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<h5 id="copper_smith_e_d">Copper_smith_e_d</h5>
<p>已知：</p>
<p><span class="math inline">\(n = p * q * r ,\\\  r ,\\\  e * d \equiv 1 \mod ((p-1)*(q-1)*(r-1)) ,\\\  d^e \equiv t \mod n ,\\\  e = 3\)</span></p>
<p>可以看到e非常的小为3，故可知<span class="math inline">\(e *d = 1 + k * (p-1)(q-1)(r-1)\)</span> 中k小于3，使k遍历1，2，即可得到等式<span class="math inline">\(e *d = 1 + k * (p-1)(q-1)(r-1)\)</span>， 再将<span class="math inline">\(d^3 \equiv t \mod n\)</span> 变为<span class="math inline">\((e * d )^3 \equiv 27 t \mod n\)</span></p>
<p>从而得到方程：<span class="math inline">\((1 + k * (p-1)(q-1)(r-1))^3 \equiv 27t \mod n\)</span></p>
<p>可化简为<span class="math inline">\((1 + k*(r-1)*(p*q -(p+1) +1))^3 \mod 27 t \mod n\)</span></p>
<p>有单变量<span class="math inline">\(p+q\)</span>，分析<span class="math inline">\(p+q\)</span> 的位数最大为1025位，而n的位数为3344， 代入Copper_smith参数</p>
<p>即为：<span class="math display">\[\beta = 1, \delta =  3, p+q \leq \frac{1}{2}n^{\frac{1}{3} - \epsilon} \]</span></p>
<p>可近似为<span class="math inline">\(2 ^ {1025} - 1 \leq \frac{1}{2}n^{\frac{1}{3} - \epsilon}\)</span></p>
<p>此处也可以随机取两个位数为1024的素数之和近似p+q，将<span class="math inline">\(\frac{1}{3} - \epsilon\)</span> 看作<span class="math inline">\(\frac{a}{b}\)</span>，找到满足满足<span class="math inline">\((2 * (p+q))^b &lt; n ^a\)</span>中<span class="math inline">\(\frac{a}{b}\)</span>最小的，则<span class="math inline">\(\epsilon = \frac{1}{3} - \frac{a}{b}\)</span>， 寻找代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    p = getPrime(<span class="number">1024</span>)</span><br><span class="line">    q = getPrime(<span class="number">1024</span>)</span><br><span class="line">    base = <span class="number">2</span> * (p+q)</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">if</span> base ** i &lt; n ** j:</span><br><span class="line">                tmp.append(j/i)</span><br><span class="line">    print(<span class="number">1</span>/<span class="number">3</span> - min(tmp))</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(2^{1025}\)</span>的寻找结果为0.025</p>
<p>随机<span class="math inline">\(p, q\)</span>寻找的结果约为0.026，（最终求解后验证得<span class="math inline">\(\epsilon\)</span> 约为0.0265）</p>
<p>可知<span class="math inline">\(\epsilon &gt; 0.026\)</span>，取0.03，将参数代入smallroots求解方程即可得到<span class="math inline">\(p+q\)</span>， 从而得到phi，得到flag，完整exp如下（取0.03时计算时间过长。。。改成0.035或0.04之后很快就出了。。似乎越大越快（迷惑？））：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">c = </span><br><span class="line">r = </span><br><span class="line">t = </span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">e_d_3 = (<span class="number">27</span> * t) % n</span><br><span class="line">p_q = n//r</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">	f = (<span class="number">1</span>+k*(r<span class="number">-1</span>) * (p_q-x+<span class="number">1</span>))^<span class="number">3</span> - e_d_3</span><br><span class="line">	solve_1 = f.monic().small_roots(X=<span class="number">2</span>^<span class="number">1025</span>, beta=<span class="number">1</span>, epsilon=<span class="number">0.04</span>)</span><br><span class="line">	<span class="keyword">if</span> len(solve_1) &gt; <span class="number">0</span>:</span><br><span class="line">		p_add_q = solve_1[<span class="number">0</span>]</span><br><span class="line">		phi = (r<span class="number">-1</span>) * (p_q-p_add_q+<span class="number">1</span>)</span><br><span class="line">		d = inverse(<span class="number">3</span>, phi)</span><br><span class="line">		flag = long_to_bytes(pow(c, d, n))</span><br><span class="line">		print(flag)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Crypto in CTF</category>
      </categories>
      <tags>
        <tag>Crypto in CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes on Algebraic Number Theory</title>
    <url>/2022/01/19/Notes-on-Algebraic-Number-Theory/</url>
    <content><![CDATA[<h2 id="algebraic-number-theory">Algebraic Number Theory</h2>
<blockquote>
<p>最近事情比较多，代数数论先断更一段时间，搞完毕设再来续。—— 2022 3.1</p>
</blockquote>
<p>reference book: <a href="https://www.jmilne.org/math/CourseNotes/ANT.pdf">Algebraic Number Theory</a></p>
<h3 id="introduction">Introduction</h3>
<h4 id="primary-concept">primary concept</h4>
<blockquote>
<p><strong>free abelian group</strong></p>
<p>G is an abelian group with a basis, then any element in G could be uniquely expressed as an integer combination of finitely basis elements, like a 2-dim lattice in <span class="math inline">\(\mathbb{Z}\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>module</strong></p>
<p>module is an algebraic structure which is extension of vector space, scalar multiplication of module could be a ring instead of a field in vector space.</p>
<p>ideal is a kind of module, more details could be seen <a href="https://math.stackexchange.com/questions/1776913/a-conceptual-question-in-ring-theory">here</a>.</p>
</blockquote>
<blockquote>
<p><strong>field of fractions</strong></p>
<p>Frac(R) means a field is defined based on a integral domain R like Q based on Z, which uses an equivalence relation on <span class="math inline">\(R\times R\backslash \{0\}\)</span> by letting <span class="math inline">\((n, d) \sim (m, b)\)</span> whenever <span class="math inline">\(nb =md\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>fractional ideal</strong></p>
<p>A fractional ideal <span class="math inline">\(I\)</span> of R is an R-submodule, and it’s a subgroup of Frac(R). There exists a non-zero <span class="math inline">\(r \in R\)</span> let <span class="math inline">\(rI \subset R\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>proper ideal</strong></p>
<p>Any ideal of a ring which is strictly smaller than the whole ring.</p>
</blockquote>
<blockquote>
<p><strong>principal ideal</strong></p>
<p>An ideal which is generated by a single element, like <span class="math inline">\((2) \subset \mathbb{Z}\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>exact sequence</strong></p>
<p>A sequence of group homomorphisms between groups like:</p>
<p><span class="math inline">\(G_0 \stackrel{f_1}\rightarrow G_1 \stackrel{f_2}\rightarrow \dots \stackrel{f_n}\rightarrow G_n\)</span>, <span class="math inline">\(im(f_i) = ker(f_{i+1})\)</span></p>
<p><span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> in sequence always mean trivial group <span class="math inline">\(\{0\}, \{1\}\)</span>.</p>
<p>for sequences whose form like <span class="math inline">\(0 \rightarrow A \stackrel{f}\rightarrow B \stackrel{g}\rightarrow C \rightarrow 0\)</span>, which is called ‘short exact sequences’. <span class="math inline">\(f\)</span> is monomorphism (injective or one-to-one) and <span class="math inline">\(g\)</span> is an epimorphism</p>
</blockquote>
<h4 id="symbol">symbol</h4>
<p><span class="math inline">\(K^{\times}\)</span>: the multiplicative group of units in K.</p>
<p><span class="math inline">\(O_K\)</span> : the ring of integers in field K, which contains all algebraic integers in K.</p>
<h4 id="p8">p8</h4>
<p>The definition of <strong>norm map</strong> is in <a href="https://en.wikipedia.org/wiki/Field_norm">Field norm</a>, <span class="math inline">\(N_{L/K} (\alpha) = \prod_{\sigma\in Gal(L/K)} \sigma(\alpha)\)</span></p>
<p>this is multiplicative, the details of norm could be found in <a href="#p31">p31</a></p>
<h4 id="p10">p10</h4>
<p>There’s two errors here</p>
<ol type="1">
<li><p><span class="math inline">\((1+\sqrt{-5})^2 = -4 + 2\sqrt{-5}\)</span>, but <span class="math inline">\((2, 1 + \sqrt{-5})^2\)</span> still be equal to <span class="math inline">\((2)\)</span>.</p></li>
<li><p><span class="math inline">\((2, 1+\sqrt{-5})(3, 1-\sqrt{-5})\)</span> should be <span class="math inline">\((6, 3+3\sqrt{-5}, 2-2\sqrt{-5})\)</span></p>
<ol type="1">
<li><p>as book says, <span class="math inline">\((2, 1+\sqrt{-5})^2 = (4, -4 + 2\sqrt{-5}, 2+2\sqrt{-5}) = (2)\)</span></p></li>
<li><p><span class="math inline">\((3, 1+\sqrt{-5})(3, 1-\sqrt{-5}) = (9, 3+3\sqrt{-5}, 3-3\sqrt{-5}, 6) \subset (3)\)</span></p>
<p><span class="math inline">\(3 = 9-6 \in (9, 3+3\sqrt{-5}, 3-3\sqrt{-5}, 6)\)</span></p>
<p>so <span class="math inline">\((3, 1+\sqrt{-5})(3, 1-\sqrt{-5}) = (3)\)</span></p></li>
<li><p><span class="math inline">\((2, 1+\sqrt{-5})(3, 1+\sqrt{-5}) = (6, 3+3\sqrt{-5}, 2+2\sqrt{-5}, -4 + 2\sqrt{-5})\)</span></p>
<p><span class="math inline">\(6 = (1+\sqrt{-5})(1-\sqrt{-5})\)</span>, <span class="math inline">\(-4 + 2\sqrt{-5}= (1+\sqrt{-5})^2\)</span></p>
<p><span class="math inline">\((2, 1+\sqrt{-5})(3, 1+\sqrt{-5}) = (1+\sqrt{-5})\)</span></p>
<p>so <span class="math inline">\((2, 1+\sqrt{-5})(3, 1+\sqrt{-5}) \subset (1+\sqrt{-5})\)</span></p>
<p>and $1+ =3+3 - (2+2) (2, 1+)(3, 1+) $</p>
<p>so <span class="math inline">\((2, 1+\sqrt{-5})(3, 1+\sqrt{-5}) = (1+\sqrt{-5})\)</span></p></li>
<li><p><span class="math inline">\((2, 1+\sqrt{-5})(3, 1-\sqrt{-5}) = (6, 3+3\sqrt{-5}, 2-2\sqrt{-5})\)</span></p>
<p><span class="math inline">\(1-\sqrt{-5} = 6 - (3+3\sqrt{-5} + 2-2\sqrt{-5}) \in (6, 3+3\sqrt{-5}, 2-2\sqrt{-5})\)</span></p>
<p><span class="math inline">\((6, 3+3\sqrt{-5}, 2-2\sqrt{-5}) \subset (1+\sqrt{-5}, 1-\sqrt{-5})\)</span></p></li>
</ol></li>
</ol>
<h4 id="p11">p11</h4>
<p><strong>doubtful point</strong>:</p>
<p>units of <span class="math inline">\(\mathbb{Z}[\sqrt2]\)</span> are not only <span class="math inline">\(1+\sqrt 2\)</span>, why <span class="math inline">\(\mathbb{Z}[\sqrt 2]^{\times} = \{\pm(1+\sqrt 2)^m | m \in \mathbb{Z}\}\)</span>?</p>
<p>maybe in <span class="math inline">\(\mathbb{Z}[\sqrt 2]^{\times}\)</span>, we could still use addition?</p>
<h4 id="exercises">exercises</h4>
<ol type="1">
<li><p><span class="math inline">\(d\)</span>, a square-free number, <span class="math inline">\(K = \mathbb{Q}[\sqrt d]\)</span>, we talk about <span class="math inline">\(O_K\)</span> here.</p>
<p>​ Let <span class="math inline">\(\alpha = a+b \sqrt d, b \neq 0, a, b\in \mathbb{Q}\)</span>, then if <span class="math inline">\(\alpha \in O_K\)</span>,</p>
<p>it should satisfy <span class="math inline">\(2a \in \mathbb{Z}, a^2-b^2d\in \mathbb{Z}\)</span></p>
<p>​ If <span class="math inline">\(a, b \in \mathbb{Z}\)</span>, it’s obviously that the condition are met whatever d is.</p>
<p>​ if <span class="math inline">\(a \notin \mathbb{Z}\)</span>, it should be a half-integer, set <span class="math inline">\(a = \frac{1}{2} + a&#39;\)</span>, <span class="math inline">\(\frac{1-4b^2d}{4}\)</span> should be an integer, which is equivalent to <span class="math inline">\(4b^2d \equiv 1 \mod 4\)</span>. if this work , the coefficient <span class="math inline">\(4\)</span> should be cancelled, and <span class="math inline">\(4b^2d\)</span> should be an integer, so b is a half-integer too, set <span class="math inline">\(b = b&#39; + \frac{1}{2}\)</span>, then it turns to <span class="math inline">\(d \equiv 1\mod 4\)</span>.</p>
<p>​ After all, if <span class="math inline">\(d \equiv 1 \mod 4\)</span>, <span class="math inline">\(a, b\)</span> could be all half-integer or all integer, else <span class="math inline">\(a, b\)</span> should be all integer.</p></li>
<li><p>In <span class="math inline">\(\mathbb{Z}[\sqrt{-5}]\)</span>, proof <span class="math inline">\((6) = (2, 1+\sqrt{-5})^2(3, 1+\sqrt{-5})(3, 1-\sqrt{-5})\)</span> is a factorization of <span class="math inline">\((6)\)</span> into a product of prime ideals.</p>
<ol type="1">
<li><p><span class="math inline">\((2, 1+\sqrt{-5})\)</span> is prime means:</p>
<p><span class="math inline">\(\forall a, b\in \mathbb{Z},\)</span> if <span class="math inline">\((2a+(1+\sqrt{-5})b)\ |\ (cd),\ c, d \in \mathbb{Z}[\sqrt{-5}]\)</span></p>
<p>then <span class="math inline">\(c \in (2, 1+\sqrt{-5})\)</span> or <span class="math inline">\(d \in (2, 1+\sqrt{-5})\)</span>.</p>
<p>Let <span class="math inline">\(c = c_0 + c_1\sqrt{-5}, d = d_0 + d_1\sqrt{-5}\)</span>, then we have</p>
<p><span class="math inline">\(2(2a^2 + 3b^2+2ab)\ |\ (c_0^2+5c_1^2)(d_0^2+5d_1^2)\)</span></p>
<p><span class="math inline">\(2\)</span> is prime, which means <span class="math inline">\((c_0^2 + 5c_1^2) \in (2)\)</span> or <span class="math inline">\((d_0^2 + 5d_1^2) \in (2)\)</span></p>
<p>so <span class="math inline">\((2, 1+\sqrt{-5})\)</span> is prime.</p></li>
<li><p><span class="math inline">\((3, 1+\sqrt{-5})\)</span> is prime means:</p>
<p><span class="math inline">\(\forall a, b\in \mathbb{Z},\)</span> if <span class="math inline">\((3a+(1+\sqrt{-5})b)\ |\ (cd),\ c, d \in \mathbb{Z}[\sqrt{-5}]\)</span></p>
<p>then <span class="math inline">\(c \in (3, 1+\sqrt{-5})\)</span> or <span class="math inline">\(d \in (3, 1+\sqrt{-5})\)</span>.</p>
<p>Let <span class="math inline">\(c = c_0 + c_1\sqrt{-5}, d = d_0 + d_1\sqrt{-5}\)</span>, then we have</p>
<p><span class="math inline">\(3(3a^2 + 2b^2+2ab)\ | \ (c_0^2+5c_1^2)(d_0^2+5d_1^2)\)</span></p>
<p><span class="math inline">\(3\)</span> is prime, which means <span class="math inline">\((c_0^2 + 5c_1^2) \in (3)\)</span> or <span class="math inline">\((d_0^2 + 5d_1^2) \in (3))\)</span></p>
<p>so <span class="math inline">\((3, 1+\sqrt{-5})\)</span> is prime.</p></li>
<li><p>In a similar way, we could also prove that <span class="math inline">\((3, 1-\sqrt{-5})\)</span> is prime.</p></li>
</ol></li>
</ol>
<h3 id="commutative-algebra">Commutative Algebra</h3>
<p>some details in this chapter would be found <a href="https://www.jmilne.org/math/xnotes/CA221.pdf">here</a>.</p>
<h4 id="primary-concept-1">primary concept</h4>
<blockquote>
<p><strong>quotient ring</strong></p>
<p>use an equivalence relation <span class="math inline">\(\sim\)</span> on a ring <span class="math inline">\(R\)</span>, <span class="math inline">\(I\)</span> is a two-sided ideal in R:</p>
<p>$a b $ if and only if <span class="math inline">\((a-b) \in I\)</span></p>
<p><span class="math inline">\(a \mod I\)</span> is the equivalence class of element <span class="math inline">\(a \in R\)</span>, <span class="math inline">\([a] = a+I:=\{a+r|r\in I\}\)</span></p>
<p>we call <span class="math inline">\(R/I\)</span> a quotient ring which is <span class="math inline">\(\{a \mod I | a\in R\}\)</span></p>
<p>zero-element in <span class="math inline">\(R/I\)</span> is <span class="math inline">\(I\)</span>, multiplicateive identity is <span class="math inline">\(1+I\)</span></p>
</blockquote>
<blockquote>
<p><strong>Euclidean domain</strong></p>
<p>A Euclidean domain is an integral domain which can be endowed with at least one Euclidean function.</p>
<p>A Euclidean function on an integral domain R is a function <span class="math inline">\(f: R\backslash\{0\} \rightarrow \{a\ | \ a \geq 0\}\)</span> which satisfies:</p>
<p><span class="math inline">\(\forall a, b \in R, b \neq 0\)</span>, there exist <span class="math inline">\(q, r \in R,\quad a = b q + r\)</span></p>
<p>and <span class="math inline">\(r= 0\)</span> or <span class="math inline">\(f(r) &lt; f(b)\)</span></p>
</blockquote>
<blockquote>
<p><strong>algebra</strong></p>
<p>Let <span class="math inline">\(K\)</span> be a field, and let <span class="math inline">\(A\)</span> be a vector space over K, if there’s a bilinear map <span class="math inline">\(A \times A \rightarrow A\)</span> on A, then we call <span class="math inline">\(A\)</span> as <span class="math inline">\(K\)</span>-algebra, and <span class="math inline">\(K\)</span> is the base field of <span class="math inline">\(A\)</span>.</p>
</blockquote>
<h4 id="symbol-1">symbol</h4>
<p><span class="math display">\[{\rm Hom}\]</span>: For two modules <span class="math inline">\(M, N\)</span> over a ring <span class="math inline">\(R\)</span>, <span class="math inline">\({\rm Hom}_R(M, N)\)</span> denotes the set of all module homomorphisms from <span class="math inline">\(M\)</span> to <span class="math inline">\(N\)</span>.</p>
<h4 id="p17">p17</h4>
<p>In the first one of Nakayama’s Lemma, <span class="math inline">\(\mathfrak{a}\)</span> should be an ideal contained in all maximal ideals of <span class="math inline">\(A\)</span>, this make <span class="math inline">\(1-a_1\)</span> not be in <span class="math inline">\(\mathfrak{m}\)</span>, more details could be seen <a href="http://homepage.divms.uiowa.edu/~acwood/files/notes/nakayamaslemma.pdf">here</a>.</p>
<h4 id="p18">p18</h4>
<p><span class="math inline">\(\mathfrak{a}^e \in S^{-1}A\)</span> means <span class="math inline">\(\{a/s \ | \ a \in \mathfrak{a}, s\in S\}\)</span></p>
<p>For <span class="math inline">\(\mathfrak{a}\)</span> an a ideal of <span class="math inline">\(S^{-1}A\)</span>, <span class="math inline">\(\mathfrak{a} \cap A\)</span> means all integer in <span class="math inline">\(\mathfrak{a}\)</span>.</p>
<h4 id="p19">p19</h4>
<p>'<span class="math inline">\(\mathfrak{p}\)</span> a prime ideal in <span class="math inline">\(S^{-1}A \Rightarrow \mathfrak{p} \cap A\)</span> is a prime ideal in <span class="math inline">\(A\)</span> disjoint from <span class="math inline">\(S\)</span>’ is not clear, <span class="math inline">\(\mathfrak{p} = \{\frac{a}{b} \ | \ a\in \mathfrak{p}&#39;, b \in S\}\)</span> has to satisfies <span class="math inline">\(\mathfrak{p}&#39; \cap S = \varnothing\)</span></p>
<p><span class="math inline">\(A_{\mathfrak{p}}\)</span> means <span class="math inline">\((A-\mathfrak{p})^{-1}A\)</span>, more details could be seen <a href="https://www.math.purdue.edu/~sbasu/teaching/fall08/557/Week3.pdf">here</a>.</p>
<p>Conversely thinking, if there’s another genertors <span class="math inline">\(w\)</span> in <span class="math inline">\(\mathfrak{p}A_{\mathfrak{p}}\)</span>, then $w (A-)^{-1}(A-) $, it would make <span class="math inline">\(\mathfrak{p}A_{\mathfrak{p}}\)</span> and <span class="math inline">\(A\)</span> equal. We could use some examples in <span class="math inline">\(\mathbb{Z}\)</span> to help us understand.</p>
<p>To understand <span class="math inline">\((m) + (n) = \mathbb{Z}\)</span> if and only if <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> are relatively prime. We could think back to <span class="math inline">\(GCD\)</span> on <span class="math inline">\(\mathbb{Z}\)</span>, if <span class="math inline">\(GCD(m, n) = 1\)</span>, then <span class="math inline">\(\exists\ s, t, \ sm+tn = 1\)</span>.</p>
<h4 id="p20">p20</h4>
<p><span class="math inline">\(\mathfrak{a} \mathfrak{b} = \{\sum_ia_ib_i\ | \ a_i\in \mathfrak{a}, b_i\in \mathfrak{b}\}, c\in \mathfrak{a}_1 \cap \mathfrak{a}_2\)</span>, which means <span class="math inline">\(a_1c+a_2c \in \mathfrak{a_1} \mathfrak{a_2}\)</span>.</p>
<p>the detailed proof of <span class="math inline">\(A/(\mathfrak{a}_1 \cap \mathfrak{a}_2) \simeq A/\mathfrak{a}_1 \times A/ \mathfrak{a}_2\)</span> could be seen <a href="https://math.stackexchange.com/questions/1102037/the-chinese-remainder-theorem-for-rings">here</a>.</p>
<h4 id="p21">p21</h4>
<p><strong>doubtful point</strong>: element in <span class="math inline">\(\otimes_iM_i\)</span> should be like <span class="math inline">\((m_0, m_1, \dots)\)</span>, but why the isomorphism map be <span class="math inline">\((\sum m_i) \otimes (\sum n_j) \rightarrow \sum m_i \otimes n_j\)</span></p>
<h4 id="p22">p22</h4>
<p>proof for $M/aM (A/)_A M $ could be seen <a href="https://math.stackexchange.com/questions/682468/given-ring-a-ideal-i-and-a-module-m-show-that-a-i-otimes-a-m-is-is">here</a>. The point is why <span class="math inline">\(im(\mathfrak{a} \otimes_A M) \cap M = \mathfrak{a}M = \{\sum a_im_i \ | \ a_i \in \mathfrak{a}, m_i \in M\}\)</span>, firstly I think for different bilinear map <span class="math inline">\(f\)</span>, then <span class="math inline">\(\mathfrak{a} \otimes_A M\)</span> should be different. But then I realized that all the rings are isomorphic, so we could use an simple bilinear map <span class="math inline">\(f(a, b) = a \cdot b\)</span>, then we get <span class="math inline">\(im(\mathfrak{a} \otimes_A M) \cap M= \{\sum a_im_i \ | \ a_i \in \mathfrak{a}, m_i \in M\}\)</span>.</p>
<p>For counter-example about <span class="math inline">\(M \rightarrow N\)</span> is injective but <span class="math inline">\(M \otimes_A P \rightarrow N \otimes_A P\)</span> is not.</p>
<p>We know that <span class="math inline">\(M \otimes_A P \rightarrow N \otimes_A P = (M\rightarrow N)\otimes_AP\)</span></p>
<p>Let <span class="math inline">\(A = \mathbb{Z}, M = \mathbb{Z}, N = m\mathbb{Z}, P = \mathbb{Z}/ m\mathbb{Z}\)</span>, then <span class="math inline">\(M \rightarrow N\)</span> s injective, and <span class="math inline">\(M \otimes_A P \rightarrow N \otimes_A P\)</span> is a zero map.</p>
<h4 id="p23">p23</h4>
<p>the reason of using <span class="math inline">\(m \rightarrow 1\otimes m\)</span> to denote the map from <span class="math inline">\(M\)</span> to <span class="math inline">\(B \otimes_A M\)</span> is that <span class="math inline">\(B\otimes_A M \simeq \{bm\ | \ b\in B, m\in M \} \simeq \{1 \otimes m\ | \ m \in M\}\)</span></p>
<hr>
<p><em>Because I’m not familiar with field, so maybe compelete notes on this part later.</em></p>
<hr>
<h4 id="exercises-1">exercises</h4>
<ol type="1">
<li><p>If <span class="math inline">\(S\)</span> is saturated, we assumpt that its complement isnot a union of prime ideals, which means there’s at least one prime ideal <span class="math inline">\(I\)</span> satisfies:</p>
<p><span class="math inline">\(\exists I_0 \subseteq S,\ I_0 \not \subset A\backslash S,\quad \ I\backslash I_0 \subseteq A\backslash S,\ I\backslash I_0\not \subset S\)</span></p>
<p>then because of the property of being saturated , <span class="math inline">\(\exists i_0 \in I_0, i_0 \in S\)</span>, <span class="math inline">\(i_0\)</span> is prime, so <span class="math inline">\(\{1, i_0, i_0^2, \dots, i_0^n, \dots \} \subseteq S\)</span>. Let <span class="math inline">\(U\)</span> be the set of all the units, because <span class="math inline">\(1 \in S\)</span>, then <span class="math inline">\(U \subseteq S\)</span>. For all the prime ideals with one generator $(i_0), (i_1), , $ the set <span class="math inline">\(\{1, i_j, i_j^2, \dots, i_j^n, \dots \} = A\backslash U - \cup_{ k\neq j}(i_k)\)</span>.</p>
<p>so in this case, all the elements in <span class="math inline">\(I\backslash I_0\)</span> could still be allocated to other prime ideals, the assumption is false.</p>
<p>If complement of <span class="math inline">\(S\)</span> is a union of prime ideals, then according to above proof, S should be like <span class="math inline">\(A- \cup_{ k\notin J}(i_k) = \cup_{j\in J}\{1, i_j, i_j^2, \dots,i_j^n,\dots \} \cup U\)</span>, then <span class="math inline">\(\forall s \in S\)</span>, the form of it is <span class="math inline">\(\prod_{j\in J} i_j^{e_j}, e_j \in \mathbb{Z}\)</span>, clearly it’s saturated.</p></li>
<li><p>According to 1, we know that <span class="math inline">\(S&#39; = S\)</span> could satisfy the need.</p>
<p>For <span class="math inline">\(S^{-1}A = \{\frac{a}{s} \ | \ a\in A, s \in S\}\)</span>, the form of <span class="math inline">\(\frac{a}{s}\)</span> is <span class="math inline">\(\frac{a}{\prod_{j\in J} i_j^{e_j}} , e_j \in \mathbb{Z}\)</span>.</p>
<p>so for prime ideal <span class="math inline">\(i_w \in A\)</span>, <span class="math inline">\((\frac{1}{i_w})\)</span> is still a prime ideal in <span class="math inline">\(S^{-1}A\)</span>.</p></li>
</ol>
<h3 id="rings-of-integers">Rings of Integers</h3>
<h4 id="primary-concept-2">primary concept</h4>
<blockquote>
<p><strong>separable extension</strong></p>
<p>for an algebraic field enxtension <span class="math inline">\(E \supseteq F\)</span> is called a separable extension if <span class="math inline">\(\forall \alpha \in E\)</span>, its minimal polybomial over <span class="math inline">\(F\)</span> is a separable polynomial (the polynomial’s roots are distinct, without multiple root).</p>
</blockquote>
<blockquote>
<p><strong>dual space</strong></p>
<p>For a vector space <span class="math inline">\(V\)</span> over a field <span class="math inline">\(F\)</span>, dual space <span class="math inline">\(V^{\lor}\)</span> is the set of all linear maps from <span class="math inline">\(V\)</span> to <span class="math inline">\(F\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>Kronecker delta</strong></p>
<p><span class="math inline">\(\delta_{ij} = 0\)</span> if <span class="math inline">\(i \neq j\)</span> else <span class="math inline">\(1\)</span>.</p>
</blockquote>
<blockquote>
<p><strong>stem field</strong></p>
<p><span class="math inline">\(K\)</span> a field, and <span class="math inline">\(f \in K[x]\)</span> is an irreducible polynomial. The ring <span class="math inline">\(L = K[x]/(f)\)</span> is a field, with a distinguished root <span class="math inline">\(\overline x = x + (f)\)</span> of <span class="math inline">\(f\)</span>. The stem field of <span class="math inline">\(f\)</span> is the pair <span class="math inline">\((L, \overline x)\)</span>.</p>
</blockquote>
<h4 id="symbol-2">symbol</h4>
<p><span class="math inline">\((k_{ij})\)</span>: sometime means a matrix <span class="math inline">\(M\)</span> satisfy <span class="math inline">\(M_{ij} = k_{ij}\)</span></p>
<h4 id="p25">p25</h4>
<p>symmetric polynomial means all the coefficients in the polynomial has equal status.</p>
<h4 id="p26">p26</h4>
<p>Cause <span class="math inline">\(h(X)\)</span> is a product of monomials, so we could take <span class="math inline">\(g(\alpha_{\sigma(1)}, \dots,\alpha_{\sigma(n))})\)</span> as <span class="math inline">\(g_i(\alpha_1, \dots, \alpha_n)\)</span>, then the coefficient polynomials would be symmetric after expanding the product.</p>
<p>The point is: for any integral elements $ , $, <span class="math inline">\(\alpha +\beta, \alpha \beta\)</span> are still integral elements.</p>
<p>For the first proof, the chain of thought should be:</p>
<p>‘symmetric polynomials are polynomials of symmetric elementary polynomials’ <span class="math inline">\(\Rightarrow\)</span></p>
<p>‘plug integral elements in any polynomial in <span class="math inline">\(A[X]\)</span> would get other integral elements.’ <span class="math inline">\(\Rightarrow\)</span></p>
<p>then we use polynomials <span class="math inline">\(x+y / xy\)</span> to get ‘all integral elements form a ring’.</p>
<p>At the end of the second proof, the point is <span class="math inline">\(\alpha \beta M, (\alpha \beta) M\)</span> all in <span class="math inline">\(M\)</span>.</p>
<h4 id="p28">p28</h4>
<p>another proof of <strong>Proposition 2.9</strong> could be seen <a href="https://proofwiki.org/wiki/Unique_Factorization_Domain_is_Integrally_Closed">here</a>. <span class="math inline">\(a, b\)</span> are not random elements in <span class="math inline">\(A\)</span>.</p>
<h4 id="p29">p29</h4>
<p>For proposition 2.11, firstly I’m confused about ‘some <span class="math inline">\(a_i \in A\)</span>’, if $$ is integral over A, then all <span class="math inline">\(a_i\)</span> should be in <span class="math inline">\(A\)</span>. The rest part of proof are clearly, we know all integral elements form a ring, so if all the roots are integral over <span class="math inline">\(A\)</span>, and so are all the coefficients. The proof in book has proved that if an element <span class="math inline">\(\alpha\)</span> of <span class="math inline">\(L\)</span> is integral over <span class="math inline">\(A\)</span>, then all the coefficients of its minimal polynomial over K are in <span class="math inline">\(A\)</span>.</p>
<p>And conversely, I know ‘some’ works that if there’s no coefficient of <span class="math inline">\(\alpha\)</span> minimal polynomial over <span class="math inline">\(K\)</span> is in <span class="math inline">\(A\)</span>, then <span class="math inline">\(\alpha\)</span> would not be integral over <span class="math inline">\(A\)</span>.</p>
<p>Also, I’m confused about proposition 2.13, any A-algebra should be a vector space, then it should be a A-module, why need to prove that.</p>
<h4 id="p31"><span id="p31">p31 </span></h4>
<p>There’s an example could help us to understand the determinant of a basis of module works <a href="https://math.stackexchange.com/questions/3255768/determinant-for-a-basis-of-a-free-module">here</a>.</p>
<p>The proof of ‘index of <span class="math inline">\(N\)</span> is <span class="math inline">\(det(a_{ij})\)</span>’ could be seen <a href="https://math.stackexchange.com/questions/920870/explain-why-the-determinant-of-a-is-the-index-of-the-subring">here</a>. We could associate it with the relation with determinant of lattice and sublattice (In <span class="math inline">\(\mathbb{Z}^n\)</span>, determinant of sublattice is multiple of determinant of lattice.).</p>
<blockquote>
<p><strong>trace</strong> and <strong>norm</strong></p>
<p>Consider <span class="math inline">\(L/K\)</span> as an extension of fields of degree <span class="math inline">\(n\)</span>. The <strong>trace</strong> of <span class="math inline">\(x \in L\)</span> is the trace of the <span class="math inline">\(K\)</span>-linear endomorphism <span class="math inline">\(m_x: L\rightarrow L, m_x(y) = xy\)</span>, the <strong>norm</strong> of <span class="math inline">\(x\)</span> is <span class="math inline">\(det(m_x)\)</span>.</p>
<p>Computational procedure (for element $ x L$, basis is <span class="math inline">\(\{e_0,\dots, e_{n-1}\}\)</span>):</p>
<ol type="1">
<li>calculate vector: <span class="math inline">\(\vec m_{xy} = x (e_0y_0, \dots, e_{n-1}y_{n-1})\)</span></li>
<li>calculate matrix: <span class="math inline">\(m_x : m_x \times \vec m_{xy} = (y_0, \dots, y_{n-1})\)</span></li>
<li>calculate trace and norm: <span class="math inline">\(Tr(x) = Tr(m_x), Nm(x) = det(m_x)\)</span></li>
</ol>
</blockquote>
<p>For proposition 2.19, it build a field <span class="math inline">\(K[\beta]\)</span> in the middle to complete the proof. <span class="math inline">\(L = K[\beta]\)</span> in the proof is not the previous <span class="math inline">\(L\)</span>. For <span class="math inline">\(L/K\)</span> with basis <span class="math inline">\(\{1, \beta, \beta^2, \dots, \beta^{n-1}\}\)</span>, we could get trace and norm as follow $$ f(x) = x^n - <em>1x^{n-1} - - </em>{n-1}x - _n \</p>
<p>= _1, f(_i) = 0, i = 1, 2, , n-1\</p>
m_x =
<span class="math display">\[\begin{bmatrix}
0 &amp;\cdots  &amp; 0 &amp; \alpha_n\\
1 &amp; \cdots &amp; 0 &amp; \alpha_{n-1}\\
\vdots &amp; \ddots &amp; \vdots &amp; \vdots\\
0 &amp; \cdots &amp; 1 &amp; \alpha_1
\end{bmatrix}\]</span>
<p>$$ use Vieta’s formulas, we get <span class="math inline">\(Tr(\beta) = \alpha_{1} = \sum \beta_i, Nm(\beta) =(-1)^n\alpha_n = \prod \beta_i\)</span>, and 2.19 extend it to some <span class="math inline">\(L\)</span> with degree bigger than <span class="math inline">\(n\)</span>.</p>
<h4 id="p32">p32</h4>
<p>In corollary 2.20, <span class="math inline">\(\sigma_i\)</span> are all homomorphisms, <span class="math inline">\(\sigma_i \beta\)</span> means <span class="math inline">\(\sigma_i(\beta)\)</span></p>
<p>In this page, I’m confused the difference between module and extension, because in <span class="math inline">\(Tr_{B/A}\)</span>, somtimes <span class="math inline">\(B\)</span> is an extension over <span class="math inline">\(A\)</span>, sometimes <span class="math inline">\(B\)</span> is <span class="math inline">\(A\)</span>-module. The point is that we could think that if <span class="math inline">\(B\)</span> is a <span class="math inline">\(A\)</span>-module which is a 2-dims vector space, then we couldn’t define the polynomial for <span class="math inline">\(B/A\)</span>, how could we calculate <span class="math inline">\(Tr_{B/A}\)</span>.</p>
<p>Then we could see <a href="https://math.stackexchange.com/questions/2365940/trace-operators-on-modules">here</a>, the second answer gives a construction for vector space like module, then we know the <span class="math inline">\(Tr\)</span> is just an operator, if meet its property, it could exist, in general case, it’s called the <a href="https://mathoverflow.net/questions/156264/trace-of-finitely-generated-projective-module">Hattori-Stallings trace</a>.</p>
<h4 id="p33">p33</h4>
<p>How to construct the isomorphism from <span class="math inline">\(V^{\lor}\)</span> to <span class="math inline">\(V\)</span> could be seen <a href="https://math.stackexchange.com/questions/105490/isomorphisms-between-a-finite-dimensional-vector-space-and-its-dual">here</a>.</p>
<p>If got any more question about discriminant, you may get the answer <a href="http://math.stanford.edu/~conrad/676Page/handouts/discexist.pdf">here</a>.</p>
<h4 id="p35">p35</h4>
<p>For corollary 2.30, I think we could know the basis <span class="math inline">\(\{\beta_1, \dots, \beta_m\}\)</span> of <span class="math inline">\(L\)</span> could all in <span class="math inline">\(O_L\)</span>, so the subring of <span class="math inline">\(L\)</span> which is finitely generated as a <span class="math inline">\(\mathbb{Z}\)</span>-module is also generated by basis in <span class="math inline">\(O_L\)</span>, clearly <span class="math inline">\(O_L\)</span> is the largest subring.</p>
<h4 id="p36">p36</h4>
<p>In Remark 2.33, <span class="math inline">\(Tr(\beta \beta_i) \in A , i=1, \dots, m\)</span> means that a ‘dual’ basis <span class="math inline">\(\{\beta_1&#39;, \dots, \beta_m&#39;\}\)</span> is in <span class="math inline">\(C^*\)</span>, then we know the conclusion from 2.29.</p>
<h4 id="p39">p39</h4>
<p>If <span class="math inline">\(D(1, \alpha, \dots, \alpha^{m-1})\)</span> doesn’t contain any square factor, then if should be <span class="math inline">\(disc(O_K/\mathbb{Z})\)</span>, and <span class="math inline">\(|O_K| = |\mathbb{Z}[\alpha]|\)</span>, then we knwo <span class="math inline">\(O_K = \mathbb{Z}[\alpha]\)</span>.</p>
<p>sign function here just means the plus or minus of integer.</p>
<p>According to 2.34, we know <span class="math inline">\(D(1, \beta, \dots, \beta^{m-1}) = \prod_{1\leq i\leq j\leq m}(\beta_i-\beta_j)^2\)</span>, then we know 2.40(a).</p>
<p>detailed proof of Stickllberger’s Theorem could be seen <a href="https://math.stackexchange.com/questions/394785/proof-of-stickelberger-s-theorem">here</a>.</p>
<p>proof for $a^2 , 1, a $</p>
<p>if <span class="math inline">\(\exists a\in \mathbb{Z}, a^2 \equiv 2 \mod 4\)</span>, then <span class="math inline">\(a^2 = 4k+2 = 2(2k+1)\)</span>, the right side only has one 2 factor, so there’s a contradiction.</p>
<p>if <span class="math inline">\(\exists a \in \mathbb{Z}, a\equiv 3\mod 4\)</span>, then <span class="math inline">\(a^2-1 = 4k+2 \Rightarrow (a+1)(a-1)=2(2k+1)\)</span>, the left side has two 2 factor, but the right side only has one.</p>
<h4 id="p41">p41</h4>
<p>I use sagemath to do the same work as PARI do in the book.</p>
<p><img src="/2022/01/19/Notes-on-Algebraic-Number-Theory/image-20220130113325852.png"></p>
<figure>
<img src="/2022/01/19/Notes-on-Algebraic-Number-Theory/image-20220130113713512.png" alt="image-20220130113713512"><figcaption aria-hidden="true">image-20220130113713512</figcaption>
</figure>
<h4 id="exercise">exercise</h4>
<ol type="1">
<li><p>To find an example, we want <span class="math inline">\(\alpha = (a+b\sqrt 5)(c+d\sqrt 5) = (e+f\sqrt 5)(g + h\sqrt 5)\)</span> with <span class="math inline">\(a \neq e, a \neq g\)</span>, so the variables should satisfy <span class="math inline">\(ac + 5bd = eg + 5hf, ad + bc = eh+ fg\)</span>.</p>
<p>While, it’s too bother, let’s just use <span class="math inline">\(-4 = -2 \cdot 2 = (1+\sqrt 5)\cdot (1-\sqrt 5)\)</span>.</p></li>
<li><p>If <span class="math inline">\(f(X)\)</span> is reducible in <span class="math inline">\(K[X]\)</span>, which means <span class="math inline">\(f(X) = f_0(X)f_1(X)...fn(X)\)</span> with <span class="math inline">\(f_i(X) \in K[X]\)</span>. We know that <span class="math inline">\(f(X) \in A[X]\)</span>, so all the roots of <span class="math inline">\(f(X)\)</span> are integral over <span class="math inline">\(A\)</span>. For <span class="math inline">\(f_0(X)\)</span>, the roots of <span class="math inline">\(f_0\)</span> are all integral over A, so all the coefficients should be integral over <span class="math inline">\(A\)</span>, then they are all in <span class="math inline">\(A\)</span>.</p></li>
<li><p>Let <span class="math inline">\(L = K[\beta]\)</span>, <span class="math inline">\(\beta\)</span> is one root of <span class="math inline">\(f(X) \in K[X]\)</span>. From 2.34, we know that <span class="math inline">\(disc(L/K) = (-1)^{\frac{m(m-1)}{2}}\prod_i(\prod_{j\neq i} (\beta_i-\beta_j))\)</span>, <span class="math inline">\(\beta_1=\beta, \beta_2, \dots, \beta_n\)</span> are the roots of <span class="math inline">\(f(X)\)</span>, because <span class="math inline">\(L/K\)</span> is not separable, then there exists <span class="math inline">\(\beta_s =\beta_t\)</span>, <span class="math inline">\(disc(L/K) = 0\)</span>.</p></li>
<li><p><span class="math inline">\(\mathfrak{a} \neq (2)\)</span> is clearly, <span class="math inline">\(\mathfrak{a}^2 = (4, 2+2\sqrt{-3}, -2+2\sqrt{-3})\)</span>, <span class="math inline">\(-2+2\sqrt{-3} = 2+2\sqrt{-3} - 4\)</span>, then <span class="math inline">\(\mathfrak{a}^2 = (4, 2+2\sqrt{-3}) = (2)\mathfrak{a}\)</span>.</p>
<p>In <span class="math inline">\(\mathbb{Z}[\sqrt{-3}]\)</span>, there exists <span class="math inline">\(10 = 2 \cdot 5 = (1+\sqrt{-3})(1-\sqrt{-3})\)</span>, so it couldn’t factor uniquely.</p></li>
<li><p>For <span class="math inline">\(\alpha \in A[\beta] \cap A[\beta ^{-1}]\)</span>, there will be two polynomials <span class="math inline">\(f(X) \in A[\beta][X]\)</span>, <span class="math inline">\(g(X)\in A[\beta^{-1}][X]\)</span>, with $f() = g() = $, and the coefficients of two polynomials are all in <span class="math inline">\(A\)</span>, we let <span class="math inline">\(deg(f) = m, deg(g) = n\)</span></p>
<p>We set <span class="math inline">\(M = A + A\beta + \dots + A\beta^{m+n}\)</span>, then we wonder if <span class="math inline">\(\alpha \beta^k\)</span> is in <span class="math inline">\(M\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(0 \leq k &lt; n\)</span>: <span class="math inline">\(\alpha \beta^k = \beta^kf(\beta) \in M\)</span></li>
<li><span class="math inline">\(n\leq k \leq m+n\)</span>: <span class="math inline">\(\alpha \beta^k = \beta^{k-n} \alpha \beta^{n} \in M\)</span></li>
</ol>
<p>then we know that <span class="math inline">\(\alpha \beta^k \in M\)</span>, so <span class="math inline">\(\alpha M \in M\)</span>, then $$ is integral over <span class="math inline">\(A\)</span>, more details could be seen <a href="https://math.stackexchange.com/questions/1436242/show-that-ax-cap-ax-1-is-integral-over-a">here</a>.</p></li>
<li><ol type="1">
<li><p>All <span class="math inline">\(\alpha_i \alpha_j, i\neq j\)</span> would have factor <span class="math inline">\((1+\sqrt{10})(1-\sqrt{10}) = -9\)</span> or <span class="math inline">\((1+\sqrt{7})(1-\sqrt{7}) = -6\)</span>, they are all divisible by 3 in <span class="math inline">\(O_K\)</span>. According to 2.12, we know that if <span class="math inline">\(\frac{\alpha_i^n}{3}\)</span> is integral over <span class="math inline">\(\mathbb{Z}\)</span>, then its norm and trace should all in <span class="math inline">\(\mathbb{Z}\)</span>, the norm clearly lie in <span class="math inline">\(\mathbb{Z}\)</span>, but the trace is not. We know <span class="math inline">\(Tr(\alpha_i^n) = \sum \alpha_j^n = 4^n\)</span>, because for <span class="math inline">\(f(X) \in \mathbb{Z}[X], f(\alpha_j) = 0\)</span>, then the minimal polynomial <span class="math inline">\(f_n(X)\)</span> of <span class="math inline">\(\alpha_i^n\)</span> would satisfy <span class="math inline">\(f_n(\alpha_j^n) = 0\)</span>.</p></li>
<li><p>If <span class="math inline">\(\overline g\)</span> is divisible by <span class="math inline">\(f\)</span> in <span class="math inline">\(F_3[X]\)</span>, then <span class="math inline">\(\overline g(\alpha) = 0\)</span> over <span class="math inline">\(F_3\)</span>, and <span class="math inline">\(g(X) = \overline g(X) + 3g&#39;(X)\)</span>, so <span class="math inline">\(g(\alpha) \equiv \overline g(\alpha) \mod 3\)</span>.</p>
<p>if <span class="math inline">\(g(\alpha)\)</span> is divisible by 3 in <span class="math inline">\(\mathbb{Z}[\alpha]\)</span>, then <span class="math inline">\(\overline g(\alpha) = 0\)</span> in <span class="math inline">\(F_3\)</span>, because <span class="math inline">\(f\)</span> is minimal polynomial of <span class="math inline">\(\alpha\)</span>, then <span class="math inline">\(\overline g\)</span> is divisible by <span class="math inline">\(f\)</span>. The point is that whether <span class="math inline">\(f\)</span> is still minimal polynomial in <span class="math inline">\(F_3[X]\)</span>. If there’s another <span class="math inline">\(f&#39; \in F_3[X], f&#39;(\alpha) = 0\)</span> with <span class="math inline">\(deg(f&#39;) &lt; deg(f)\)</span>, then <span class="math inline">\(f&#39;(\alpha) + 3T = 0\)</span> over <span class="math inline">\(\mathbb{Z}\)</span>, <span class="math inline">\(f&#39;&#39;(X) = f&#39;(X) + 3T\)</span> become minimal polynomial, so there’s a contradicition.</p></li>
<li><p>We know that <span class="math inline">\(f_i(\alpha) \equiv \overline f_i(\alpha) \mod 3\)</span>, then <span class="math inline">\(\overline f_i \overline f_j(\alpha) \equiv \alpha_i\alpha_j \mod 3\)</span>, from 1 we know <span class="math inline">\(\alpha_i\alpha_j \equiv 0\mod 3\)</span>, so <span class="math inline">\(\overline f | \overline f_i \overline f_j, i\neq j\)</span>, and <span class="math inline">\(\overline f\)</span> not divide <span class="math inline">\(\overline f_i^n\)</span>, because if it happens, then <span class="math inline">\(\overline f_i^n(\alpha) = 0\)</span>, which means <span class="math inline">\(\alpha_i^n \equiv 0 \mod 3\)</span>, which is a contradiction.</p></li>
<li><p><span class="math inline">\(\overline f\)</span> has at least 4 irreducible factors on <span class="math inline">\(F_3[X]\)</span>, which means <span class="math inline">\(f\)</span> has at least 4 irreducible factors on <span class="math inline">\(\mathbb{Z}[X]\)</span>, and <span class="math inline">\(f\)</span> has degree at most 4, so <span class="math inline">\(f\)</span> just has these 4 irreducible factors, <span class="math inline">\(f\)</span> will be <span class="math inline">\(f(X) = (X-t_0)(X-t_1)(X-t_2)(X-t_3)\)</span>, we know <span class="math inline">\(f(\alpha) = 0\)</span>, so <span class="math inline">\(t_i = \alpha\)</span>, then <span class="math inline">\(X-t_i\)</span> is the minipoly of <span class="math inline">\(\alpha\)</span>, here’s a contradiction.</p></li>
</ol></li>
<li><p><span class="math inline">\(S^{-1}A = \{\frac{a}{s}\ |\ a\in A, s\in S \}\)</span>, <span class="math inline">\(\forall f(X) \in S^{-1}A[X]\)</span>, <span class="math inline">\(f(X)\)</span> could be written as <span class="math inline">\(\frac{\sum_{i=0}^na_i&#39;X^i}{\prod_{i=0}^ns_i}\)</span>, if <span class="math inline">\(f(x_0) = 0\)</span>, then there exists <span class="math inline">\(f&#39;(X)\)</span> with <span class="math inline">\(f&#39;(x_0) = 0\)</span> on <span class="math inline">\(A\)</span>, so <span class="math inline">\(S^{-1}B\)</span> is still integral closure of <span class="math inline">\(S^{-1}A\)</span>.</p></li>
<li><p><span class="math inline">\(A_\mathfrak{p} = \{\frac{a}{s}\ | \ a\in A, s\in A\backslash \mathfrak{p}\}\)</span>, and <span class="math inline">\(\mathfrak{p}A_\mathfrak{p} = (A \backslash \mathfrak{p}) ^{-1} \mathfrak{p} = \{\frac{p}{s} \ | \ p\in \mathfrak{p}, s \in A\backslash \mathfrak{p}\}\)</span>.</p>
<p><span class="math inline">\(A_\mathfrak{p}/ \mathfrak{p}A_\mathfrak{p} = \{\frac{a}{s} \ | \ a\in A/\mathfrak{p}A, s\in A/\mathfrak{p} \}\)</span>，then <span class="math inline">\(\forall p \in A_\mathfrak{p}/\mathfrak{p}A_\mathfrak{p}\)</span> can be written in the form <span class="math inline">\(p = \frac{a}{b}, a, b\in A\)</span>.</p></li>
</ol>
<h3 id="dedekind-domains-factorization">Dedekind Domains &amp; Factorization</h3>
<hr>
<p>We could know that the first main task of this book is to summarize what a kind of ring could have the property which is factorable uniquely.</p>
<hr>
<h4 id="p49">p49</h4>
<p>In alternative proof, there’s an error that <span class="math inline">\(a \in \mathfrak{a}, b\in \mathfrak{b}\)</span>, not <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</p>
<p>In lemma 3.10, the map is <span class="math inline">\(a + \mathfrak{p}^m \rightarrow a + \mathfrak{q}^m\)</span>, firstly I thought it should be a map <span class="math inline">\(A/\mathfrak{p}^m \rightarrow A/\mathfrak{q}^m\)</span>, but then I realized that <span class="math inline">\(\mathfrak{q}^m\)</span> is not ideal of <span class="math inline">\(A\)</span>, so this quotient ring couldn’t exist. Then I take a look at the equivalence, we want to prove the map is one-to-one, which equals <span class="math inline">\(\forall a_0, a_1\in A\)</span>, if <span class="math inline">\(a_0 + \mathfrak{q}^m = a_1+\mathfrak{q}^m\)</span>, then <span class="math inline">\(a_0+\mathfrak{p}^m=a_1 + \mathfrak{p}^m\)</span>. If <span class="math inline">\(a_0 = a_1\)</span>, it’s obvious, if not, then <span class="math inline">\(a_0 \neq a_1, a_0+\mathfrak{q}^m = a_1 + \mathfrak{q}^m\)</span>, hence <span class="math inline">\(a_0, a_1 \in A\cap \mathfrak{q}^m\)</span>, so in the proof we have to show that <span class="math inline">\(\mathfrak{q}^m \cap A = \mathfrak{p}^m\)</span>.</p>
<h4 id="p50">p50</h4>
<p>Firstly I’m confused about <span class="math inline">\(s^{-1}\)</span> in <span class="math inline">\(A_\mathfrak{p}/\mathfrak{q}^m\)</span>, the element in <span class="math inline">\(A_\mathfrak{p}/\mathfrak{q}^m\)</span> should be in the form of <span class="math inline">\(a + \mathfrak{q}^m\)</span>, <span class="math inline">\(s\)</span> is just an element in <span class="math inline">\(A\backslash \mathfrak{p}\)</span>, so <span class="math inline">\(s^{-1}\)</span> is also a set <span class="math inline">\(\{b \ | \ bs + q = 1, q \in \mathfrak{p}^m\}\)</span>. <span class="math inline">\(ba = \frac{a}{s}(1-q)\)</span>, then <span class="math inline">\(\frac{a}{s}(1-q) + \mathfrak{q}^m = \frac{a}{s} + \mathfrak{q}^m\)</span>, then I know that “invertible” means <span class="math inline">\(b + \mathfrak{q}^m\)</span> is the inverse of <span class="math inline">\(s + \mathfrak{q}^m\)</span>.</p>
<p>In the proof, firstly we need to know the isomorphism from the ideals of <span class="math inline">\(A/\mathfrak{b}\)</span> to the ideals of <span class="math inline">\(A\)</span> containing <span class="math inline">\(\mathfrak{b}\)</span>, details could be seen <a href="https://math.stackexchange.com/questions/69578/bijection-between-ideals-of-r-i-and-ideals-containing-i">here</a>.</p>
<p>For $A/ , $ <span class="math inline">\(\mathfrak{q}_i^j = (A\backslash \mathfrak{p}_i)^{-1}\mathfrak{p}^j\)</span> , and for <span class="math inline">\(\mathfrak{a}/\mathfrak{b}\)</span>, here we take <span class="math inline">\(\mathfrak{a}/\mathfrak{b}\)</span> as an element in <span class="math inline">\(A/\mathfrak{b}\)</span>, then we know that <span class="math inline">\(\mathfrak{p}_1^{s_1}\mathfrak{p}_2^{s_2}\dots\mathfrak{p}_m^{s_m} / \mathfrak{b}\)</span> is also an element in <span class="math inline">\(A/\mathfrak{b}\)</span>, we take this element in the isomorphism, under first isomorphism, it turns to <span class="math inline">\(\mathfrak{p}_1^{s_1}\mathfrak{p}_2^{s_2}\dots\mathfrak{p}_m^{s_m} / \mathfrak{p}_1^{r_1} \times \dots \times \mathfrak{p}_1^{s_1}\mathfrak{p}_2^{s_2}\dots\mathfrak{p}_m^{s_m} / \mathfrak{p}_m^{r_m}\)</span>, we could use an example $(2 ) / (4) $ over <span class="math inline">\(\mathbb{Z}\)</span> to think of <span class="math inline">\(\mathfrak{p}_1^{s_1}\mathfrak{p}_2^{s_2}\dots\mathfrak{p}_m^{s_m} / \mathfrak{p}_1^{r_1}\)</span>, then we know that <span class="math inline">\(\mathfrak{p}_1^{s_1}\mathfrak{p}_2^{s_2}\dots\mathfrak{p}_m^{s_m} / \mathfrak{p}_1^{r_1} \cong \mathfrak{p}_1^{s_1} / \mathfrak{p}_1^{r_1}\)</span>, because the zero of both is $ {k _1^{r_1-s_1} |  k }$. Then under the second isomorphism, <span class="math inline">\(\mathfrak{p}^{s_i} \rightarrow \mathfrak{q}^{s_i} : A \rightarrow A_{\mathfrak{p}}\)</span>.</p>
<p>In the last, if <span class="math inline">\(\mathfrak{q}_i^{s_i} = \mathfrak{q}_i^{t_i}\)</span> with <span class="math inline">\(s_i \neq t_i\)</span>, we suppose <span class="math inline">\(s_i &gt; t_i\)</span> then there’s an ideal chain <span class="math inline">\(\mathfrak{q}_i^{t_i} \subseteq \mathfrak{q}_i^{t_i-1} \subseteq \dots \subseteq \mathfrak{q}_i^{s_i} \subseteq \dots \subseteq \mathfrak{q}_i\)</span>, any ideal $ _i^{j}$ is in this chain, then <span class="math inline">\(A_{ \mathfrak{p}_i}/ \mathfrak{q}_i\)</span> is not a field, so $ _i$ is not the maximal ideal, which contradicts the premises.</p>
<h4 id="p51">p51</h4>
<p>Firstly, I’m confused about <span class="math inline">\(x\equiv 1 \mod \mathfrak{p}_i, i\neq 1\)</span>, how could we get this. Then I think the point is why <span class="math inline">\(\mathfrak{p}_1\)</span> and <span class="math inline">\((x)\)</span> generate the same ideals in <span class="math inline">\(A_{\mathfrak{p}_i}\)</span>. <span class="math inline">\(\mathfrak{p}_1\)</span> generates <span class="math inline">\(\frac{\mathfrak{p}_1}{A-\mathfrak{p}_i}\)</span>, and <span class="math inline">\((x)\)</span> generates <span class="math inline">\(\frac{(x)}{A-\mathfrak{p}_i} = \frac{(x_1) + \mathfrak{p}_1^2}{A-\mathfrak{p}_i} = \frac{k_1\mathfrak{p}_1 + \mathfrak{p}_1^2}{A-\mathfrak{p}_i} = \frac{\mathfrak{p}_1(k_1 + \mathfrak{p}_1)}{A-\mathfrak{p}_i}\)</span>, we know that <span class="math inline">\(x_1 \in \mathfrak{p}_1 - \mathfrak{p}_1^2\)</span> , so <span class="math inline">\(k_1 \notin \mathfrak{p}_1\)</span>, <span class="math inline">\(k_1+\mathfrak{p}_1\)</span> is fixed, then we have a simple isomorphism <span class="math inline">\(\sigma(\frac{p}{q}) : \frac{p}{q} \rightarrow \frac{p}{(k_1+\mathfrak{p}_1)q}\)</span> from <span class="math inline">\((x)\)</span> to <span class="math inline">\(\mathfrak{p}_1\)</span>.</p>
<p>3.14 and 3.15 use the same kind of proof, in 3.15, we could calculate that <span class="math inline">\(\mathfrak{a}\)</span> generates <span class="math inline">\(\frac{\mathfrak{p}_i^{s_i}}{A-\mathfrak{p}_i}\)</span>, and <span class="math inline">\(\mathfrak{b} + (a)\)</span> generates <span class="math inline">\(\frac{\mathfrak{p}_i^{r_i}}{A-\mathfrak{p}_i} + \frac{(x_i)}{A-\mathfrak{p}_i}\)</span> in <span class="math inline">\(A_{\mathfrak{p}_i}\)</span>, then I’m wondering whether <span class="math inline">\((a) = \mathfrak{a}\)</span>, but then I recognized that <span class="math inline">\(a \equiv x_i \mod \mathfrak{p}_i^{r_i}\)</span>, so it need the part <span class="math inline">\(\frac{\mathfrak{p}_i^{r_i}}{A-\mathfrak{p}_i}\)</span>.</p>
<h4 id="p52">p52</h4>
<p>The point of proof for 3.18 is to use the (c) property of Dedekind domains.</p>
<p>​</p>
]]></content>
      <categories>
        <category>Learning Notes</category>
      </categories>
      <tags>
        <tag>Algebraic Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>摸鱼Writeup-1</title>
    <url>/2020/11/04/%E6%91%B8%E9%B1%BCWriteup-1/</url>
    <content><![CDATA[<p><em>本系列博客大概写一些较大比赛解数量较少的writeup，主要提供思路，具体流程可能不会过于细节</em></p>
<h4 id="bytectf-2020-crypto2">ByteCTF 2020 crypto2</h4>
<p><em>crypto1和crypto3都没啥好说的，这里就放下cry2的writeup~</em></p>
<p>分析可以构造 <span class="math inline">\(B = (H(m)+1)*G \Rightarrow encK = H(kc*G) = H(A-H(m)*G)\)</span></p>
<p>故做签名的sk为<span class="math inline">\(flag \otimes Cprime\)</span>，使<span class="math inline">\(Cprime = cipher = flag \otimes private\_key\)</span></p>
<p>则对s,e 有<span class="math inline">\(s \equiv r - e * private\_key \mod (n)\)</span>，即有<span class="math inline">\(r*G =s*G + e*pk\)</span>，又<span class="math inline">\(rG.x = e\)</span>，故可做verify判断，这里考虑可以诸位爆破，从低位对<span class="math inline">\(Cprime\)</span> 诸位取反，则最终得到的sk为private_key某一位取反后的值，即<span class="math inline">\(sk = private\_key \pm 2^i\)</span>，通过verify即可判断为加还是减，即可判断private_key那一位为0/1，256次后得到private_key，再与cipher异或即得到flag，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> winpwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto_tools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm3, func</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex, b2a_hex</span><br><span class="line"></span><br><span class="line">sm2p256v1_ecc_table = &#123;</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span>: <span class="string">&#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;p&#x27;</span>: <span class="string">&#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;g&#x27;</span>: <span class="string">&#x27;32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7&#x27;</span> + <span class="string">&#x27;bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APAKE</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hashed_pwd, pubkey</span>):</span></span><br><span class="line">        self.ecc_table = sm2p256v1_ecc_table</span><br><span class="line">        self.para_len = len(self.ecc_table[<span class="string">&#x27;n&#x27;</span>])</span><br><span class="line">        self.ecc_a3 = (int(self.ecc_table[<span class="string">&#x27;a&#x27;</span>], base=<span class="number">16</span>) + <span class="number">3</span>) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        self.hashed_pwd = hashed_pwd</span><br><span class="line">        self.K = <span class="literal">None</span></span><br><span class="line">        self.public_key = pubkey</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sm3_hash_str</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        <span class="keyword">return</span> sm3.sm3_hash(func.bytes_to_list(msg.encode()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_client</span>(<span class="params">self, kc_str</span>):</span></span><br><span class="line">        kc = int(kc_str, <span class="number">16</span>)</span><br><span class="line">        hpi = int(self.hashed_pwd, <span class="number">16</span>)</span><br><span class="line">        a = (kc + hpi) % int(self.ecc_table[<span class="string">&#x27;n&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        A = self._kg(a, self.ecc_table[<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prove_client</span>(<span class="params">self, password, kc_str, A, B, c_prime</span>):</span></span><br><span class="line">        kc = int(kc_str, <span class="number">16</span>)</span><br><span class="line">        hpi = int(self.hashed_pwd, <span class="number">16</span>)</span><br><span class="line">        n_sub_hpi = (int(self.ecc_table[<span class="string">&#x27;n&#x27;</span>], base=<span class="number">16</span>) - hpi) % int(self.ecc_table[<span class="string">&#x27;n&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        n_sub_hpi_G = self._kg(n_sub_hpi, self.ecc_table[<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">        print(<span class="string">&#x27;N_H(M) -&gt;&#x27;</span>, n_sub_hpi_G)</span><br><span class="line">        B_sub_hpi_G = self._add_point(B, n_sub_hpi_G)</span><br><span class="line">        B_sub_hpi_G = self._convert_jacb_to_nor(B_sub_hpi_G)</span><br><span class="line">        print(<span class="string">&#x27;B_H(M) -&gt;&#x27;</span>, B_sub_hpi_G)</span><br><span class="line">        self.K = self._kg(kc, B_sub_hpi_G)</span><br><span class="line">        enc_K = self.sm3_hash_str(self.K)</span><br><span class="line">        print(<span class="string">&#x27;K -&gt;&#x27;</span>, enc_K)</span><br><span class="line">        sk = <span class="string">&#x27;%064x&#x27;</span> % (int(c_prime, <span class="number">16</span>) ^ int(password, <span class="number">16</span>) ^ int(enc_K, <span class="number">16</span>))</span><br><span class="line">        transcript = A + B + c_prime</span><br><span class="line">        signature = self._sign(transcript, sk)</span><br><span class="line">        <span class="keyword">return</span> signature</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_sign</span>(<span class="params">self, data, sk</span>):</span></span><br><span class="line">        k_str = func.random_hex(len(self.ecc_table[<span class="string">&#x27;n&#x27;</span>]))</span><br><span class="line">        k = int(k_str, <span class="number">16</span>) % int(self.ecc_table[<span class="string">&#x27;n&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        R = self._kg(k, self.ecc_table[<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">        x1 = R[<span class="number">0</span>:self.para_len]</span><br><span class="line">        e_str = self.sm3_hash_str(x1 + data)</span><br><span class="line">        e = int(e_str, <span class="number">16</span>)</span><br><span class="line">        d = int(sk, <span class="number">16</span>)</span><br><span class="line">        s = (k - d * e) % int(self.ecc_table[<span class="string">&#x27;n&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%064x%064x&#x27;</span> % (s, e)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify</span>(<span class="params">self, data, pk, signature, adjust</span>):</span></span><br><span class="line">        s = int(signature[<span class="number">0</span>:self.para_len], <span class="number">16</span>)</span><br><span class="line">        e = int(signature[self.para_len:<span class="number">2</span> * self.para_len], <span class="number">16</span>)</span><br><span class="line">        sG = self._kg((s-adjust*e) % int(self.ecc_table[<span class="string">&#x27;n&#x27;</span>], base=<span class="number">16</span>), self.ecc_table[<span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">        eP = self._kg(e, pk)</span><br><span class="line">        R = self._add_point(sG, eP)</span><br><span class="line">        R = self._convert_jacb_to_nor(R)</span><br><span class="line">        x1 = R[<span class="number">0</span>:self.para_len]</span><br><span class="line">        e_str = self.sm3_hash_str(x1 + data)</span><br><span class="line">        <span class="keyword">return</span> e == int(e_str, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_kg</span>(<span class="params">self, k, Point</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (k % int(self.ecc_table[<span class="string">&#x27;n&#x27;</span>], base=<span class="number">16</span>)) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> * <span class="number">128</span></span><br><span class="line">        Point = <span class="string">&#x27;%s%s&#x27;</span> % (Point, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        mask_str = <span class="string">&#x27;8&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.para_len - <span class="number">1</span>):</span><br><span class="line">            mask_str += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        mask = int(mask_str, <span class="number">16</span>)</span><br><span class="line">        Temp = Point</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(self.para_len * <span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                Temp = self._double_point(Temp)</span><br><span class="line">            <span class="keyword">if</span> (k &amp; mask) != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    Temp = self._add_point(Temp, Point)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    Temp = Point</span><br><span class="line">            k = k &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self._convert_jacb_to_nor(Temp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_double_point</span>(<span class="params">self, Point</span>):</span></span><br><span class="line">        l = len(Point)</span><br><span class="line">        len_2 = <span class="number">2</span> * self.para_len</span><br><span class="line">        <span class="keyword">if</span> l &lt; self.para_len * <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x1 = int(Point[<span class="number">0</span>:self.para_len], <span class="number">16</span>)</span><br><span class="line">            y1 = int(Point[self.para_len:len_2], <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">if</span> l == len_2:</span><br><span class="line">                z1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                z1 = int(Point[len_2:], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">            T6 = (z1 * z1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T2 = (y1 * y1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T3 = (x1 + T6) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T4 = (x1 - T6) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T1 = (T3 * T4) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T3 = (y1 * z1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T4 = (T2 * <span class="number">8</span>) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T5 = (x1 * T4) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T1 = (T1 * <span class="number">3</span>) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T6 = (T6 * T6) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T6 = (self.ecc_a3 * T6) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T1 = (T1 + T6) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            z3 = (T3 + T3) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T3 = (T1 * T1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T2 = (T2 * T4) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            x3 = (T3 - T5) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (T5 % <span class="number">2</span>) == <span class="number">1</span>:</span><br><span class="line">                T4 = (T5 + ((T5 + int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)) &gt;&gt; <span class="number">1</span>) - T3) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                T4 = (T5 + (T5 &gt;&gt; <span class="number">1</span>) - T3) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">            T1 = (T1 * T4) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            y3 = (T1 - T2) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">            form = <span class="string">&#x27;%%0%dx&#x27;</span> % self.para_len</span><br><span class="line">            form = form * <span class="number">3</span></span><br><span class="line">            <span class="keyword">return</span> form % (x3, y3, z3)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add_point</span>(<span class="params">self, P1, P2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> P1 == <span class="string">&#x27;0&#x27;</span> * <span class="number">128</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;%s%s&#x27;</span> % (P2, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> P2 == <span class="string">&#x27;0&#x27;</span> * <span class="number">128</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;%s%s&#x27;</span> % (P1, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        len_2 = <span class="number">2</span> * self.para_len</span><br><span class="line">        l1 = len(P1)</span><br><span class="line">        l2 = len(P2)</span><br><span class="line">        <span class="keyword">if</span> (l1 &lt; len_2) <span class="keyword">or</span> (l2 &lt; len_2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X1 = int(P1[<span class="number">0</span>:self.para_len], <span class="number">16</span>)</span><br><span class="line">            Y1 = int(P1[self.para_len:len_2], <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">if</span> l1 == len_2:</span><br><span class="line">                Z1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Z1 = int(P1[len_2:], <span class="number">16</span>)</span><br><span class="line">            x2 = int(P2[<span class="number">0</span>:self.para_len], <span class="number">16</span>)</span><br><span class="line">            y2 = int(P2[self.para_len:len_2], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">            T1 = (Z1 * Z1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T2 = (y2 * Z1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T3 = (x2 * T1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T1 = (T1 * T2) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T2 = (T3 - X1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T3 = (T3 + X1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T4 = (T2 * T2) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T1 = (T1 - Y1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            Z3 = (Z1 * T2) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T2 = (T2 * T4) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T3 = (T3 * T4) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T5 = (T1 * T1) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T4 = (X1 * T4) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            X3 = (T5 - T3) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T2 = (Y1 * T2) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T3 = (T4 - X3) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            T1 = (T1 * T3) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">            Y3 = (T1 - T2) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">            form = <span class="string">&#x27;%%0%dx&#x27;</span> % self.para_len</span><br><span class="line">            form = form * <span class="number">3</span></span><br><span class="line">            <span class="keyword">return</span> form % (X3, Y3, Z3)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_convert_jacb_to_nor</span>(<span class="params">self, Point</span>):</span></span><br><span class="line">        len_2 = <span class="number">2</span> * self.para_len</span><br><span class="line">        x = int(Point[<span class="number">0</span>:self.para_len], <span class="number">16</span>)</span><br><span class="line">        y = int(Point[self.para_len:len_2], <span class="number">16</span>)</span><br><span class="line">        z = int(Point[len_2:], <span class="number">16</span>)</span><br><span class="line">        z_inv = pow(z, int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>) - <span class="number">2</span>, int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>))</span><br><span class="line">        z_invSquar = (z_inv * z_inv) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        z_invQube = (z_invSquar * z_inv) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        x_new = (x * z_invSquar) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        y_new = (y * z_invQube) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        z_new = (z * z_inv) % int(self.ecc_table[<span class="string">&#x27;p&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> z_new == <span class="number">1</span>:</span><br><span class="line">            form = <span class="string">&#x27;%%0%dx&#x27;</span> % self.para_len</span><br><span class="line">            form = form * <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> form % (x_new, y_new)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">assit</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        hpi = int(self.hashed_pwd, <span class="number">16</span>)</span><br><span class="line">        n_sub_hpi = (<span class="number">-1</span> * hpi) % int(self.ecc_table[<span class="string">&#x27;n&#x27;</span>], base=<span class="number">16</span>)</span><br><span class="line">        rG = self._convert_jacb_to_nor(self._add_point(A, self._kg(n_sub_hpi, self.ecc_table[<span class="string">&#x27;g&#x27;</span>])))</span><br><span class="line">        print(<span class="string">&#x27;fake rG -&gt;&#x27;</span>, rG)</span><br><span class="line">        c_prime = self.sm3_hash_str(rG)</span><br><span class="line">        <span class="keyword">return</span> c_prime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hash_m = <span class="number">0x53b9edeb45a1175bad0ba15381a8676dff3611ad90629bf8fe0bae2f48d4a31d</span></span><br><span class="line">n = <span class="number">0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123</span></span><br><span class="line">pk = <span class="string">&#x27;1f719bef8a35ec64ac88c0d4e5909201326fb3a84e39f45acc8dd34a8ae83ea595a8e7c877cd817204a1760b7dff10a34d50c3de4e48122aaaaed45a76752cd4&#x27;</span></span><br><span class="line">cipher = <span class="number">0x1cd3018bd12e647f91a19f02ce460685bd5c13eb2d7253da549baf62aa943da2</span></span><br><span class="line">cipher_bin = bin(cipher)[<span class="number">2</span>:].rjust(<span class="number">256</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">apake = APAKE(hashed_pwd=hex(Hash_m)[<span class="number">2</span>:], pubkey=pk)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    p = remote(<span class="string">&#x27;182.92.153.117&#x27;</span>, <span class="number">30102</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;A = &#x27;</span>)</span><br><span class="line">    A = hex(int(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>))[<span class="number">2</span>:].rjust(<span class="number">128</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;PublicKey = &#x27;</span>)</span><br><span class="line">    tmp_pk = hex(int(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>))[<span class="number">2</span>:].rjust(<span class="number">128</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Cipher = &#x27;</span>)</span><br><span class="line">    tmp_cipher = int(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;B = ?&#x27;</span>)</span><br><span class="line">    B = <span class="string">&#x27;ed5794bb9114317bb0a502b82d3705216a325a2e15810bff91b8df5ad59d0e333e908d589d5ebb0ee2727768e81147d81f640d9d16a149282bd3fd20c5dbc895&#x27;</span></span><br><span class="line">    p.send(B + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;c_prime = ?&#x27;</span>)</span><br><span class="line">    balance = apake.assit(A)</span><br><span class="line">    check = int(balance, <span class="number">16</span>) ^ cipher ^ int((<span class="string">&#x27;0&#x27;</span> * (<span class="number">255</span> - i) + <span class="string">&#x27;1&#x27;</span>).ljust(<span class="number">256</span>, <span class="string">&#x27;0&#x27;</span>), <span class="number">2</span>)</span><br><span class="line">    c_prime = hex(check)[<span class="number">2</span>:]</span><br><span class="line">    p.send(c_prime + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Signature = &#x27;</span>)</span><br><span class="line">    tmp_signature = hex(int(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>), <span class="number">16</span>))[<span class="number">2</span>:].rjust(<span class="number">128</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    data = A + B + c_prime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> apake.verify(data, pk, tmp_signature, <span class="number">2</span>**i):</span><br><span class="line">        flag = flag + <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = flag + <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(int(flag[::<span class="number">-1</span>], <span class="number">2</span>) ^ cipher))</span><br></pre></td></tr></table></figure>
<h4 id="xnuca-2020-crypto3">XNUCA 2020 crypto3</h4>
<p><em>crypto1利用Blomer May的连分数求出x和y再利用Copper Smith恢复p，再恢复Twisted Edward即可，crypto2因为是分组我就没看，这里只给出crypto3的writeup~</em></p>
<p><em>这一题算是我第一次遇见格套娃，最难的一层应该就是恢复A了，比赛的时候7点多恢复出来了A，但忘记A的列顺序不影响B，故应该对A的所有列做个全排列再恢复LWE，恰逢S10决赛，于是乎并没有拿到三血orz，晚上十二点多经学长提醒才意识到2333</em></p>
<p>本题审题后发现有三层嵌套：</p>
<ol type="1">
<li><p>第一层是类背包问题，已知向量R，可知有</p>
<p><span class="math display">\[R_{64} = \sum_{i=0}^{63} T_i * S_{yi}, R_i = T_i \]</span></p>
<p>可以发现和背包问题非常相似，但是系数<span class="math inline">\(S_{yi}\)</span> 并非为<span class="math inline">\(0/1\)</span>， 而是落在<span class="math inline">\([0,1000)\)</span> 上，故考虑对解决背包问题的格子做修改，可知一般解决背包问题使用如下格子：</p>
<p><img src="/2020/11/04/%E6%91%B8%E9%B1%BCWriteup-1/image-20201104171256398.png"></p>
<p>最后一行的向量1是用来均衡系数的，使得最后的解向量为<span class="math inline">\(2x_i - 1 = -1/1\)</span></p>
<p>这里考虑到系数为<span class="math inline">\([0, 1000)\)</span>，故最后一行将1修改为1000，则有<span class="math inline">\(2x_i - 1000 \in [-1000, 1000)\)</span>，则可成功规约出解向量，此部分代码如下：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = Matrix([i <span class="keyword">for</span> i <span class="keyword">in</span> R[:<span class="number">64</span>]]).transpose()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">enc, publickey</span>):</span></span><br><span class="line">    n = len(publickey)</span><br><span class="line"></span><br><span class="line">    d = <span class="number">2</span> * identity_matrix(ZZ, n, n)</span><br><span class="line">    col = publickey + [enc]</span><br><span class="line">    col = matrix(col).transpose()</span><br><span class="line"></span><br><span class="line">    last = matrix(ZZ, [[<span class="number">1000</span>] * n])</span><br><span class="line">    tmp = block_matrix(ZZ, [[d], [last]])</span><br><span class="line">    grid = block_matrix(ZZ, [[tmp, col]])</span><br><span class="line"></span><br><span class="line">    M = grid.LLL()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> M[<span class="number">0</span>][:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># got Sy with R</span></span><br><span class="line">Sy = decrypt(R[<span class="number">64</span>], R[:<span class="number">64</span>])</span><br><span class="line">Sy = [(x+<span class="number">1000</span>)//<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> Sy]</span><br><span class="line">print(Sy)</span><br></pre></td></tr></table></figure></p></li>
<li><p>第二层，也是最难的一层，即是通过矩阵B恢复矩阵A。</p>
<p><em>这看起来是件很离谱的事情，只通过矩阵积恢复出来相乘的两个矩阵，但利用这题的bound确实可以做到这点orz。</em></p>
<p>已知有<span class="math inline">\(A r = B\)</span>， 其中A为<span class="math inline">\(320\times5\)</span>的矩阵，r为<span class="math inline">\(5\times 7\)</span>的随机矩阵，B即为<span class="math inline">\(320 \times 7\)</span>的矩阵，特殊的地方在于，A的元素均在<span class="math inline">\([10, 1000)\)</span>上，而r的元素基本在1000位以上，故想到，我们可以对B为基底的格进行规约，从而可能得到A中某一列（因为考虑到广义逆，大概率有一个线性变换<span class="math inline">\(r&#39;\)</span>，使得<span class="math inline">\(A = Br&#39;\)</span>），但由于可能有多解，所以需要使用bound<span class="math inline">\([10, 1000)\)</span>约束一下。</p>
<p>这里如果直接对B中的6列/7列进行全排列构造格子规约，则可以规约出两组320维的满足条件的A的列向量，但还有三列并不知道，这一点也是比赛中困扰我最久的问题，后来想到其实我们可以通过降低维度去扩大解空间范围，然后再取top5大概率即可找出A中所有的列向量。</p>
<p>具体操作即是选取6/7个B的列向量部分，做全排列，我一开始取的是前140-220行遍历，这样可以找到7-8个满足条件的部分列向量，之前规约出的两个完整列向量也在其中，后来提高了维数为200-300行便只有五个了，这样成功找到了A的前200行，此部分代码如下：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> limit <span class="keyword">in</span> tqdm(range(<span class="number">200</span>, <span class="number">300</span>)):</span><br><span class="line">    base = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        base.append(B[i*<span class="number">320</span>:(i+<span class="number">1</span>)*<span class="number">320</span>][:limit])</span><br><span class="line">    <span class="keyword">for</span> rows <span class="keyword">in</span> range(<span class="number">6</span>, <span class="number">8</span>):</span><br><span class="line">        tmp = list(itertools.combinations(base, rows))</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> tmp:</span><br><span class="line">            M = Matrix(ZZ, l)</span><br><span class="line">            M = M.LLL()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> M:</span><br><span class="line">                v = [abs(x) <span class="keyword">for</span> x <span class="keyword">in</span> list(i)]</span><br><span class="line">                <span class="keyword">if</span> min(v) &gt;= <span class="number">10</span> <span class="keyword">and</span> max(v) &lt;= <span class="number">1000</span> <span class="keyword">and</span> v[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> had:</span><br><span class="line">                    print(v)</span><br><span class="line">                    print(limit)</span><br><span class="line">                    had.append(v[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># had = [706, 808, 626, 428, 717]</span></span><br></pre></td></tr></table></figure></p>
<p>找到了A的前200行后，可知有<span class="math inline">\(A_{part} r = B_{part}\)</span>，故我们对得到五个列向量全排列，然后结合B矩阵前200行，即可解出r矩阵，再利用r矩阵，即可成功恢复A矩阵，此部分代码如下：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B_matrix = Matrix(ZZ, _B).transpose()</span><br><span class="line">tmp = list(itertools.permutations(possible_A, int(cols)))</span><br><span class="line">A_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> tqdm(tmp):</span><br><span class="line">    A = Matrix(ZZ, l).transpose()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        R = A.solve_right(B_matrix)</span><br><span class="line">        _B = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">            _B.append(B[i * <span class="number">320</span>:(i + <span class="number">1</span>) * <span class="number">320</span>])</span><br><span class="line">        B_matrix = Matrix(ZZ, _B).transpose()</span><br><span class="line">        A = R.solve_left(B_matrix)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> R.list():</span><br><span class="line">            <span class="keyword">assert</span> <span class="number">1000</span> &lt; int(j).bit_length() &lt;= <span class="number">1024</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p>
<p><em>需要注意的是，由于B中元素是A中行元素线性和，故而其实A的列顺序不影响B的列顺序，故需要对A的5个列做个全排列才能找到正确的A。</em></p></li>
<li><p>最后一层，比较简单，即是恢复LWE，这里我直接用了之前N1CTF那个LWE的代码，加上A的列全排列即可：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> A.nrows() == <span class="number">320</span></span><br><span class="line"><span class="keyword">assert</span> len(A.columns()) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">all_cols_comb = list(itertools.permutations(A.columns(), int(<span class="number">5</span>)))</span><br><span class="line">total_sk = []</span><br><span class="line"><span class="keyword">for</span> cols_comb <span class="keyword">in</span> tqdm(all_cols_comb):</span><br><span class="line">    tmp_A = Matrix(ZZ, cols_comb).transpose()</span><br><span class="line">    tmp = [int(x).__xor__(int(y)) <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(tmp_A.list(), xor_M)]</span><br><span class="line">    LWE_a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">        LWE_a.append(tmp[i * <span class="number">25</span>:(i + <span class="number">1</span>) * <span class="number">25</span>])</span><br><span class="line">    LWE_c = Sy</span><br><span class="line"></span><br><span class="line">    module = <span class="number">1000</span></span><br><span class="line">    row = <span class="number">64</span></span><br><span class="line">    column = <span class="number">25</span></span><br><span class="line">    M = matrix(ZZ, row + column, row)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(column):</span><br><span class="line">            M[row + j, i] = LWE_a[i][j]</span><br><span class="line">        M[i, i] = module</span><br><span class="line"></span><br><span class="line">    lattice = IntegerLattice(M, lll_reduce=<span class="literal">True</span>)</span><br><span class="line">    target = vector(ZZ, LWE_c[:row])</span><br><span class="line">    res = CVP(lattice.reduced_basis, target)</span><br><span class="line">    R = IntegerModRing(module)</span><br><span class="line">    M = Matrix(R, LWE_a[:row])</span><br><span class="line"></span><br><span class="line">    total_sk.append(M.solve_right(res))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;total_sk =&#x27;</span>, total_sk)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>最后的最后，遍历得到的所有可能私钥，解AES即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">iv_cipher = <span class="number">0xc338be5406289b99332176593ae94b5e254df0e6b31b3155f370845e99d55f3a5b8b9e5576a126512b93eacacb6b7865f925120c3a221d0a2fcff362d841ad6be183a796f0c0a8111704737b6fc412f4</span></span><br><span class="line">iv_cipher = long_to_bytes(iv_cipher)</span><br><span class="line"><span class="keyword">for</span> LWE_s <span class="keyword">in</span> total_sk:</span><br><span class="line">    key = hashlib.sha256(<span class="string">&#x27;&#x27;</span>.join(list(map(str, LWE_s))).encode()).digest()</span><br><span class="line">    iv = iv_cipher[:<span class="number">16</span>]</span><br><span class="line">    cipher = iv_cipher[<span class="number">16</span>:]</span><br><span class="line">    aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    flag = aes.decrypt(cipher)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;X-NUCA&#123;&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        print(flag)</span><br></pre></td></tr></table></figure>
<p>最终得到flag：</p>
<p><img src="/2020/11/04/%E6%91%B8%E9%B1%BCWriteup-1/image-20201104174409177.png"></p>
<h4 id="hxb2020-crypto4">HXB2020 crypto4</h4>
<p><em>除了crypto4都比较简单，就crypto1还有点意思</em></p>
<p>这题其实即是改版的Wiener Attack，通过这篇<a href="https://www.mdpi.com/2410-387X/3/1/2">paper</a> 知道当存在<span class="math inline">\(|ap - bq|\)</span> 较小时，我们可以得到<span class="math inline">\(p+q\)</span> 的一个估计，$q&lt;p&lt;2q $ 时，这个估计为<span class="math inline">\(\sqrt{\frac{(a+b)^2 N}{ab}}\)</span> ，</p>
<p>于是有exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rational_to_quotients</span>(<span class="params">x, y</span>):</span>  <span class="comment"># calculate the series of continued fraction</span></span><br><span class="line">    a = x // y</span><br><span class="line">    quotients = [a]</span><br><span class="line">    <span class="keyword">while</span> a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        quotients.append(a)</span><br><span class="line">    <span class="keyword">return</span> quotients</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convergents_from_quotients</span>(<span class="params">quotients</span>):</span>  <span class="comment"># calculate the convergent series of continued fraction</span></span><br><span class="line">    convergents = [(quotients[<span class="number">0</span>], <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(quotients) + <span class="number">1</span>):</span><br><span class="line">        quotients_partion = quotients[<span class="number">0</span>:i]</span><br><span class="line">        denom = quotients_partion[<span class="number">-1</span>]  <span class="comment"># 分母</span></span><br><span class="line">        num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">-2</span>, -len(quotients_partion), <span class="number">-1</span>):</span><br><span class="line">            num, denom = denom, quotients_partion[_] * denom + num</span><br><span class="line">        num += denom * quotients_partion[<span class="number">0</span>]</span><br><span class="line">        convergents.append((num, denom))</span><br><span class="line">    <span class="keyword">return</span> convergents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WienerAttack_change</span>(<span class="params">e, n, N, c</span>):</span></span><br><span class="line">    quotients = rational_to_quotients(e, n)</span><br><span class="line">    convergents = convergents_from_quotients(quotients)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        m = pow(c, d, N)</span><br><span class="line">        flag = long_to_bytes(m)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;DASCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            print(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">11</span></span><br><span class="line">WienerAttack_change(e, n - int(isqrt(((a+b)**<span class="number">2</span>) * n // (a*b))) + <span class="number">1</span>, n, c)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Crypto in CTF</category>
      </categories>
      <tags>
        <tag>Crypto in CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题闲记-2</title>
    <url>/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-2/</url>
    <content><![CDATA[<h4 id="gactf2020">GACTF2020</h4>
<h5 id="elgamal-rsa">Elgamal-RSA</h5>
<p>一开始直接把key给了。。。不过本身Elgamal部分本身就很简单，其实并无所谓</p>
<p>先求解Elgamal，计算出secret:</p>
<p>已知：</p>
<p>$c_1 = g^r $</p>
<p>$ c_2 = m * g^{dr} $</p>
<p>$ c_{11} = g^{B*r + A} $</p>
<p>$ c_{12} = m * g^{B*r + A} $</p>
<p>$ h = g ^ d$</p>
<p>推导：</p>
<p><span class="math display">\[ c_2 ^{-B} = m^{-B} * (g^d)^{-Br} \]</span></p>
<p><span class="math display">\[   c_{12} * c_2^{-B} = m^{1-B} * (g^d)^A \]</span></p>
<p><span class="math display">\[   (c_{12} * c_2^{-B})^{\frac{1}{1-B}} = m * (g^d)^{\frac{A}{1-B}} \]</span></p>
<p><span class="math display">\[   (c_{12} * c_2^{-B})^{\frac{1}{1-B}} * h^{\frac{1-B}{A}} = m\]</span></p>
<p>从而得到secret，之后计算<span class="math inline">\(\phi(n)\)</span>，发现有 <span class="math inline">\(e|\phi(n)\)</span>，但<span class="math inline">\(n\)</span>有6个素因子，都不大，故对每个素因数<span class="math inline">\(p_i\)</span>，先在$ p_i^{l_i}$下decrypt，即把e当作</p>
<p><span class="math display">\[ \frac{e}{gcd(e, \phi(p_i^{l_i}))} \]</span></p>
<p>得到<span class="math inline">\(m_i\)</span>，之后求模$ p_i^{l_i}<span class="math inline">\(下\)</span>m_i$的 <span class="math inline">\(gcd(e, \phi(p_i^{l_i}))\)</span> 次根，然后CRT即可，完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto_tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">g, h, A, B, p, q = </span><br><span class="line">c1, c2 = </span><br><span class="line">c11, c12 = </span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate the secret</span></span><br><span class="line">g_br = (inverse(pow(g, A, p), p) * c11) % p</span><br><span class="line">tmp = pow(c12 * inverse(pow(c2, B, p), p), inverse(<span class="number">1</span>-B, q), p)</span><br><span class="line">m = tmp * inverse(pow(h, A * inverse(<span class="number">1</span>-B, q), p), p)</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line">n = m % p</span><br><span class="line">e = <span class="number">0x1296</span></span><br><span class="line">primes = [<span class="number">232087313537</span>, <span class="number">104280142799213</span>, <span class="number">28079229001363</span>, <span class="number">653551912583</span>, <span class="number">42044128297</span>, <span class="number">802576647765917</span>]</span><br><span class="line">index = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># check the primes</span></span><br><span class="line">base = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(primes)):</span><br><span class="line">    base = base * (primes[i]**index[i])</span><br><span class="line">print(base == n)</span><br><span class="line"></span><br><span class="line">phi = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(primes)):</span><br><span class="line">    phi.append(primes[i] ** (index[i]<span class="number">-1</span>) * (primes[i]<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">low_e = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> phi:</span><br><span class="line">    low_e.append(int(gcd(i, e)))</span><br><span class="line"></span><br><span class="line">low_n = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(primes)):</span><br><span class="line">    low_n.append(primes[i] ** index[i])</span><br><span class="line"></span><br><span class="line">low_c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(primes)):</span><br><span class="line">    low_c.append(pow(c, inverse(e//low_e[i], phi[i]), low_n[i]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(low_n)):</span><br><span class="line">    print(<span class="string">&#x27;\n%d primes&#x27;</span>%(i+<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">&#x27;n = &#x27;</span> + str(low_n[i]))</span><br><span class="line">    print(<span class="string">&#x27;root = &#x27;</span> + str(low_e[i]))</span><br><span class="line">    print(<span class="string">&#x27;c = &#x27;</span> + str(low_c[i]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># use sage&#x27;s &#x27;Mod(c,n).nth_root(root)&#x27;</span></span><br><span class="line">candidate = [<span class="number">353407247512303965045365245273514113979254413155723038594</span>, <span class="number">118406996121335867872417220406950412663021908207429086460086709649567668592818842789</span>, <span class="number">40838194187011975196269228876765908865444944296745005849695833986972327289154552784299932702051642970620861282724383667531261441125357573017325620944049102688903343462724551047586535304480</span>, <span class="number">1695123516800295425246681257666516560158663239197207672350847711896311171077931594423061655507605147792730816972030575396344034948137641207075718430653779535756721008018915068547</span>, <span class="number">4723044149650256515091565811539899787013565528592340044059397238</span>, <span class="number">214489300896472271161382790695870756301586580281999239401045130054091244899629639375835223662794331991713</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># check</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidate)):</span><br><span class="line">    <span class="keyword">assert</span> pow(candidate[i], e, low_n[i]) == c % low_n[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># find all roots</span></span><br><span class="line">roots = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidate)):</span><br><span class="line">    roots.append(all_roots_mod(low_n[i], candidate[i], low_e[i], phi[i]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># check again</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidate)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> roots[i]:</span><br><span class="line">        <span class="keyword">assert</span> pow(j, e, low_n[i]) == c % low_n[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># solve</span></span><br><span class="line"><span class="keyword">for</span> i_1 <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">for</span> i_2 <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span> i_1 == i_2:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> roots[i_1]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> roots[i_2]:</span><br><span class="line">                possible = long_to_bytes(GCRT([low_n[i_1], low_n[i_2]], [i, j])[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">if</span> all_ascii(possible):</span><br><span class="line">                    print(possible)</span><br><span class="line">                    sys.exit()</span><br></pre></td></tr></table></figure>
<h5 id="square">Square</h5>
<p>这题本质是要求出二元二次方程的整数通解，即求出解之间的递推式。使用这个<a href="https://www.alpertron.com.ar/QUAD.HTM">工具</a>可以轻松解决，此处探讨一种特殊情况的<a href="http://mathforum.org/library/drmath/view/55988.html">原理</a>（太久不看分析，感觉完全不会构造了orz），一般性情况的原理可见<a href="https://www.alpertron.com.ar/METHODS.HTM">这里</a>。</p>
<p>二元二次方程可定义通式：<span class="math inline">\(Ax^2 + Bxy+Cy^2+Dx+Ey+F = 0 \quad (1)\)</span></p>
<p>且 <span class="math inline">\(\exists k \in Z_+, \ let \ B^2 -4AC = k^2\)</span> （此处即为特殊条件）</p>
<p>之后进行构造求解，根本思想是降低次数，即通过构造简化为二元一次方程求解</p>
<p>一般需要降次时，容易想到需要构造平方来，于是先使用一个系数产生可配项</p>
<p>$(1) * 4A $</p>
<p><span class="math display">\[   \Rightarrow 4A^2x^2 + 4ABxy + 4ACy^2 +4ADx +4AEy + 4AF = 0 \quad (2)\]</span></p>
<p>之后2式加减<span class="math inline">\((B^2y^2 + 2BDy +D^2)\)</span> （通过这个构造trick来化简)</p>
<p><span class="math display">\[ \Rightarrow 
4 A^2 x^2 + 4 A B+x y + B^2 y^2 + 4 A D x + 2 B D y + D^2 + \]</span></p>
<p><span class="math display">\[   4 A C y^2 - B^2 y^2 + 4 A E y - 2 B D y + 4 A F - D^2 = 0 \]</span></p>
<p>由此构造平方和，化简得<span class="math inline">\((2Ax+By+D)^2 - (ky)^2 +(4AE-2BD)*y = D^2 - 4AF \quad (3)\)</span></p>
<p>再将左边构造成两个平方差</p>
<p>$(3) * k^2 + (2AE-BD)^2 $</p>
<p><span class="math display">\[   \Rightarrow (2Akx + Bky +Dk)^2 - (k^2y + (2AE-BD))^2 = D^2k^2 - 4AFk^2 + (2AE-BD)^2 \]</span></p>
<p>由此利用平方差公式，得到：</p>
<p><span class="math display">\[ \Rightarrow [(2Akx + Bky +Dk) + (k^2y + 2AE-BD)][(2Akx + Bky +Dk) - (k^2y + 2AE-BD)] \]</span></p>
<p><span class="math display">\[   = D^2k^2 - 4AFk^2 + (2AE-BD)^2\]</span></p>
<p>此时分两种情况讨论：</p>
<p>设<span class="math inline">\(C = D^2k^2 - 4AFk^2 + (2AE-BD)^2\)</span></p>
<ol type="1">
<li><p>C为0：</p>
<p>即有<span class="math inline">\(D^2k^2 - 4AFk^2 + (2AE-BD)^2 = 0\)</span>，则左边的积的两个因子（简称为<span class="math inline">\(f_1, f_2\)</span>）必然有一个因子为0，这就转换成了两个二元一次方程，之后只需判断有无解，选择相适的解集即可。</p></li>
<li><p>C不为0：</p>
<p>此时对C进行因子分解，得到所有因子（包含所有负数）<span class="math inline">\(divisor_i, i = 1, 2, \dots, s\)</span></p>
<p>对<span class="math inline">\(f_1, f_2\)</span>， 逐个判断<span class="math inline">\(f_1 = divisor_i\)</span> 解的正确性，遍历<span class="math inline">\(divisor\)</span> 数列，必然可以得到原方程的解集。</p></li>
</ol>
<p>本题具体解法比较麻烦，属于较为一般的情况，了解构造思想即可。</p>
<h4 id="rctf2020">RCTF2020</h4>
<h5 id="infantecc-working">infantECC | working</h5>
<p>使用定理：</p>
<p>GF(p)上形为<span class="math inline">\(y^2 = x^3 + b\)</span> 的椭圆曲线在<span class="math inline">\(p\equiv 2 \mod 3\)</span>时，阶数为p+1（这种曲线即为所谓的超奇异曲线）</p>
<p>emmmm准备复现的时候发现ROIS把博客删了???，只找到了Hellman的wp，但我主要是想看看多元Copper Smith的使用方法。。。所以就只能面向exp复现了。。。</p>
<p>猜测<span class="math inline">\(E_p, E_q\)</span> 均为超奇异曲线（否则无法做题）</p>
<p>则已知s，r的低256位，且 <span class="math inline">\(s*r \equiv \mod ((p+1)*(q+1))\)</span></p>
<p><span class="math inline">\((p+1)*(q+1) = n + (p+q) + 1\)</span>，n未知，但已知<span class="math inline">\(E_n\)</span>两个点，故通过ECC可以很容易复原出来：</p>
<p><span class="math inline">\(k*n = gcd((x_1^3+b-y_1^2), (x_2^3+b-y_2^2))\)</span></p>
<p>k较小，得到结果分解即可得到n：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = gcd(int(Cy)^<span class="number">2</span>-int(Cx)^<span class="number">3</span>-int(b), int(Ty)^<span class="number">2</span>-int(Tx)^<span class="number">3</span>-int(b))</span><br><span class="line"><span class="comment"># 下面代码为消除k</span></span><br><span class="line">N = factor_trial_division(N, <span class="number">1000</span>)[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>将s，r看作e，d，由此问题转化为了类似于Copper Smtih中Partial d的情况</p>
<p>可知有 <span class="math inline">\(k*(p+1)*(q+1) = e*d - 1\)</span> ，且<span class="math inline">\(d &lt; 2^{412}\)</span></p>
<p><span class="math inline">\(\Rightarrow k *(n + p + q + 1) = e*d -1\)</span></p>
<p>设<span class="math inline">\(s = p+q\)</span>，且已知d的低256位<span class="math inline">\(d_{low}\)</span>，则 <span class="math inline">\(\Rightarrow k * (n+s+1) = e * (d_{high}* 2 ^{256}+ d_{low})-1\)</span></p>
<p>存在三个变量：<span class="math inline">\(k, s, d_{high}\)</span></p>
<p>此处使用三元Copper Smith 求解，先考虑三个变量的上界：</p>
<p><span class="math inline">\(k = \frac{e*d - 1}{(p+1)*(q-1)} \leq 2 ^{1024 + 412 - 1024} = 2 ^ {412}\)</span></p>
<p><span class="math inline">\(s = (p+1)*(q+1) \leq 2 ^ {1024}\)</span></p>
<p><span class="math inline">\(d_{high} = \frac{d - d_{low}}{2^{256}} \leq 2^{412-256} = 2^{156}\)</span></p>
<p>这里考虑类似于Boneh and Durfee attack，具体原理可以先看<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.2636&amp;rep=rep1&amp;type=pdf">这篇论文</a></p>
<p>尝试使用二元Cooper去解</p>
<p>设<span class="math inline">\(s = p+q\)</span></p>
<p>则 <span class="math inline">\(k&#39;*(n + s + 1) \equiv e * d_{low} -1 \mod 2^{256}\)</span></p>
<p>还有 <span class="math inline">\(p^2 - sp +n \equiv 0 \mod 2^{256}\)</span></p>
<p>上式乘<span class="math inline">\(p\)</span>，下式乘<span class="math inline">\(k&#39;\)</span>，相加得到<span class="math inline">\(k&#39;np + k&#39;p + p +k&#39;p^2 + k&#39;n \equiv ed_{low}p \mod 2^{256}\)</span></p>
<p><span class="math inline">\(\Rightarrow k&#39;p^2 + (k&#39;n + k&#39; + 1 - ed_{low}) p + k&#39;n \equiv 0 \mod 2^{256}\)</span></p>
<p>此时只剩下两个未知量<span class="math inline">\(k&#39;, p\)</span>， 通常<span class="math inline">\(k&#39;\)</span>是采用在<span class="math inline">\((0, e-1)\)</span> 下爆破来获取，而这里e为1024位，显然并不现实。。</p>
<h4 id="de1ctf2020">De1CTF2020</h4>
<h5 id="easy_rsa">easy_RSA</h5>
<p>Ver学长tql，比赛的时候还没入门，于是只能复现的时候看了，本题貌似不小心和D3CTF的撞了，学长后来也很懵233</p>
<p>本题利用的是Howgrave-Graham and Seifert’s Attack是基于Wiener's Attack（<span class="math inline">\(d &lt; N^{\frac{1}{4}}\)</span>）和Guo's Common Modulus Attack（<span class="math inline">\(d &lt; N^{\frac{1}{3}}\)</span>）的一种攻击，通过<a href="https://eprint.iacr.org/2009/037.pdf">这篇paper</a>，可以比较清晰的了解原理，也可以看官方wp</p>
<p>可行性分析：</p>
<p>相较于其借鉴的两种攻击，此种攻击对d的范围限制更小，根据所有公钥数量r，有约束<span class="math inline">\(d &lt; N^{\frac{3+r}{7r}}\)</span>，原题中给了两个e，故r = 2，即需<span class="math inline">\(d&lt; N^{\frac{5}{14}}\)</span>，而所给d范围限定在<span class="math inline">\([N^{\frac{1}{3}}, 2^{49} *N^{\frac{1}{3}} ]\)</span>，约为<span class="math inline">\([N^{\frac{1}{3}}, N^{\frac{1}{3}+0.023} ]\)</span></p>
<p>而又有 <span class="math inline">\(\frac{1}{3} + 0.023 \approx 0.357 \approx \frac{5}{14}\)</span></p>
<p>可以看到d基本是在范围内的，故攻击可行</p>
<p>已知：n组<span class="math inline">\(e_i\)</span>，满足<span class="math inline">\(e_i * d_i = 1 + ki * \phi(N), d &lt; N^{\delta}\)</span></p>
<p>本题使用了<span class="math inline">\(lcm(N)\)</span>，相当于<span class="math inline">\(e_i * d_i = 1 + ki * \frac{\phi(N)}{g}\)</span>，并无无太大影响</p>
<p>依据四个等式可以列出矩阵：</p>
<p>之后为了能够正确格基约化，需要将各分量放缩到数量级相近，通过简单计算使用如下放缩矩阵即可：</p>
<p><img src="/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-2/image-20200918180437622.png"></p>
<p>之后直接求解方程组，得到向量<span class="math inline">\(x_2\)</span>，然后利用如下推导，即可求出<span class="math inline">\(\phi(N)\)</span> <span class="math display">\[
e_i * d_i = 1 + k_i * \frac{\phi(N)}{g}\\
\Rightarrow \phi(N) = \frac{e_id_ig-g}{k_i}\\
\Rightarrow \phi(N) = \frac{e_id_ig}{k_i} + \frac{g}{k_i}\\
\Rightarrow  e_i * \frac{k_2d_1g}{k_1k_2}-1 \leq \phi(N) \leq e_i * \frac{k_2d_1g}{k_1k_2} + 1
\]</span></p>
<p>最后等式中未知的分母，分子即为<span class="math inline">\(x_2\)</span>向量中的分量，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto_tools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.all_cmdline <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = </span><br><span class="line">e1 = </span><br><span class="line">e2 = </span><br><span class="line">c = </span><br><span class="line">E = [e1, e2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2048</span>//<span class="number">3</span>,  <span class="number">2048</span>//<span class="number">3</span> + <span class="number">50</span>):</span><br><span class="line">    x = Integer(i) / Integer(<span class="number">2048</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    N_1 = round(N**(Integer(<span class="number">1</span>)/Integer(<span class="number">2</span>)))</span><br><span class="line">    N_2 = round(N**(<span class="number">1</span>+x))</span><br><span class="line"></span><br><span class="line">    N_3 = round(N**(Integer(i) / Integer(<span class="number">100</span>)))</span><br><span class="line">    A = Matrix(ZZ, [[N,   -N_1 * N,   <span class="number">0</span>,            N**<span class="number">2</span>],</span><br><span class="line">                    [<span class="number">0</span>,   N_1 * e2,  -N_2 * e2,     -e2*N],</span><br><span class="line">                    [<span class="number">0</span>,    <span class="number">0</span>,         N_2 * e1,     -e1*N],</span><br><span class="line">                    [<span class="number">0</span>,    <span class="number">0</span>,         <span class="number">0</span>,            e1*e2]])</span><br><span class="line"></span><br><span class="line">    AL = A.LLL()</span><br><span class="line">    C = Matrix(ZZ, AL[<span class="number">0</span>])</span><br><span class="line">    B = A.solve_left(C)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    phi_base = floor(e2 * (B[<span class="number">1</span>] // B[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">2</span>):</span><br><span class="line">        phi = phi_base + j</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> E:</span><br><span class="line">            d = inverse(e, phi)</span><br><span class="line">            m = long_to_bytes(pow(c, d, N))</span><br><span class="line">            <span class="keyword">if</span> all_ascii(m):</span><br><span class="line">                print(m)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><del>奇怪的想法</del></p>
<p>emmm我在复现的时候看paper，就觉得很奇怪，为什么构造的等式一定是这四个呢：</p>
<p><img src="/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-2/image-20200918181621345.png"></p>
<p>从理论上来说，将<span class="math inline">\(G_{1,2}\)</span> 替换成<span class="math inline">\(k_1W_2\)</span>，似乎也无伤大雅，但我尝试这样构造之后，并没有成功，即便爆破了放缩的系数，仍然无法求解，而且误差相当的大，后来算了一波bound，发现确实不符合2333，大概作者写的时候可能也经历了这种尝试吧。</p>
<p>不过这题也帮我梳理了一种构造Latiice时的步骤：</p>
<ol type="1">
<li>寻找n组等式，其中具有n个未知量</li>
<li>通过这n组等式，提取出n个未知量作为初始向量x，构造秩为n的矩阵A，并有<span class="math inline">\(xA = y\)</span></li>
<li>计算向量y的范数，分析各分量的数量级，通过一个放缩矩阵D，将y向量各分量尽量放缩到一个数量级上</li>
<li>对矩阵<span class="math inline">\(A&#39; = AD\)</span>使用格基约化，利用约简出的向量和<span class="math inline">\(A&#39;\)</span> 矩阵求出向量x，得到欲求量</li>
</ol>
<h4 id="pwnhub2020-crypto-theme">Pwnhub2020 Crypto theme</h4>
<h5 id="coinflip">CoinFlip</h5>
<p>知识点：</p>
<p>Elgamal加密时所选p（即模）的安全准则：DDH假设（Decisional Diffie–Hellman）</p>
<p>对于随机选取的<span class="math inline">\(a, b \in Z_p\)</span>，已知<span class="math inline">\(g^a, g^b\)</span>，产生的 <span class="math inline">\(g^{ab}\)</span> 接近于<span class="math inline">\(Z_p\)</span> 上的随机数</p>
<p>可以形式化为：</p>
<ol type="1">
<li>若p存在k次剩余<span class="math inline">\(r_k\)</span>，<span class="math inline">\(\frac{p-1}{k}\)</span> 也应为一大素数</li>
<li>对于p上的任意椭圆曲线E，E的阶很大</li>
<li>对于p上的超椭圆曲线，其Jacobian的阶很大</li>
</ol>
<p><img src="/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-2/image-20200927223628490.png"></p>
<p>如上所述，GF上的乘法群并不符合DDH假设，因为其可以通过计算Lengendre符号区分<span class="math inline">\(g^ab\)</span>和一般随机序列。故直接根据所给公钥，区分两组明文，但存在一定概率性（两组明文的Lengendre符号可能相同）。</p>
<p>测试exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> ElGamal</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> SystemRandom</span><br><span class="line"><span class="keyword">from</span> Crypto_tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = </span><br><span class="line">g = </span><br><span class="line">y = </span><br><span class="line">pubkey = ElGamal.construct((p, g, y))</span><br><span class="line">base = jacobi(y, p)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">2</span>**<span class="number">10</span>)):</span><br><span class="line">    rnd = SystemRandom()</span><br><span class="line">    msg1 = bytes_to_long(<span class="string">b&quot;Head&quot;</span> + os.urandom(<span class="number">124</span>))</span><br><span class="line">    msg2 = bytes_to_long(<span class="string">b&quot;Tail&quot;</span> + os.urandom(<span class="number">124</span>))</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        coin = rnd.randrange(<span class="number">2</span>)</span><br><span class="line">        gift = pubkey._encrypt([msg1, msg2][coin], rnd.randrange(<span class="number">1</span>, p - <span class="number">1</span>))</span><br><span class="line">        check_1 = jacobi(gift[<span class="number">0</span>], p)</span><br><span class="line">        check_2 = jacobi(gift[<span class="number">1</span>], p)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> check_1 == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> check_2 == <span class="number">1</span>:</span><br><span class="line">                ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> check_1 == <span class="number">-1</span> <span class="keyword">and</span> base == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> check_2 == <span class="number">1</span>:</span><br><span class="line">                ans = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> ans == coin:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">50</span>:</span><br><span class="line">                print(<span class="string">&#x27;try %d times&#x27;</span> % i)</span><br><span class="line">                print(<span class="string">&#x27;flag&#123;LordRiot\&#x27;s test flag&#125;&#x27;</span>)</span><br><span class="line">                exit()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>注意pycrypto中的Elgamal由于继承关系，encrypt函数为空，应调用_encrypt函数。</p>
<h5 id="oblivious-transfer">Oblivious transfer</h5>
<p>核心漏洞是在于始终使用一组RSA公私钥，从而可以构造两个连接，利用不变量来爆破，wp郑佬写的很详细了，这里就不详述了，我这里把大小写区分了一下，大概跑一百多次就可以跑出结果，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment"># main-decrypt</span></span><br><span class="line">main_connection = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">n = int(main_connection.recvline())</span><br><span class="line">e = int(main_connection.recvline())</span><br><span class="line">init_x0 = int(main_connection.recvline())</span><br><span class="line">init_x1 = int(main_connection.recvline())</span><br><span class="line">main_connection.sendline(str(init_x0))</span><br><span class="line">msg0 = int(main_connection.recvline())</span><br><span class="line">init_enc1 = int(main_connection.recvline())</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub-attack</span></span><br><span class="line">attack_connection = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">attack_connection.recvline()</span><br><span class="line">attack_connection.recvline()</span><br><span class="line">possible = [set(range(<span class="number">256</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">cnt = <span class="number">1</span></span><br><span class="line">little_min = <span class="number">97</span></span><br><span class="line">little_max = <span class="number">122</span></span><br><span class="line">big_min = <span class="number">65</span></span><br><span class="line">big_max = <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    x0 = int(attack_connection.recvline())</span><br><span class="line">    x1 = int(attack_connection.recvline())</span><br><span class="line">    attack_connection.sendline(str(init_x0 - init_x1 + x0))</span><br><span class="line">    enc0 = int(attack_connection.recvline())</span><br><span class="line">    enc1 = int(attack_connection.recvline())</span><br><span class="line">    attack_connection.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    attack_connection.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    bytes_enc = long_to_bytes(enc0, <span class="number">256</span>)[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            carrymin = <span class="number">0</span></span><br><span class="line">            carrymax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> min(possible[i - <span class="number">1</span>]) + big_min &gt;= <span class="number">256</span>:</span><br><span class="line">                carrymin = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carrymin = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> max(possible[i - <span class="number">1</span>]) + little_max &lt; <span class="number">256</span>:</span><br><span class="line">                carrymax = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carrymax = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">256</span> - <span class="number">1</span>:</span><br><span class="line">            little_start = bytes_enc[i] - carrymax</span><br><span class="line">            little_end = bytes_enc[i] - carrymin</span><br><span class="line">            big_start = bytes_enc[i] - carrymax</span><br><span class="line">            big_end = bytes_enc[i] - carrymin</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            little_start = bytes_enc[i] - little_max - carrymax</span><br><span class="line">            little_end = bytes_enc[i] - little_min - carrymin</span><br><span class="line">            big_start = bytes_enc[i] - big_max - carrymax</span><br><span class="line">            big_end = bytes_enc[i] - big_min - carrymin</span><br><span class="line">        tmp = set(x % <span class="number">256</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(little_start, little_end + <span class="number">1</span>)) | set(x % <span class="number">256</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(big_start, big_end + <span class="number">1</span>))</span><br><span class="line">        possible[i] &amp;= tmp</span><br><span class="line"></span><br><span class="line">    limit = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        limit *= len(possible[i])</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    print(cnt, limit.bit_length())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> limit &lt; <span class="number">50000</span>:</span><br><span class="line">        print(<span class="string">&quot;Trying all possibilities&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> product(*possible):</span><br><span class="line">            m = bytes_to_long(bytes(b[::<span class="number">-1</span>])) % n</span><br><span class="line">            <span class="keyword">if</span> pow(m, e, n) == init_x0 - init_x1:</span><br><span class="line">                main_connection.sendline(str(msg0))</span><br><span class="line">                main_connection.sendline(str((init_enc1 - m) % n))</span><br><span class="line">                print(<span class="string">&#x27;Got&#x27;</span>)</span><br><span class="line">                print(main_connection.recvline())</span><br><span class="line">                main_connection.interactive()</span><br><span class="line">        print(<span class="string">&quot;Failed&quot;</span>)</span><br><span class="line">        attack_connection.close()</span><br><span class="line">        main_connection.close()</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Crypto in CTF</category>
      </categories>
      <tags>
        <tag>Crypto in CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题闲记-3</title>
    <url>/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-3/</url>
    <content><![CDATA[<h4 id="tctf-quals-2020">TCTF Quals 2020</h4>
<h5 id="baby-ring">baby ring</h5>
<p>当时打Quals的时候还没怎么开始密码学，全程划水233，看了rxz大佬的exp发现他是拿线性基做的，这就是OI大佬吗，i了i了，但由于我是条懒狗，所以并没有去学线性基，就还是用最基本的线代知识做。</p>
<p>分析题目，可知是需要输入64组x，然后server计算<span class="math inline">\(y_i \equiv x_i^e \mod n_i\)</span>，之后获取输入<span class="math inline">\(v\)</span>，重复64次<span class="math inline">\(cur = RC4(cur, key) \quad XOR\quad y_i\)</span>，由于RC4计算中均是异或PRNG的生成流，又考虑到异或运算的交换律，可知<span class="math inline">\(cur = v \quad XOR\quad RC4_{sum} \quad XOR \quad y_{sum}\)</span>，其中<span class="math inline">\(RC4_{sum}\)</span> 指RC4的所有生成流异或的结果，由于RC4的key已知，这部分是确定的，<span class="math inline">\(y_{sum}\)</span> 指所有<span class="math inline">\(y_i\)</span> 的异或结果，可知需要让<span class="math inline">\(y_{sum} = RC4_{sum}\)</span></p>
<p>仔细思考就会发现，这其实是个模线性方程问题，即构造矩阵<span class="math inline">\(Y = [yb_0, yb_1, \dots, yb_{63}]\)</span>，其中列向量<span class="math inline">\(yb_i\)</span>为<span class="math inline">\(y_i\)</span>的二进制排列，再考虑向量<span class="math inline">\(r = [RC4b]\)</span>，其为<span class="math inline">\(RC4_{sum}\)</span>的二进制排列，可知原问题等价于求出在模2（异或等价于模2上的加）上的<span class="math inline">\(Ax = r\)</span>。</p>
<p>这时再考虑<span class="math inline">\(y_i\)</span>的生成，为了方便起见，只需设置一个base，<span class="math inline">\(y_i \equiv base^e \mod n_i\)</span>即可，进行小范围遍历（我这里选取’LordRiot’为msg，遍历到3即发现解，看到有别人的exp，选用‘aaa’做msg，2即可求解了），即可找到使得<span class="math inline">\(Ax = r\)</span>有解的base，之后根据向量<span class="math inline">\(x\)</span>，第 i 次交互时，若<span class="math inline">\(x_i\)</span>为1，则发送base，否则发送0即可，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> winpwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">e, Ns = </span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10001</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;message:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;LordRiot&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get target</span></span><br><span class="line">key = sha256(<span class="string">&#x27;LordRiot&#x27;</span>.encode()).digest()[:<span class="number">16</span>]</span><br><span class="line">E = ARC4.new(key)</span><br><span class="line">target = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">    target ^= unpack(<span class="string">&#x27;Q&#x27;</span>, E.encrypt(pack(<span class="string">&#x27;Q&#x27;</span>, <span class="number">0</span>)))[<span class="number">0</span>]</span><br><span class="line">print(target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># use sage get ans</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">from sage.all import *</span></span><br><span class="line"><span class="string">candidate = [pow(3, e, N) % (1 &lt;&lt; 64) for N in Ns]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I = GF(2)</span></span><br><span class="line"><span class="string">_matrix = [[] for _ in range(64)]</span></span><br><span class="line"><span class="string">for i in range(64):</span></span><br><span class="line"><span class="string">    _matrix[i] = [int(bit) for bit in bin(candidate[i])[2:].rjust(64, &#x27;0&#x27;)]</span></span><br><span class="line"><span class="string">_matrix = matrix(I, _matrix)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">target_vec = [int(bit) for bit in bin(target)[2:].rjust(64, &#x27;0&#x27;)]</span></span><br><span class="line"><span class="string">target_vec = matrix(I, target_vec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ans = _matrix.solve_left(target_vec)</span></span><br><span class="line"><span class="string">print(&#x27;ans =&#x27;, list(res[0]))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ans = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># io to get flag</span></span><br><span class="line">print(len(ans))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> ans[i] == <span class="number">1</span>:</span><br><span class="line">        p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;v:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h5 id="simple-curve">Simple Curve</h5>
<p>这个题涉及到概念 <strong>hyperelliptic curve</strong>，具体的理论我在Way to Crypto中已添加，此处不做赘述，<a href="https://jack4818.github.io/0CTF/#simple-curves">这篇wp</a>讲的很好，推荐一看。</p>
<p>这里的曲线是基于<span class="math inline">\(F_{q^n}, q = 2, n = 256\)</span> 的</p>
<p>这里使用的超椭圆曲线即为：<span class="math inline">\(v^2 +h(u)v = f(u)\)</span>，此处<span class="math inline">\(h(u) = u^2 + u, f(u) = u^5 + u^3 + 1\)</span></p>
<p>之前的paper中提供了一种计算Jacobian阶的算法（看到Balsn是用的<a href="http://magma.maths.usyd.edu.au/calc/">Magma</a>，可以直接算）</p>
<p><img src="/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-3/image-20200930154458064.png"></p>
<p><em>Magma代码：</em></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">P&lt;x&gt; := PolynomialRing(GF(<span class="number">2</span>^<span class="number">256</span>));</span><br><span class="line">C := HyperellipticCurve(x^<span class="number">5</span> + x^<span class="number">3</span> + <span class="number">1</span>, x^<span class="number">2</span> + x);</span><br><span class="line">C;</span><br><span class="line">J := Jacobian(C);</span><br><span class="line">O := #J;</span><br><span class="line">O;</span><br></pre></td></tr></table></figure>
<p>具体算法步骤可以参见Way to Crypto中的描述和exp中的代码</p>
<p>这里的F.fetch_int(n) 函数的意思是将整数n转为二进制序列，然后将其作为域F上多项式<span class="math inline">\(\sum_{i=1}^r a_ix_i\)</span>的系数，即<span class="math inline">\(a_i\)</span>，实例如下：</p>
<p><img src="/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-3/image-20200929170701091.png"></p>
<p>而decode时的这个操作:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [i.integer_representation() <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br></pre></td></tr></table></figure>
<p>其中于integer_representation()函数为fetch_int()的逆函数，即是将多项式转为了一个整数。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto_tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">F = GF(<span class="number">2</span>**<span class="number">256</span>)</span><br><span class="line">P = PolynomialRing(F, <span class="string">&#x27;u, v&#x27;</span>)</span><br><span class="line">u, v = P.gens()</span><br><span class="line">PP = PolynomialRing(F, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">w = PP.gens()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">h = u^<span class="number">2</span> + u</span><br><span class="line">f = u^<span class="number">5</span> + u^<span class="number">3</span> + <span class="number">1</span></span><br><span class="line">c = v^<span class="number">2</span> + h*v - f</span><br><span class="line">f = f(u=w)</span><br><span class="line">h = h(u=w)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">plain</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> plain &lt; <span class="number">2</span> ** <span class="number">256</span></span><br><span class="line">    x = F.fetch_int(plain)</span><br><span class="line">    y, k = c(u=x, v=w).roots()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> k == <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> w - x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">c</span>):</span></span><br><span class="line">    x, y = c</span><br><span class="line">    tmp = x</span><br><span class="line">    x = [i.integer_representation() <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">    y = [i.integer_representation() <span class="keyword">for</span> i <span class="keyword">in</span> y]</span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">p1, p2</span>):</span></span><br><span class="line">    a1, b1 = p1</span><br><span class="line">    a2, b2 = p2</span><br><span class="line">    d1, e1, e2 = xgcd(a1, a2)</span><br><span class="line">    d, c1, c2 = xgcd(d1, b1 + b2 + h)</span><br><span class="line">    di = PP(<span class="number">1</span> / d)</span><br><span class="line">    a = a1 * a2 * di * di</span><br><span class="line">    b = (c1 * e1 * a1 * b2 + c1 * e2 * a2 * b1 + c2 * (b1 * b2 + f)) * di</span><br><span class="line">    b %= a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> a.degree() &gt; <span class="number">2</span>:</span><br><span class="line">        a = PP((f - b * h - b * b) / a)</span><br><span class="line">        b = (-h - b) % a</span><br><span class="line">    a = a.monic()</span><br><span class="line">    <span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">p, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp = mul(p, k // <span class="number">2</span>)</span><br><span class="line">        tmp = add(tmp, tmp)</span><br><span class="line">        <span class="keyword">if</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            tmp = add(tmp, p)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># exp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">re_decode</span>(<span class="params">data</span>):</span></span><br><span class="line">      xs, ys = data</span><br><span class="line">      pt_x = PP([F.fetch_int(i) <span class="keyword">for</span> i <span class="keyword">in</span> xs])</span><br><span class="line">      pt_y = PP([F.fetch_int(i) <span class="keyword">for</span> i <span class="keyword">in</span> ys])</span><br><span class="line">      <span class="keyword">return</span> (pt_x, pt_y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Paramters and curve</span></span><br><span class="line">q = <span class="number">2</span></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line">genus = <span class="number">2</span></span><br><span class="line"><span class="comment"># h(x) = x^2 + x</span></span><br><span class="line"><span class="comment"># f(x) = x^5 + x^3 + 1</span></span><br><span class="line">_h = <span class="keyword">lambda</span> x: x ^ <span class="number">2</span> + x</span><br><span class="line">_f = <span class="keyword">lambda</span> x: x ^ <span class="number">5</span> + x ^ <span class="number">3</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc M_i</span></span><br><span class="line">M = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus):</span><br><span class="line">    P.&lt;x&gt; = PolynomialRing(GF(q ^ (i + <span class="number">1</span>)))</span><br><span class="line">    C = HyperellipticCurve(_f(x), _h(x))</span><br><span class="line">    M.append(C.cardinality())</span><br><span class="line">print(<span class="string">&quot;Calc M done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc a_i</span></span><br><span class="line">a = [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus):</span><br><span class="line">    a.append((M[i] - <span class="number">1</span> - q ^ (i + <span class="number">1</span>) + a[i] ^ (i + <span class="number">1</span>)) / (i + <span class="number">1</span>))</span><br><span class="line">a = [<span class="number">1</span>] + a[<span class="number">1</span>:]</span><br><span class="line">print(<span class="string">&quot;Calc a done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc gamma_i</span></span><br><span class="line">var(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">function = -genus * q</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus + <span class="number">1</span>):</span><br><span class="line">    function += a[i] * X ^ (genus - i)</span><br><span class="line">gamma = list(map(<span class="keyword">lambda</span> x: x.rhs(), solve([function == <span class="number">0</span>], X)))</span><br><span class="line">print(<span class="string">&quot;Calc gamma done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc alpha_i</span></span><br><span class="line">alpha = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus):</span><br><span class="line">    function = X ^ <span class="number">2</span> - gamma[i] * X + q</span><br><span class="line">    alpha.append(list(map(<span class="keyword">lambda</span> x: x.rhs(), solve([function == <span class="number">0</span>], X))))</span><br><span class="line">print(<span class="string">&quot;Calc alpha done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc #J</span></span><br><span class="line">order = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus):</span><br><span class="line">    order *= abs(<span class="number">1</span> - alpha[i][<span class="number">0</span>] ^ n) ^ <span class="number">2</span></span><br><span class="line">print(<span class="string">&#x27;#J =&#x27;</span>, int(order))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ctext = ([<span class="number">113832590633816699072296178013238414056344242047498922038140127850188287361982</span>, <span class="number">107565990181246983920093578624450838959059911990845389169965709337104431186583</span>, <span class="number">1</span>], [<span class="number">60811562094598445636243277376189331059312500825950206260715002194681628361141</span>, <span class="number">109257511993433204574833526052641479730322989843001720806658798963521316354418</span>])</span><br><span class="line">J_card = int(order)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = inverse(<span class="number">0x10001</span>, J_card)</span><br><span class="line">flag_point = mul(re_decode(ctext), d)</span><br><span class="line">flag_int = decode(flag_point)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(flag_int))</span><br></pre></td></tr></table></figure>
<h4 id="tctf2020-final">TCTF2020 Final</h4>
<h5 id="obviously-transfer">Obviously Transfer</h5>
<p>本题的关键是将<span class="math inline">\(c = x0 \ \ XOR \ \ x1\)</span>，看作<span class="math inline">\(c \equiv m^e \mod n\)</span>，则有<span class="math inline">\(c^d \equiv m^{ed} \equiv m \mod n\)</span>，则可解密出flag。</p>
<p>流程为：</p>
<ol type="1">
<li>先获取一组数据x0，x1，然后直接将x0发给server，则返回的m0p即为m0，则通过生成m0r再与m1p异或可以得到<span class="math inline">\(flag \ \ XOR \ \ k_1\)</span></li>
<li>考虑到其中<span class="math inline">\(k_1 = (x_0\ \ XOR \ \ x_1)^d\)</span>，考虑<span class="math inline">\((x_0\ \ XOR \ \ x_1) \equiv m^e \mod n\)</span>，则有<span class="math inline">\(k_1 = m\)</span>，从而转化为已知enc，求m问题</li>
<li>想到可以通过partial oracle来实现，至于获取具体的low bit，是通过m0p的低位和m1p的高位异或而确定的，因为m0p的低位为<span class="math inline">\(lsb \ \ XOR \ \ m0_{low}\)</span>，而m1p的高位与m1相同概率很大（因为k1模n，其高位均匀分布，故当样本增多的时候产生影响不断降低），而m1的高位又与m0相同，故重复一定次数，根据概率即可确定lsb</li>
</ol>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> winpwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto_tools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num</span>(<span class="params">until</span>):</span></span><br><span class="line">    p.recvuntil(until)</span><br><span class="line">    <span class="keyword">return</span> int(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BITS = <span class="number">2048</span></span><br><span class="line">flag_len = BITS // <span class="number">8</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">10002</span>)</span><br><span class="line">n = get_num(<span class="string">&#x27;n = &#x27;</span>)</span><br><span class="line">e = get_num(<span class="string">&#x27;e = &#x27;</span>)</span><br><span class="line"></span><br><span class="line">x0 = get_num(<span class="string">&#x27;x0 = &#x27;</span>)</span><br><span class="line">x1 = get_num(<span class="string">&#x27;x1 = &#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(str(x0))</span><br><span class="line">m0 = get_num(<span class="string">&#x27;m0p = &#x27;</span>)</span><br><span class="line">m1 = get_num(<span class="string">&#x27;m1p = &#x27;</span>)</span><br><span class="line"></span><br><span class="line">m0r = (((m0 &amp; <span class="number">1</span>) &lt;&lt; (BITS - <span class="number">1</span>)) | (m0 &gt;&gt; <span class="number">1</span>))</span><br><span class="line">k1_flag = m1 ^ m0 ^ m0r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># partial oracle attack</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span>(<span class="params">enc</span>):</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    loop = <span class="number">40</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(loop):</span><br><span class="line">        _x0 = get_num(<span class="string">&#x27;x0 = &#x27;</span>)</span><br><span class="line">        _x1 = get_num(<span class="string">&#x27;x1 = &#x27;</span>)</span><br><span class="line">        p.sendline(str(_x0 ^ enc))</span><br><span class="line">        low_bit = get_num(<span class="string">&#x27;m0p = &#x27;</span>) &amp; <span class="number">1</span></span><br><span class="line">        high_bit = get_num(<span class="string">&#x27;m1p = &#x27;</span>) &gt;&gt; (BITS - <span class="number">1</span>)</span><br><span class="line">        cnt += low_bit ^ high_bit</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> cnt / loop &gt; <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_oracle_attack</span>(<span class="params">c, e, n, enc</span>):</span></span><br><span class="line">    nbits = n.bit_length()</span><br><span class="line">    decimal.getcontext().prec = nbits</span><br><span class="line">    low = decimal.Decimal(<span class="number">0</span>)</span><br><span class="line">    high = decimal.Decimal(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(nbits)):</span><br><span class="line">        c = (c * pow(<span class="number">2</span>, e, n)) % n</span><br><span class="line">        <span class="keyword">if</span> oracle(c) == <span class="number">0</span>:</span><br><span class="line">            high = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">8</span> == <span class="number">0</span>:</span><br><span class="line">            flag = enc ^ int(high)</span><br><span class="line">            print(long_to_bytes(flag)[:i // <span class="number">8</span>])</span><br><span class="line">    <span class="keyword">return</span> int(high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k1 = partial_oracle_attack(x0 ^ x1, e, n, k1_flag)</span><br></pre></td></tr></table></figure>
<p>由于其是有概率的，所以可能需要多试几次，成功时效果如下：</p>
<p><img src="/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-3/image-20201004150712900.png"></p>
<p>本地大概需要25秒左右可以跑出一字节flag。</p>
<h4 id="cryptoctf-2020">CryptoCTF 2020</h4>
<h5 id="decent-rsa">Decent RSA</h5>
<p>这题学到了神奇的套路233，如果将n转化为<span class="math inline">\(GF(q)\)</span> 上多项式后，其分量不多，则可以在多项式上做分解求得p，q</p>
<p>此题中，n在<span class="math inline">\(GF(11)\)</span> 上表示为如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x^<span class="number">592</span> + x^<span class="number">589</span> + <span class="number">2</span>*x^<span class="number">559</span> + x^<span class="number">547</span> + <span class="number">2</span>*x^<span class="number">501</span> + <span class="number">2</span>*x^<span class="number">498</span> + <span class="number">2</span>*x^<span class="number">492</span> + <span class="number">2</span>*x^<span class="number">475</span> + <span class="number">2</span>*x^<span class="number">472</span> + <span class="number">4</span>*x^<span class="number">468</span> + <span class="number">2</span>*x^<span class="number">456</span> + <span class="number">4</span>*x^<span class="number">444</span> + <span class="number">4</span>*x^<span class="number">442</span> + <span class="number">2</span>*x^<span class="number">430</span> + <span class="number">2</span>*x^<span class="number">420</span> + <span class="number">4</span>*x^<span class="number">401</span> + <span class="number">4</span>*x^<span class="number">375</span> + <span class="number">8</span>*x^<span class="number">353</span> + <span class="number">4</span>*x^<span class="number">329</span> + <span class="number">8</span>*x^<span class="number">327</span> + <span class="number">2</span>*x^<span class="number">311</span> + <span class="number">4</span>*x^<span class="number">303</span> + <span class="number">6</span>*x^<span class="number">296</span> + <span class="number">2</span>*x^<span class="number">293</span> + <span class="number">4</span>*x^<span class="number">263</span> + <span class="number">2</span>*x^<span class="number">251</span> + <span class="number">4</span>*x^<span class="number">220</span> + <span class="number">8</span>*x^<span class="number">205</span> + <span class="number">4</span>*x^<span class="number">196</span> + <span class="number">4</span>*x^<span class="number">194</span> + <span class="number">8</span>*x^<span class="number">179</span> + <span class="number">8</span>*x^<span class="number">148</span> + <span class="number">4</span>*x^<span class="number">124</span> + <span class="number">4</span>*x^<span class="number">15</span> + <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>分解得p，q：</p>
<p><img src="/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-3/image-20201004175046117.png"></p>
<p>之后分解即可。</p>
<p>test demo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bits = <span class="number">256</span></span><br><span class="line">p = getPrime(bits)</span><br><span class="line">q = getPrime(bits)</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = next_prime(p)</span><br><span class="line">    q = next_prime(q)</span><br><span class="line">    n = p * q</span><br><span class="line">    <span class="keyword">for</span> prime <span class="keyword">in</span> primes:</span><br><span class="line">        tmp = sys_convert(n, prime, max=primes[<span class="number">-1</span>]).count(<span class="string">&#x27;0&#x27;</span>)/len(sys_convert(n, prime, max=primes[<span class="number">-1</span>]))</span><br><span class="line">        <span class="keyword">if</span> tmp &gt; <span class="number">0.8</span>:</span><br><span class="line">            print(<span class="string">&#x27;p =&#x27;</span>, p)</span><br><span class="line">            print(<span class="string">&#x27;q =&#x27;</span>, q)</span><br><span class="line">            print(<span class="string">&#x27;n =&#x27;</span>, n)</span><br><span class="line">            print(<span class="string">&#x27;density =&#x27;</span>, tmp)</span><br><span class="line">            print(<span class="string">&#x27;n base on %d = %s&#x27;</span> % (prime, sys_convert(n, prime, max=primes[<span class="number">-1</span>])))</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> index % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&#x27;%d rounds&#x27;</span> % (index//<span class="number">100</span>))</span><br><span class="line">        p = getPrime(bits)</span><br><span class="line">        q = getPrime(bits)</span><br></pre></td></tr></table></figure>
<p>emmmmm，然而找上万轮也没找到2333，本来还想着可以拿来出题的233</p>
<h5 id="abbout">abbout</h5>
<p>这个题提醒了我密码中也要善用数学归纳法。。。</p>
<p>通过输出其实可以发现每个分数的倒数的绝对值的整数部分即是对应的字符的ascii值，依次写出逆函数，则有exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> frac</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag_min = <span class="number">48</span></span><br><span class="line">flag_max = <span class="number">125</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">re_me</span>(<span class="params">fini</span>):</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    den, num = fini[<span class="number">0</span>], fini[<span class="number">1</span>]</span><br><span class="line">    reducer = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">        char = int(den / num)</span><br><span class="line">        res += chr(char)</span><br><span class="line">        tmp = frac(den, num) - char</span><br><span class="line">        reducer += <span class="number">1</span></span><br><span class="line">        den, num = tmp.denominator * reducer, tmp.numerator</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">re_you</span>(<span class="params">fini</span>):</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    den, num = fini[<span class="number">0</span>], fini[<span class="number">1</span>]</span><br><span class="line">    reducer = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">        char = abs(round(den / num))</span><br><span class="line">        res += chr(char)</span><br><span class="line">        tmp = frac(den, num) - char</span><br><span class="line">        reducer *= <span class="number">-1</span></span><br><span class="line">        den, num = tmp.denominator * reducer, tmp.numerator</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">re_us</span>(<span class="params">fini</span>):</span></span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    den, num = fini[<span class="number">0</span>], fini[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">        char = abs(round(den / num))</span><br><span class="line">        res += chr(char)</span><br><span class="line">        tmp = frac(den, num) - char</span><br><span class="line">        den, num = tmp.denominator, tmp.numerator</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enc = [</span><br><span class="line">    (<span class="number">4874974328610108385835995981839358584964018454799387862</span>, <span class="number">72744608672130404216404640268150609115102538654479393</span>)</span><br><span class="line">    ,</span><br><span class="line">    (<span class="number">39640220997840521464725453281273913920171987264976009809</span>, <span class="number">366968282179507143583456804992018400453304099650742276</span>)</span><br><span class="line">    ,</span><br><span class="line">    (<span class="number">145338791483840102508854650881795321139259790204977</span>, <span class="number">1529712573230983998328149700664285268430918011078</span>)</span><br><span class="line">    ,</span><br><span class="line">    (<span class="number">84704403065477663839636886654846156888046890191627</span>, <span class="number">717773708720775877427974283328022404459326394028</span>)</span><br><span class="line">    ,</span><br><span class="line">    (<span class="number">287605888305597385307725138275886061497915866633976011</span>, <span class="number">8712550395581704680675139804565590824398265004367939</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line"><span class="comment"># me</span></span><br><span class="line">flag.append(re_me(enc[<span class="number">2</span>]))</span><br><span class="line">flag.append(re_me(enc[<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># you</span></span><br><span class="line">flag.append(re_you(enc[<span class="number">1</span>]))</span><br><span class="line">flag.append(re_you(enc[<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># us</span></span><br><span class="line">flag.append(re_us(enc[<span class="number">0</span>]))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>
<p>以me函数分析其数学原理，以数列<span class="math inline">\(\{m_n\}\)</span>表示明文序列，<span class="math inline">\(l\)</span> 表示明文序列长度，可知对于分数数列<span class="math inline">\(\{a_n\}\)</span>，有<span class="math inline">\(a_0 = \frac{l-1}{m_0}\)</span>，之后进行轮操作</p>
<p><span class="math display">\[a_1 = \frac{l-2}{a_0+m_1} , \frac{1}{a_1} = \frac{l-1}{(l-2)m_0} + \frac{m_1}{l-2} \Rightarrow \frac{l-2}{a_1} \approx m_1 \]</span></p>
<p>通过数学归纳法，不难证明对于<span class="math inline">\(a_i\)</span> 均有<span class="math inline">\(\frac{l-1-i}{a_i} \approx m_i\)</span>，从而可以迭代求解。</p>
<p>埋个坑，下次用数学归纳法整个数列题玩玩2333</p>
<h5 id="strip">strip</h5>
<p>终于用了点分析里的技巧2333，其实也是很常用的技巧，观察数列<span class="math inline">\(\{a_n\}\)</span>，可知有 <span class="math display">\[
a_n = \frac{6*a_{n-1}^2}{a_{n-1}} - \frac{8a_{n-1}a_{n-2}}{a_{n-3}} \\
\Rightarrow \frac{a_n}{a_{n-1}} = \frac{6a_{n-1}}{a_{n-2}} - \frac{8a_{n-2}}{a_{n-3}}
\]</span> 于是设<span class="math inline">\(b_i = \frac{a_i}{a_{i-1}},i&gt;1\)</span>，则有<span class="math inline">\(b_n = 6b_{n-1}-8b_{n-2}\)</span>，待定系数法（有二解，等价）得<span class="math inline">\(b_n - 2b_{n-1} = 4b_{n-1} - 8b_{n-2}\)</span>，再设<span class="math inline">\(c_i = b_i-2b_{i-1},i&gt;2\)</span>，则有<span class="math inline">\(c_n = 4c_{n-1}\)</span>，即<span class="math inline">\(c_n = 4^{n-3}c_3\)</span></p>
<p>则<span class="math inline">\(c_n = 4^{n-3}*(\frac{24}{2} - \frac{2*2}{1}) = 4^{n-2}*2\)</span></p>
<p>然后就可以写出a的递推式了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> a(n)//a(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*b(n<span class="number">-1</span>) + c(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*<span class="number">4</span>**(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_a</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> my_a(n<span class="number">-1</span>) * b(n)</span><br></pre></td></tr></table></figure>
<p>从而得到n：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">2</span>**<span class="number">10</span>):</span><br><span class="line">    n = strip(my_a(i))</span><br><span class="line">    <span class="keyword">if</span> n &gt; enc:</span><br><span class="line">        print(<span class="string">&#x27;n =&#x27;</span>, n)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>emmmmm但这个n太大了，yafu分解不了，factordb输入都不行，此时想到n其实是<span class="math inline">\(b_i\)</span> 的连乘乘以一个常数再除以<span class="math inline">\(2^k\)</span>，于是计算k=183315：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bits = bin(my_a(<span class="number">606</span>))[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(bits)):</span><br><span class="line">    <span class="keyword">if</span> bits[i] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(n = \frac{24 * \prod_{i=4}^{606}b_i}{2^k} = \frac{3 * \prod_{i=4}^{606}b_i}{2^{k-3}}\)</span></p>
<p>计算phi，考虑到n太大了。。所以考虑使用n的因子<span class="math inline">\(a(x), x&lt; 606\)</span> 当作模，计算phi如下（获得n的所有素因子，其中get_factor_list函数是调用的factordb获得的素因子）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_phi_a</span>(<span class="params">index, return_list=False</span>):</span></span><br><span class="line">    primes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">4</span>, index+<span class="number">1</span>)):</span><br><span class="line">        tmp = strip(b(i))</span><br><span class="line">        <span class="keyword">if</span> isPrime(tmp):</span><br><span class="line">            primes.append(tmp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            factors = get_factor_list(tmp)</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> factors:</span><br><span class="line">                primes.append(factor)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> return_list:</span><br><span class="line">        <span class="keyword">return</span> set(primes)</span><br><span class="line"></span><br><span class="line">    phi = <span class="number">2</span></span><br><span class="line">    factor_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> primes:</span><br><span class="line">        factor_dict[key] = factor_dict.get(key, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> factor_dict.keys():</span><br><span class="line">        <span class="keyword">if</span> factor_dict[key] == <span class="number">1</span>:</span><br><span class="line">            phi *= int(key) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            phi *= int(key) - <span class="number">1</span></span><br><span class="line">            phi *= pow(key, factor_dict[key]<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> phi</span><br></pre></td></tr></table></figure>
<p>其中index即为<span class="math inline">\(n_{low} = a(x)\)</span>中的x</p>
<p>然后思路有两种，一种是直接找到足够大的index，另一种是找两个大点的素数然后CRT，遗憾的是index到200的时候仍然无法获得flag，于是改为第二种：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">factors_list = list(get_phi_a(<span class="number">606</span>, <span class="literal">True</span>))</span><br><span class="line">print(len(factors_list))</span><br><span class="line">e = <span class="number">0x10001</span> + <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> prime <span class="keyword">in</span> itertools.combinations(factors_list, <span class="number">2</span>):</span><br><span class="line">    p = prime[<span class="number">0</span>]</span><br><span class="line">    q = prime[<span class="number">1</span>]</span><br><span class="line">    n = p * q</span><br><span class="line">    phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">    m = pow(enc, inverse(e, phi), n)</span><br><span class="line">    flag = long_to_bytes(m)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;CCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>得到所有prime大概需要7，8分钟，最终得到flag：</p>
<p><img src="/2020/10/23/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-3/image-20201005231113072.png"></p>
<h4 id="n1ctf-2020">N1CTF 2020</h4>
<h5 id="easy-rsa">easy RSA</h5>
<p>本题有两层，一层是分解n，一层是恢复LWE，恢复LWE相对简单，与攻击GGH差不多，直接LLL后CVP即可，难点在于利用p，q生成弱点分解n。</p>
<p><span class="math inline">\(f(x) = a_4x^4 + a_3x^3 + a_2x^2 + a_1 x + a_0\)</span></p>
<p><span class="math inline">\(g(x) = b_4x^4 + b_3x^3 + b_2x^2 + b_1 x + b_0\)</span></p>
<p><span class="math inline">\(x_0= 3^{66}\)</span>， p为<span class="math inline">\(f(x_0)\)</span>最大的根，q为<span class="math inline">\(g(x_0)\)</span>最大的根</p>
<p>则有<span class="math inline">\(f(x_0) g(x_0) = k n\)</span>，k相对于n较小，设<span class="math inline">\(f(x)g(x) = \sum_{i=0}^8t_ix^i\)</span></p>
<p>即有<span class="math inline">\(\sum_{i=0}^8t_ix_0^i-kn =0\)</span> ，故可构造格：</p>
<p><span class="math display">\[\begin{bmatrix} 1 &amp; 0  &amp; \ldots &amp; 0 &amp; 0 &amp; x^8 \\ 0 &amp; 1  &amp; \ldots &amp; 0 &amp; 0 &amp; x^7 \\ \vdots  &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots  &amp; \vdots \\ 0 &amp; 0 &amp;  \ldots &amp; 1 &amp;  0 &amp; x \\ 0 &amp; 0  &amp; \ldots &amp; 0 &amp;  1 &amp; 1 \\ 0 &amp;  0 &amp; \ldots &amp; 0 &amp;  0 &amp;  N \end{bmatrix}\]</span></p>
<p>目标向量为<span class="math inline">\((t_8, t_7, \dots, t_0, 0)\)</span>，由于<span class="math inline">\(t_r = \sum_{i+j=r}a_i*b_j\)</span>，故<span class="math inline">\(t_i &lt; 2^{64} * (5 - |i-4|)\)</span></p>
<p>则其范数上界为<span class="math inline">\(\sqrt{\sum_{i=0}^8 (2^{64} * (5 - |i-4|))^2 } &lt; 2 ^ {68}\)</span></p>
<p>则由Minkowski定理得 <span class="math display">\[ 2 ^ {68} &lt; n^{\frac{1}{2}} det(L)^{\frac{1}{n}} = \sqrt{10} N^{\frac{1}{10}} \]</span></p>
<p>而<span class="math display">\[ \sqrt{10} N^{\frac{1}{10}} &gt; 2^{71} \]</span></p>
<p>故知Minkowski上界满足，但仍需要满足格内各基向量均大于目标向量范数，即需要在原有矩阵上乘均衡系数T，可知$ 2 ^ {68} &lt; T$</p>
<p>构造代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = matrix(ZZ, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">x = <span class="number">3</span> ** <span class="number">66</span></span><br><span class="line">balance = <span class="number">2</span> ** <span class="number">68</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    M[i, i] = <span class="number">1</span></span><br><span class="line">    M[i, <span class="number">9</span>] = (x ** (<span class="number">8</span>-i)) * balance</span><br><span class="line"></span><br><span class="line">M[<span class="number">9</span>, <span class="number">9</span>] = n * balance</span><br><span class="line">L = M.LLL()</span><br><span class="line">print(L[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>得到解向量后，直接多项式分解即可得到<span class="math inline">\(a_i, b_i\)</span>，则可分解n，分解部分完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># factor n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># calc the bound</span></span><br><span class="line">bound = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    bound += (<span class="number">2</span>**<span class="number">64</span> * (<span class="number">5</span> - abs(i - <span class="number">4</span>)))**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct the Lattice</span></span><br><span class="line">M = matrix(ZZ, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">x = <span class="number">3</span> ** <span class="number">66</span></span><br><span class="line">balance = <span class="number">2</span> ** int(iroot(int(bound), int(<span class="number">2</span>))[<span class="number">0</span>]).bit_length()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    M[i, i] = <span class="number">1</span></span><br><span class="line">    M[i, <span class="number">9</span>] = (x ** (<span class="number">8</span>-i)) * balance</span><br><span class="line"></span><br><span class="line">M[<span class="number">9</span>, <span class="number">9</span>] = n * balance</span><br><span class="line">L = M.LLL()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">P.&lt;y&gt; = PolynomialRing(ZZ)</span><br><span class="line">f = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    f += int(L[i]) * (y**(<span class="number">8</span>-i))</span><br><span class="line"></span><br><span class="line">factors = f.factor()</span><br><span class="line">a = list(factors[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">b = list(factors[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover_random_prime</span>(<span class="params">tmp</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        total += x ** i * tmp[i]</span><br><span class="line">    fac = str(factor(total)).split(<span class="string">&quot; * &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> int(fac[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">p = recover_random_prime(a)</span><br><span class="line">q = recover_random_prime(b)</span><br><span class="line"><span class="keyword">assert</span> n == p * q</span><br><span class="line">e = <span class="number">127</span></span><br><span class="line">d = inverse(e, (p<span class="number">-1</span>) * (q<span class="number">-1</span>))</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> enc:</span><br><span class="line">    result.append(pow(c, d, n))</span><br></pre></td></tr></table></figure>
<p>接下来恢复LWE即可，考虑<span class="math inline">\(A = [A_1, A_2, \dots, A_{127}]\)</span>，<span class="math inline">\(A_i\)</span> 为A的列向量，已知有<span class="math inline">\(A_im_i + b_i \equiv r_i \mod n\)</span>，其中<span class="math inline">\(m_i\)</span> 为flag第i个字符对应数字，<span class="math inline">\(b_i\)</span>为所加小偏移向量分量，<span class="math inline">\(r_i\)</span> 为通过分解n恢复的向量，n即模数152989197224467。</p>
<p>可知有<span class="math inline">\(A_i m_i + b_i = r_i + kn \Rightarrow A_im_i - kn = r_i - b_i\)</span>， 故考虑构造格使 $(r_1, r_2,, r_s) $ 向量在其上，再通过CVP寻找到<span class="math inline">\((r_1 - b_1, r_2-b_2,\dots ,r_s-b_s)\)</span> ，从而恢复出flag。</p>
<p>故构造格：</p>
<p><span class="math display">\[\begin{bmatrix} n &amp; 0  &amp; \ldots &amp; 0  \\ 0 &amp; n  &amp; \ldots &amp; 0 \\ \vdots  &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp;  \ldots &amp; n  \\ A_{11} &amp; A_{21}  &amp; \ldots &amp; A_{s1} \\ A_{12} &amp;  A_{22} &amp; \ldots &amp; A_{s2} \\ \vdots  &amp; \vdots &amp; \ddots &amp; \vdots  \\ A_{1s} &amp;  A_{2s} &amp; \ldots &amp; A_{ss}\end{bmatrix}\]</span></p>
<p>利用此格的正交基寻找CVP，改变s，发现<span class="math inline">\(s &gt; 50\)</span> 时，可以找到正确的向量，从而恢复flag，完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sage.modules.free_module_integer <span class="keyword">import</span> IntegerLattice</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">enc =</span><br><span class="line">n = </span><br><span class="line"></span><br><span class="line"><span class="comment"># factor n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># calc the bound</span></span><br><span class="line">bound = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    bound += (<span class="number">2</span>**<span class="number">64</span> * (<span class="number">5</span> - abs(i - <span class="number">4</span>)))**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct the Lattice</span></span><br><span class="line">M = matrix(ZZ, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">x = <span class="number">3</span> ** <span class="number">66</span></span><br><span class="line">balance = <span class="number">2</span> ** int(iroot(int(bound), int(<span class="number">2</span>))[<span class="number">0</span>]).bit_length()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    M[i, i] = <span class="number">1</span></span><br><span class="line">    M[i, <span class="number">9</span>] = (x ** (<span class="number">8</span>-i)) * balance</span><br><span class="line"></span><br><span class="line">M[<span class="number">9</span>, <span class="number">9</span>] = n * balance</span><br><span class="line">L = M.LLL()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">P.&lt;y&gt; = PolynomialRing(ZZ)</span><br><span class="line">f = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    f += int(L[i]) * (y**(<span class="number">8</span>-i))</span><br><span class="line"></span><br><span class="line">factors = f.factor()</span><br><span class="line">a = list(factors[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">b = list(factors[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover_random_prime</span>(<span class="params">tmp</span>):</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        total += x ** i * tmp[i]</span><br><span class="line">    fac = str(factor(total)).split(<span class="string">&quot; * &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> int(fac[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">p = recover_random_prime(a)</span><br><span class="line">q = recover_random_prime(b)</span><br><span class="line"><span class="keyword">assert</span> n == p * q</span><br><span class="line">print(<span class="string">&#x27;got factors&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e = <span class="number">127</span></span><br><span class="line">d = inverse(e, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> enc:</span><br><span class="line">    result.append(pow(c, d, n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># recover LWE</span></span><br><span class="line">A = np.ndarray.tolist(np.load(<span class="string">&#x27;A.npy&#x27;</span>))</span><br><span class="line">module = <span class="number">152989197224467</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CVP</span>(<span class="params">lattice, target</span>):</span></span><br><span class="line">    gram = lattice.gram_schmidt()[<span class="number">0</span>]</span><br><span class="line">    t = target</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(lattice.nrows())):</span><br><span class="line">        c = ((t * gram[i]) / (gram[i] * gram[i])).round()</span><br><span class="line">        t -= lattice[i] * c</span><br><span class="line">    <span class="keyword">return</span> target - t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">row = <span class="number">51</span></span><br><span class="line">column = <span class="number">43</span></span><br><span class="line">M = matrix(ZZ, row + column, row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(column):</span><br><span class="line">        M[row + j, i] = A[i][j]</span><br><span class="line">    M[i, i] = module</span><br><span class="line"></span><br><span class="line">lattice = IntegerLattice(M, lll_reduce=<span class="literal">True</span>)</span><br><span class="line">target = vector(ZZ, result[:row])</span><br><span class="line">res = CVP(lattice.reduced_basis, target)</span><br><span class="line">print(<span class="string">&#x27;got CVP&#x27;</span>)</span><br><span class="line">R = IntegerModRing(module)</span><br><span class="line">M = Matrix(R, A[:row])</span><br><span class="line"></span><br><span class="line">flag = M.solve_right(res)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> flag]))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Crypto in CTF</category>
      </categories>
      <tags>
        <tag>Crypto in CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题闲记-4</title>
    <url>/2021/01/28/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-4/</url>
    <content><![CDATA[<blockquote>
<p>这次比赛有两道crypto，都是ECC相关的，第一道由于之前不了解Demytko体系，比赛期间并未找到paper，未能作出，赛后看了7feilee师傅发的paper才复现出来，第二题倒比较简单，分析出曲线的表达式然后发现在模N上是线性的即可解出。</p>
</blockquote>
<h3 id="old-curse">Old Curse</h3>
<p>这题使用的攻击方式是这篇<a href="https://eprint.iacr.org/2019/1050.pdf">paper</a>里的攻击，本质就是对于e，N满足一个关系式和bound下的多元Copper Smith，多元Copper Smith的内容我之后专门单独写一篇，这里就不详述了，关系式和bound的定义如下</p>
<p><img src="/2021/01/28/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-4/image-20210129181352891.png"></p>
<p>具体构造多项式的方法为（也是比较标准的xz-shift，yz-shift）：</p>
<p><img src="/2021/01/28/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-4/image-20210129181428935.png"></p>
<p>规约完之后，取1，2，3行的多项式构成的理想，求Grobner Basis，再解方程即可求解，这里我还专门去学了一波Grobner Basis，然而事实上这题根本不需要，直接联立解这三个多项式即可得到解。</p>
<p><img src="/2021/01/28/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-4/image-20210129181631509.png"></p>
<p>这样得到的解是<span class="math inline">\((p-s)*(q-r)\)</span>，而通过ecm分解，可以得到其完整的素数分解，这样只需要遍历组合，即可得到<span class="math inline">\(p-s\)</span>，然后再结合partial p的单元Copper Smith即可求解，需要注意的是，这题的数据卡的很死（看到7feilee师傅的epsilon是0.01，但我降到0.007才有解orz），small_roots需要调参的同时猜测下一个字母是什么。因为通过得到<span class="math inline">\(p-s\)</span>，已经可以获知部分flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b&#x27;Congratulations!Here is the flag:rwctf&#123;tH3_CursE_h4S_bR0KEn_o1GIe\xb8\xc2T\xed\xd2&#125;\xd1\xc9m\x8a\xdfE\xb0K[\x84\x93\xc9X9\xdb\x14p\x98\xce\x85=fD\x8e\x0c\xeb&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后考虑olgie开头的字母，题给描述里有一个人名‘Olgierd’，故考虑下一个字母是r，于是猜测‘r’, ‘R’, ‘3’三种情况，逐个爆破即可通过partial p解出p，然后异或即得到flag，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto_tools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_overview</span>(<span class="params">BB</span>):</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        a = (<span class="string">&#x27;%02d &#x27;</span> % ii)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(BB.dimensions()[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> BB[ii,jj] == <span class="number">0</span>:</span><br><span class="line">                a += <span class="string">&#x27; &#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a += <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:</span><br><span class="line">                a += <span class="string">&#x27; &#x27;</span></span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lattice_attack</span>(<span class="params">pol, e, X, Y, Z, mm, tt</span>):</span></span><br><span class="line">    polys = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># G</span></span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> range(mm + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i1 <span class="keyword">in</span> range(kk, mm + <span class="number">1</span>):</span><br><span class="line">            i3 = mm - i1</span><br><span class="line">            poly = x ^ (i1 - kk) * z ^ i3 * pol ^ kk * e ^ (mm - kk)</span><br><span class="line">            polys.append(poly)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># H</span></span><br><span class="line">    <span class="keyword">for</span> kk <span class="keyword">in</span> range(mm + <span class="number">1</span>):</span><br><span class="line">        i1 = kk</span><br><span class="line">        <span class="keyword">for</span> i2 <span class="keyword">in</span> range(kk + <span class="number">1</span>, i1 + tt + <span class="number">1</span>):</span><br><span class="line">            i3 = mm - i1</span><br><span class="line">            poly = y ^ (i2 - kk) * z ^ i3 * pol ^ kk * e ^ (mm - kk)</span><br><span class="line">            polys.append(poly)</span><br><span class="line"></span><br><span class="line">    polys.sort()</span><br><span class="line">    monomials = []</span><br><span class="line">    <span class="keyword">for</span> poly <span class="keyword">in</span> polys:</span><br><span class="line">        monomials += poly.monomials()</span><br><span class="line"></span><br><span class="line">    monomials = sorted(set(monomials))</span><br><span class="line">    dims1 = len(polys)</span><br><span class="line">    dims2 = len(monomials)</span><br><span class="line">    M = matrix(QQ, dims1, dims2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(dims1):</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(dims2):</span><br><span class="line">            <span class="keyword">if</span> monomials[jj] <span class="keyword">in</span> polys[ii].monomials():</span><br><span class="line">                M[ii, jj] = polys[ii](x * X, y * Y, z * Z).monomial_coefficient(monomials[jj])</span><br><span class="line"></span><br><span class="line">    matrix_overview(M)</span><br><span class="line">    print(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;bound check:&#x27;</span>, abs(M.det()) &lt; e ^ (dims1 * mm))</span><br><span class="line">    print(int(M.det()).bit_length(), int(e ^ (dims1 * mm)).bit_length())</span><br><span class="line"></span><br><span class="line">    BB = M.LLL()</span><br><span class="line">    print(<span class="string">&#x27;LLL done&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line">    matrix_overview(BB)</span><br><span class="line">    print(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line">    H = [(i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(dims1)]</span><br><span class="line">    H = dict(H)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(dims2):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dims1):</span><br><span class="line">            H[i] += PR((monomials[j] * BB[i, j]) / monomials[j](X, Y, Z))</span><br><span class="line"></span><br><span class="line">    H = list(H.values())</span><br><span class="line">    PQ = PolynomialRing(ZZ, <span class="string">&#x27;xq, yq, zq&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dims1):</span><br><span class="line">        H[i] = PQ(H[i])</span><br><span class="line"></span><br><span class="line">    xv, yv, zv = var(<span class="string">&quot;xq,yq,zq&quot;</span>)</span><br><span class="line">    print(solve([h_i(xv, yv, zv) <span class="keyword">for</span> h_i <span class="keyword">in</span> H[<span class="number">1</span>:<span class="number">4</span>]], xv, yv, zv))</span><br><span class="line">    print(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">80330528881183983072964816732300543404856810562533626369319300810697262966387144944887576330528743612839739692299784591097332512948890518183519167192046959230085412831864255497489112175176914874596237618253755256608956517757030073479666104923402013469283716999320744856718736837534911809839541660207743594867</span></span><br><span class="line">e = <span class="number">78452652317506438607956636739779994986676384637399723342738736371812868831141251164966879331214017314432739387076791674001159059604426825547538902010774841189596518785149221523738464397224366361779781148300651051284198636694801404816891957209985325619623109930150535820404950711233032177848101830061155574970</span></span><br><span class="line"></span><br><span class="line">PR = PolynomialRing(ZZ, <span class="string">&#x27;x, y, z&#x27;</span>)</span><br><span class="line">x, y, z = PR.gens()</span><br><span class="line"></span><br><span class="line">alpha = <span class="number">0.25</span></span><br><span class="line">gamma = <span class="number">0.15</span></span><br><span class="line">delta = <span class="number">0.15</span></span><br><span class="line">beta = log2(e) / log2(N)</span><br><span class="line"></span><br><span class="line">X = floor(<span class="number">4</span> * N ^ (beta + delta - <span class="number">1</span>))</span><br><span class="line">Y = floor(<span class="number">3</span> * sqrt(<span class="number">2</span>) * N ^ (<span class="number">0.5</span> + alpha))</span><br><span class="line">Z = floor(N ^ gamma)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Target polynomial</span></span><br><span class="line">pol = x * y - N * x + z</span><br><span class="line">mm = <span class="number">3</span></span><br><span class="line">tt = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">lattice_attack(pol, e, X, Y, Z, mm, tt)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">[xq == r1, yq == r2, zq == -r1*r2 + 4298479533919222051278424008577823787364263332580438512213525069157290784423146604914451469507153913893839652272765256923591944212821123404914813182473920184304071161320177981959839398079746158378586359732136948418875022137978872858278664265291581144582621441419/3602343035298837553927542062227*r1],</span></span><br><span class="line"><span class="string">[xq == 0, yq == r3, zq == 0],</span></span><br><span class="line"><span class="string">[xq == r4, yq == (4298479533919222051278424008577823787364263332580438512213525069157290784423146604914451469507153913893839652272765256923591944212821123404914813182473920184304071161320177981959839398079746158378586359732136948418875022137978872858278664265291581144582621441419/3602343035298837553927542062227), zq == 0]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">y = <span class="number">4298479533919222051278424008577823787364263332580438512213525069157290784423146604914451469507153913893839652272765256923591944212821123404914813182473920184304071161320177981959839398079746158378586359732136948418875022137978872858278664265291581144582621441419</span>//<span class="number">3602343035298837553927542062227</span> + <span class="number">1</span></span><br><span class="line">x, z = var(<span class="string">&#x27;x, z&#x27;</span>, domain=ZZ)</span><br><span class="line"></span><br><span class="line">k1 = <span class="number">3602343035298837553927542062227</span></span><br><span class="line">k2 = <span class="number">4298479533919222051278424008577823787364263332580438512213525069157290784423146604914451469507153913893839652272765256923591944212821123404914813182473920184304071161320177981959839398079746158378586359732136948418875022137978872858278664265291581144582621441419</span></span><br><span class="line"></span><br><span class="line">res = solve([z * k1 == -k1*x*y + k2*x], x, z)</span><br><span class="line">print(res)</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">x = Integer(res[<span class="number">0</span>].coefficients()[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">z = Integer(res[<span class="number">1</span>].coefficients()[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> (x * y - N * x + z) % e == <span class="number">0</span></span><br><span class="line">u = (x * y - N * x + z) // e</span><br><span class="line">v = x</span><br><span class="line">w = -z</span><br><span class="line"></span><br><span class="line">p_s_q_r = N - y</span><br><span class="line">print(<span class="string">&#x27;(p-s)(q-r) =&#x27;</span>, p_s_q_r)</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">3885193323999136856039629631403237736159969409639584250551518536355997978891524564035346751225719460630697433654700022473218421095180111760606245394708999</span></span><br><span class="line">b = <span class="number">944838399254930087523310357339939742097556483183482662977225295067404254966876247970295271959280809100126064366722912020666848894003017117276240476372364</span></span><br><span class="line">E = EllipticCurve(Zmod(N), [a, b])</span><br><span class="line">stone = E(<span class="number">5316297494616251967087180573684467112077977207314228196651011473838683480275875989908990738740861375687186766156200219641981169308660139151062711296717379891376294785675104640775506724244803337279235747630215478504380272738204733311972022712834357078381541224632797503360732934454187646031643331529389570159</span>, <span class="number">73177062713968648963738410812785853174528721431172461113561340178691492280271903912043554814810920745154304747328073913103230849027745226637330284520633847773874342467137552022725301429074046921710660867115557994943332628756632246059800601063580017261698262663178072317324978782579376388601713100806653808812</span>)</span><br><span class="line"></span><br><span class="line">d = inverse(e, p_s_q_r)</span><br><span class="line">heart = d * stone</span><br><span class="line"></span><br><span class="line">factors_list = [</span><br><span class="line">    <span class="number">11</span>,</span><br><span class="line">    <span class="number">13</span>,</span><br><span class="line">    <span class="number">131</span>,</span><br><span class="line">    <span class="number">131</span>,</span><br><span class="line">    <span class="number">227</span>,</span><br><span class="line">    <span class="number">251</span>,</span><br><span class="line">    <span class="number">251</span>,</span><br><span class="line">    <span class="number">831396757</span>,</span><br><span class="line">    <span class="number">1108897087</span>,</span><br><span class="line">    <span class="number">2178767881</span>,</span><br><span class="line">    <span class="number">2253769513</span>,</span><br><span class="line">    <span class="number">2698180579</span>,</span><br><span class="line">    <span class="number">3504974177</span>,</span><br><span class="line">    <span class="number">3752390129</span>,</span><br><span class="line">    <span class="number">3787135097</span>,</span><br><span class="line">    <span class="number">4166580373</span>,</span><br><span class="line">    <span class="number">4192312919</span>,</span><br><span class="line">    <span class="number">505386797752007</span>,</span><br><span class="line">    <span class="number">15743834086867007131</span>,</span><br><span class="line">    <span class="number">14842292277078537617</span>,</span><br><span class="line">    <span class="number">15114820929537893567</span></span><br><span class="line"> ]</span><br><span class="line"></span><br><span class="line">base = <span class="number">120659691081137900860528439558149439256036479214584879088476613192185895986414329679519081477454257879221194033908435726005914629</span></span><br><span class="line"><span class="keyword">assert</span> isPrime(base) == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> base * prod(factors_list) == p_s_q_r</span><br><span class="line">cipher = int(heart[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">P.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> tqdm(range(<span class="number">2</span>, <span class="number">12</span>)):</span><br><span class="line">    candidate = list(combinations(factors_list, num))</span><br><span class="line">    <span class="keyword">for</span> tmp_factors <span class="keyword">in</span> candidate:</span><br><span class="line">        tmp_pro = prod(tmp_factors) * base</span><br><span class="line">        <span class="keyword">if</span> <span class="number">510</span> &lt; int(tmp_pro).bit_length() &lt; <span class="number">513</span>:</span><br><span class="line">            <span class="keyword">for</span> padding_bits <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">264</span>, <span class="number">8</span>):</span><br><span class="line">                p_r = p_s_q_r//tmp_pro</span><br><span class="line">                <span class="keyword">if</span> <span class="string">b&#x27;rwctf&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> long_to_bytes(p_r ^^ (cipher&gt;&gt;padding_bits)):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">&#x27;Found the p-r:&#x27;</span>, p_r)</span><br><span class="line">                    print(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line">                    print(<span class="string">&#x27;part flag:&#x27;</span>, long_to_bytes(p_r ^^ (cipher&gt;&gt;padding_bits)))</span><br><span class="line">                    k = <span class="number">512</span> - len(<span class="string">&#x27;rwctf&#123;tH3_CursE_h4S_bR0KEn_o1GIe&#x27;</span>) * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">                    print(<span class="string">&#x27;random padding bits:&#x27;</span>, k)</span><br><span class="line">                    print(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line">                    <span class="keyword">for</span> guess <span class="keyword">in</span> tqdm([ord(<span class="string">&#x27;R&#x27;</span>), ord(<span class="string">&#x27;r&#x27;</span>), ord(<span class="string">&#x27;3&#x27;</span>)]):</span><br><span class="line">                        p_high = ((p_r &gt;&gt; k) &lt;&lt; k) + ((guess ^^ <span class="number">0xb8</span> ^^ <span class="number">0x86</span>)&lt;&lt;(k<span class="number">-8</span>))</span><br><span class="line">                        f = p_high + x</span><br><span class="line">                        res = f.monic().small_roots(X=<span class="number">2</span> ^ (k<span class="number">-5</span>), beta=<span class="number">0.45</span>, epsilon=<span class="number">0.007</span>)</span><br><span class="line">                        <span class="keyword">if</span> len(res) &gt; <span class="number">0</span>:</span><br><span class="line">                            print(<span class="string">&#x27;found the result:&#x27;</span>, res)</span><br><span class="line">                            p = p_high + int(res[<span class="number">0</span>])</span><br><span class="line">                            q = N // p</span><br><span class="line">                            <span class="keyword">assert</span> N == p * q</span><br><span class="line">                            print(long_to_bytes((cipher &gt;&gt; padding_bits) ^^ p))</span><br><span class="line">                            sys.exit()</span><br></pre></td></tr></table></figure>
<p>最终跑个7，8min，得到flag</p>
<p><img src="/2021/01/28/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-4/image-20210129182800626.png"></p>
<h3 id="homebrewed-curve">Homebrewed Curve</h3>
<p>这里我是直接参考的Introduction to mathematical cryptography这本书里关于ECC的部分</p>
<p><img src="/2021/01/28/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-4/image-20210129182607011.png"></p>
<p><img src="/2021/01/28/%E6%9D%82%E9%A2%98%E9%97%B2%E8%AE%B0-4/image-20210129182618761.png"></p>
<p>结合标准ECC的公式推导证明，意识到<span class="math inline">\(\lambda\)</span> 在点不同时表示的是两点间的斜率，相同时是该点切线的斜率，也即是曲线的导数，发现题给的公式里是<span class="math inline">\(2ax + b\)</span>，故猜测曲线公式应为<span class="math inline">\(y = ax^2 + bx + c\)</span>，同样使用原始ECC的证明方法，代入，即有<span class="math inline">\(\lambda X+v - (aX^2 + bX + c) = (X-x_3)(X-x_0)\)</span>，其中<span class="math inline">\(x_0\)</span>即为单位元点的x坐标，发现自洽，故确定了表达式。</p>
<p>又已知四个合法点，A，B，G，O，故做差求gcd即可得到P，得到P之后分析整个加法规则，可以发现<span class="math inline">\(x_3 = x_1 + x_2 - x_0\)</span>，故<span class="math inline">\((kG)_x = k(G_x) - (k-1)x_0\)</span>，即在模上满足线性关系，于是消去乘逆即可恢复，完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> invmod</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Curve</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, **kwargs</span>):</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, p1, p2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> p1 == self.zero:</span><br><span class="line">            <span class="keyword">return</span> p2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p2 == self.zero:</span><br><span class="line">            <span class="keyword">return</span> p1</span><br><span class="line"></span><br><span class="line">        x1, y1 = p1</span><br><span class="line">        x2, y2 = p2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x1 != x2:</span><br><span class="line">            l = (y2 - y1) * invmod(x2 - x1, P)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = <span class="number">2</span> * self.a * x1 + self.b</span><br><span class="line"></span><br><span class="line">        x = ((l - self.b) * invmod(self.a, P) - self.zero[<span class="number">0</span>]) % P</span><br><span class="line">        y = ((x - self.zero[<span class="number">0</span>]) * l + self.zero[<span class="number">1</span>]) % P</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">self, p1, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> p1 == self.zero:</span><br><span class="line">            <span class="keyword">return</span> self.zero</span><br><span class="line"></span><br><span class="line">        res = self.zero</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                res = self.add(res, p1)</span><br><span class="line">            p1 = self.add(p1, p1)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_key</span>(<span class="params">self</span>):</span></span><br><span class="line">        sk = random.randint(<span class="number">1</span>, P)</span><br><span class="line">        pk = self.mul(self.gen, sk)</span><br><span class="line">        <span class="keyword">return</span> sk, pk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">338105350242668308929697763396044301660</span></span><br><span class="line">b = <span class="number">70631159681042046635446173236982478064116538177970218795092411634131296885767</span></span><br><span class="line">O = (</span><br><span class="line"><span class="number">9754705134713370500425418962906364916694128219443986534870265438313712052553913556304578048773182865236181393234774811636563665254738358548547686098321918938336999994543320310489785839068889289585561389237322554300534800377365494547910434446171077511660646734142974631896227159038644834795595939445003783184271907835168083982210804135992472981458997056367475361358045062954295385753362817510369968941277639065938619221482008127361125972584968230982231483416783792258479416113581249377750311129019561848383083514672254514692875070293706012921153875918378772956871354902564753931679232128607231527456371560574893648150</span>,</span><br><span class="line"><span class="number">1568631189076775839914050721386821274436631828518639911590203429753674249963724465949098434816249858592209181914562366684848647341809527620103035336678319490054708958682690371323396425059326761139960520329829342510826324634871361342587962617109233961205192373716747727013613655062002124851676969800006190929713777159839273173689438005523473921392011053323705509027606365967531781465002057406686284573053674133382181877418753925610208463393821516137543581472014268533517599374830226690216017114664929426655189944119312800402788151756994817725042844409983509754618168400455155658767237036605650525875166823462486072842</span>)</span><br><span class="line"></span><br><span class="line">G = (</span><br><span class="line"><span class="number">12532998589621080097666945122441206260965625062664570083674602252675892295679594034580389931735096079697125441246960301905307858329289188790029626634485829771734823159182904621402737540757430079518142479215838577833498703259391220160619426650385355407344355318793784733990238754982178179201863773450543367485332580658467529082154218982726945799974265641603861234501912638573835723384717842487988638277214429988591192513007462677389252245306874828268739787612245357189986581131725474432904172834643657027954405787429995826738074015516166702962206858859896933459093477305874443350335332968385035927605359630747331204285</span>,</span><br><span class="line"><span class="number">9677982578222119974363478748399786948047636069661692206522662047830643067492306311529114015320387572903840619331518584584400368845497864412752196098241604714699115186432809693851692194762433385961429711487895639093866274072187416400859677893102613898063134064507994013600600120524875666883108971040402000931357050726739367647257578379098507781478457700720118945453670136245178829199722575486626106268256525611370267664890630521019846806960099333376121482220389744953231843397729642415527736926160072478730239575933321480584291410141867063436921546657245313608614224909988684794138541856898030369431518091733072867437</span>)</span><br><span class="line"></span><br><span class="line">A = (</span><br><span class="line"><span class="number">13487441097225225851381503721250882201348230291456769111220742564976603915541284733903445742010369949564133835184041848270925618065093927905336977954164490448790585095635629931682025014174873840946833423568776772534204109608898522472240761836716148677237778503440395160725865443571787537094238702604760374819569040510617361718394064021678094989416987996196517169045682067813960280671702291412278502544773112916378850480939772300572998243270196397238062178930871026435948325839912933370726600147757455774532767943291746849500590032985576917021393256167765909741347168603316800970606576192321995775188693736786445970160</span>,</span><br><span class="line"><span class="number">6017599616030668129613886703128129222334636061709939196813507723707943475088184604346025813500691639135280058944967720252980654491495661264318199620883475540203205404460632231139796107580037387665375828311005986158345466234113715267437612091657183380072338306002369357139146048822354864239891700619714889347124655297444781747932429314301652892318820172915980583258019186234125036141716353634569644160769758113796289362452914192384749373824618193948698071662955348463507865825856345882176096759589399552633775680285990970529819948425052395988810137569926613717988817522119415329098727602713461364878132364924903122354</span>)</span><br><span class="line">B = (</span><br><span class="line"><span class="number">12325243140409509948390016947224835770037275709809199983863357504628092935405755615708471085146623088629930125222768275569249161772533262995997384602018963893791998430652960945216562316807507576074802113883850941124224565729858452198366295197883539144659809879585978117675682586217166877317417820588576087650344398633914868028869563804325425499084148917013752420468723286815504458371864930365680607878997170362726942929241087236675902387482097261010616327896296714705736419010609802542459944267215680522857179358080459237676786115966499799125501709118451402926712061906091422526053306629229053727883903005288795696508</span>,</span><br><span class="line"><span class="number">11505268856676087471457416848355426459576355205947042999067185842545620763588462278320812379117467263916383145249098261720386127003988544590766801168503624732272757534718035824926881081717465079216152838849559029603087971046414561166054241351336879142412362035493311540826692018441037485743070162688102587726966007813519178658355297714620527127226989353344537573502931404623687629851431286618067819135715913162892925109669537524861927815259765868576488623808219606831381696710149107337624587114848589866865509992514440834069577162069420625328534884840613305250527515798029474049312705531575693278171514006918716216130</span>)</span><br><span class="line"></span><br><span class="line">cipher = <span class="number">0x1c002f8ecfa9177ffed879245681dbb606ed194f319c12a0a0940c7193e490095e9915d9ce9252f8377def6a92bcab6a</span></span><br><span class="line">cipher = long_to_bytes(cipher)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># y = a*x^2 + b*x + c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curve_f</span>(<span class="params">point</span>):</span></span><br><span class="line">    x, y = point</span><br><span class="line">    f = a * (x ** <span class="number">2</span>) + b * x - y</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;tmp1 = a * (A[0]**2 - B[0]**2) + b*(A[0]-B[0])</span></span><br><span class="line"><span class="string">tmp2 = A[1] - B[1]</span></span><br><span class="line"><span class="string">t1 = tmp1 - tmp2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tmp1 = a * (G[0]**2 - O[0]**2) + b*(G[0]-O[0])</span></span><br><span class="line"><span class="string">tmp2 = G[1] - O[1]</span></span><br><span class="line"><span class="string">t2 = tmp1 - tmp2</span></span><br><span class="line"><span class="string">P = gcd(t1, t2)&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">P = <span class="number">16964155551072495694293641975607630224727620299506094680698561697517114055981456463802735036670824528486635128253757386796419676408241481233714972382812783160754601985902695360703612064223677630625126592834772106201583720344150312382723959316671117708799304253580291408927697557459674805267132980104779404642276846095233729275890317878916892907703929715499923974553217760175425647369679697361138159243363407958468903965694813367459663590914481184614924748816307473556323329341018650081832249242635801731713869201574073433674020290004290751530577883843107369211669006291178070342858539229191025760918841972906522445981</span></span><br><span class="line"><span class="keyword">assert</span> isPrime(P)</span><br><span class="line">c = <span class="number">16964155551072495694293641975607630224727620299506094680698561697517114055981456463802735036670824528486635128253757386796419676408241481233714972382812783160754601985902695360703612064223677630625126592834772106201583720344150312382723959316671117708799304253580291408927697557459674805267132980104779404642230883341990354632152767094707323928211372322526675151193625579132448090680173107503198477462468656666566735425940700529384596061331818284884112463944986343599664280680261379848261768748456401895568843612967863345586540761447983568059191185623814855161140280703730793084066810882147924523685770382826268634431</span></span><br><span class="line"><span class="keyword">assert</span> (curve_f(A) - c) % P == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">curve = Curve(</span><br><span class="line">    a=<span class="number">338105350242668308929697763396044301660</span>,</span><br><span class="line">    b=<span class="number">70631159681042046635446173236982478064116538177970218795092411634131296885767</span>,</span><br><span class="line">    zero=(</span><br><span class="line">        <span class="number">9754705134713370500425418962906364916694128219443986534870265438313712052553913556304578048773182865236181393234774811636563665254738358548547686098321918938336999994543320310489785839068889289585561389237322554300534800377365494547910434446171077511660646734142974631896227159038644834795595939445003783184271907835168083982210804135992472981458997056367475361358045062954295385753362817510369968941277639065938619221482008127361125972584968230982231483416783792258479416113581249377750311129019561848383083514672254514692875070293706012921153875918378772956871354902564753931679232128607231527456371560574893648150</span>,</span><br><span class="line">        <span class="number">1568631189076775839914050721386821274436631828518639911590203429753674249963724465949098434816249858592209181914562366684848647341809527620103035336678319490054708958682690371323396425059326761139960520329829342510826324634871361342587962617109233961205192373716747727013613655062002124851676969800006190929713777159839273173689438005523473921392011053323705509027606365967531781465002057406686284573053674133382181877418753925610208463393821516137543581472014268533517599374830226690216017114664929426655189944119312800402788151756994817725042844409983509754618168400455155658767237036605650525875166823462486072842</span>),</span><br><span class="line">    gen=(</span><br><span class="line">        <span class="number">12532998589621080097666945122441206260965625062664570083674602252675892295679594034580389931735096079697125441246960301905307858329289188790029626634485829771734823159182904621402737540757430079518142479215838577833498703259391220160619426650385355407344355318793784733990238754982178179201863773450543367485332580658467529082154218982726945799974265641603861234501912638573835723384717842487988638277214429988591192513007462677389252245306874828268739787612245357189986581131725474432904172834643657027954405787429995826738074015516166702962206858859896933459093477305874443350335332968385035927605359630747331204285</span>,</span><br><span class="line">        <span class="number">9677982578222119974363478748399786948047636069661692206522662047830643067492306311529114015320387572903840619331518584584400368845497864412752196098241604714699115186432809693851692194762433385961429711487895639093866274072187416400859677893102613898063134064507994013600600120524875666883108971040402000931357050726739367647257578379098507781478457700720118945453670136245178829199722575486626106268256525611370267664890630521019846806960099333376121482220389744953231843397729642415527736926160072478730239575933321480584291410141867063436921546657245313608614224909988684794138541856898030369431518091733072867437</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> curve.mul(curve.gen, P) == curve.zero</span><br><span class="line"></span><br><span class="line"><span class="comment"># kGx - (k-1)*Ox</span></span><br><span class="line">ck, C = curve.gen_key()</span><br><span class="line"><span class="keyword">assert</span> (ck * G[<span class="number">0</span>] - (ck - <span class="number">1</span>) * (O[<span class="number">0</span>])) % P == C[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">bk = ((B[<span class="number">0</span>] - O[<span class="number">0</span>]) * inverse(G[<span class="number">0</span>] - O[<span class="number">0</span>], P)) % P</span><br><span class="line">shared = curve.mul(A, bk)[<span class="number">0</span>]</span><br><span class="line">key = hashlib.sha256(long_to_bytes(shared)).digest()</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">print(aes.decrypt(cipher))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Crypto in CTF</category>
      </categories>
      <tags>
        <tag>Crypto in CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Way to Crypto</title>
    <url>/2020/07/06/Way-to-Crypto/</url>
    <content><![CDATA[<h3 id="pre-algorithm">Pre Algorithm</h3>
<p><a href="https://introspelliam.github.io/2018/03/26/crypto/常用于密码学中的算法/">link1</a></p>
<p><a href="https://www.cnblogs.com/jcchan/p/8426731.html">link2</a></p>
<p>tips1:注意BSGS算法的局限性，即<span class="math inline">\(gcd(a,p) = 1\)</span> ，条件不成立时，需使用<a href="http://kmanong.top/kmn/qxw/form/article?id=24946&amp;cate=136">扩展BSGS</a>或其他算法。</p>
<p>tips2:Linux下分解工具 <a href="https://pypi.org/project/primefac/">primefac</a></p>
<p>tips3:推荐使用工具sage，需在linux下配置，其包含了很多库和函数，如cypari2等，<a href="https://doc.sagemath.org/html/en/reference/search.html">sage官方文档</a>，<a href="https://cypari2.readthedocs.io/en/latest/pari_instance.html">cypari2官方文档</a></p>
<h3 id="rsa">RSA</h3>
<p><a href="https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/">淘宝师傅博客</a>，总结的很好，可以当作索引来学习。</p>
<p>虽然说是RSA，但其实涵盖了有限域上的离散对数密码体系和大整数分解密码体系的知识，只是这些知识可以较好的通过RSA这个模板呈现出来。</p>
<h5 id="givenedn">Given(e,d,n)</h5>
<p><img src="/2020/07/06/Way-to-Crypto/way_to_crypto_3.png"></p>
<p>tips：博客内给出的NCTF2019 babyRSA其实并不是这种情况，而是利用p，q接近，开根phi求解的。</p>
<h5 id="given-p-q-dp-dq">Given (p, q, dp, dq)</h5>
<p>tips:博客给出的证明其实就是CRT的证明</p>
<h5 id="wiener-attack">Wiener Attack</h5>
<p>tips1：博客中给的证明开始的一步有问题，可以结合<a href="%5Bhttps://muzibing.github.io/2019/05/07/2019.05.07%EF%BC%8852%EF%BC%89/%5D(https://muzibing.github.io/2019/05/07/2019.05.07（52）/)">此篇文章</a>一起看，本质上其实就是利用了连分数的最佳逼近性质和的d较小的漏洞。</p>
<p>tips2：题中的rational_to_quotients函数即是计算连分数中的数列，原理比较简单，自行推导即可。convergents_from_quotients函数是用来计算每一级连分数的，即最佳逼近。</p>
<h5 id="coppersmith-常见相关攻击">Coppersmith 常见相关攻击</h5>
<p>tips1：此部分推荐先把wiki部分内容看过一遍再做扩展，可以配合github上的这个<a href="https://github.com/mimoo/RSA-and-LLL-attacks">项目理解</a>，此处方法不理解的地方，建议多打打草稿，画一画就懂了，每种情况都可以切实code一下，至于根本原理，个人觉得不一定非要十分清楚，会意即可，感兴趣的可以参见<a href="https://paper.seebug.org/727/#41-coppersmith">此篇文章</a>。</p>
<p>一定要搞清楚small_roots函数（sage的small_root传参X不能过大，如果X过大，即使存在X内的解，也无法求出）：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200721114137102.png"></p>
<p>下面贴出测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">base = <span class="number">512</span></span><br><span class="line">p = random_prime(<span class="number">2</span>^base, <span class="number">2</span>^(base<span class="number">-1</span>))</span><br><span class="line">q = random_prime(<span class="number">2</span>^base, <span class="number">2</span>^(base<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">e = random_prime(<span class="number">2</span>^<span class="number">6</span>, <span class="number">2</span>^<span class="number">4</span>)				<span class="comment"># for test partial d</span></span><br><span class="line"><span class="comment"># e = random_prime(2^25, 2^23)  			# for test partial p </span></span><br><span class="line"><span class="comment"># e = 7							# for test partial m </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(gcd(e, p<span class="number">-1</span>) ==<span class="number">1</span> <span class="keyword">and</span> gcd(e, q<span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line">m = bytes_to_long(<span class="string">b&#x27;flag&#123;Test_flag_for_LordRiot&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;p = &#x27;</span> + str(p))</span><br><span class="line">print(<span class="string">&#x27;q = &#x27;</span> + str(q))</span><br><span class="line">print(<span class="string">&#x27;n = &#x27;</span> + str(n))</span><br><span class="line">print(<span class="string">&#x27;e = &#x27;</span> + str(e))</span><br><span class="line">print(<span class="string">&#x27;c = &#x27;</span> + str(c))</span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># this situation should use with a small e</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_m</span>(<span class="params">k1, k2</span>):</span></span><br><span class="line">	m_high = (m &gt;&gt; (k1+k2)) &lt;&lt; (k1+k2)</span><br><span class="line">	m_low = m &amp; (<span class="number">2</span> ^ (k2+<span class="number">1</span>) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	wait = (m - m_high - m_low) &gt;&gt; k1</span><br><span class="line">	<span class="keyword">assert</span>(m_high + wait  * <span class="number">2</span> ^ k1 + m_low == m)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">assert</span>(wait &lt; n ^ (<span class="number">1</span>/e))</span><br><span class="line"></span><br><span class="line">	f = (m_high + m_low + x * <span class="number">2</span> ^ k1) ^ e - c</span><br><span class="line">	solve = f.monic().small_roots(X=<span class="number">2</span>^k1, beta=<span class="number">1</span>)</span><br><span class="line">	x0 = solve[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	print(long_to_bytes(m_high + x0 * <span class="number">2</span> ^ k1 + m_low))</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_p</span>(<span class="params">low_bit, leak_bits, phar=<span class="number">0</span>, _beta=<span class="number">0.4</span>, test=False</span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> low_bit:		</span><br><span class="line">		<span class="keyword">if</span> test:</span><br><span class="line">			phar = p &amp; (<span class="number">2</span> ^ (leak_bits+<span class="number">1</span>) - <span class="number">1</span>)	</span><br><span class="line">		<span class="keyword">assert</span>((p - phar) &gt;&gt; leak_bits &lt;= <span class="number">2</span> * n ^(<span class="number">1</span>/<span class="number">4</span>))					</span><br><span class="line">		f = x * <span class="number">2</span> ^ leak_bits + phar		</span><br><span class="line">		solve = f.monic().small_roots(X=<span class="number">2</span>^(base - leak_bits), beta=_beta)</span><br><span class="line">	<span class="keyword">else</span>:	</span><br><span class="line">		<span class="keyword">if</span> test:					</span><br><span class="line">			phar = (p &lt;&lt; leak_bits) &gt;&gt; leak_bits						</span><br><span class="line">		<span class="keyword">assert</span>(p - phar &lt;= <span class="number">2</span> * n ^(<span class="number">1</span>/<span class="number">4</span>))</span><br><span class="line">		f = x + phar</span><br><span class="line">		solve = f.monic().small_roots(X=<span class="number">2</span>^leak_bits, beta=_beta)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	x0 = solve[<span class="number">0</span>]</span><br><span class="line">	p_solve = int(x0 * <span class="number">2</span> ^ leak_bits + phar)</span><br><span class="line">	q_solve = n//p_solve</span><br><span class="line">	print(p_solve * q_solve == n)</span><br><span class="line"></span><br><span class="line">	d = inverse(e, (p_solve<span class="number">-1</span>) * (q_solve<span class="number">-1</span>))</span><br><span class="line">	print(long_to_bytes(pow(c, d, n)))</span><br><span class="line">	<span class="keyword">return</span> p_solve</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cause the partial_p function need little k, so we may need to reduce the p0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial_d</span>(<span class="params">k, second_bits = (<span class="params">base * <span class="number">2</span></span>) // <span class="number">6</span> </span>):</span></span><br><span class="line">	<span class="keyword">assert</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">	kbits = k + int(n).bit_length()//<span class="number">4</span></span><br><span class="line">	d = inverse(e, (p<span class="number">-1</span>) * (q<span class="number">-1</span>))</span><br><span class="line">	dhar = d &amp; (<span class="number">2</span> ^ (kbits + <span class="number">1</span>) - <span class="number">1</span>)</span><br><span class="line">	solved = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">	X = var(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">		results = solve_mod([e*dhar*X - k*X*(n-X+<span class="number">1</span>) + k*n == X], <span class="number">2</span>^kbits)</span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">			p0 = int(x[<span class="number">0</span>])</span><br><span class="line">			leak_bits = p0.bit_length()</span><br><span class="line">			<span class="keyword">if</span> p0 == p &amp; (<span class="number">2</span> ^ (leak_bits+<span class="number">1</span>) - <span class="number">1</span>):</span><br><span class="line">				print(<span class="string">&quot;leak p bits: &quot;</span> + str(p0.bit_length()))</span><br><span class="line"></span><br><span class="line">				<span class="keyword">try</span>:		</span><br><span class="line">					p_solve = partial_p(true, p0.bit_length(), phar = p0)</span><br><span class="line">					<span class="keyword">if</span> p == p_solve:</span><br><span class="line">						print(<span class="string">&#x27;Got the solution!&#x27;</span>)</span><br><span class="line">						solved = <span class="literal">True</span></span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">				<span class="keyword">except</span>:</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> solved:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> solved:</span><br><span class="line">		print(<span class="string">&quot;No solution found&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># partial_p(true, 300, test=True)</span></span><br><span class="line"><span class="comment"># partial_m(50, 50)</span></span><br><span class="line"><span class="comment"># partial_d(50)</span></span><br></pre></td></tr></table></figure>
<p>tips2：使用的sage脚本中的small_roots其实即是集成了LLL算法的函数。</p>
<h5 id="e与phi不互素">e与phi不互素</h5>
<p>NCTF 2019 easy-RSA，<a href="http://www.soreatu.com/posts/intended-solution-to-crypto-problems-in-nctf-2019/#easyrsa909pt-2solvers">writeup</a></p>
<p>涉及有限域开高次根问题，值得细看。</p>
<p>（其实RSA算法即可以看作是在求<span class="math inline">\(GF(n)\)</span>下的<span class="math inline">\(e \ th\)</span> root，但<span class="math inline">\(gcd(e, phi) = 1\)</span>。）</p>
<p><a href="https://blog.csdn.net/jcbx_/article/details/105303760">这篇文章</a>讲的挺好，算是汉化并解释了一波论文</p>
<p><strong>AMM（Adleman-Manders-Miller）算法</strong>： （论文中关于推导方面有将q写为p的笔误，需注意）</p>
<p>$for  s * r^t = q-1,  $ 为<span class="math inline">\(\delta \mod q\)</span> 的一个<span class="math inline">\(r\)</span>次非剩余，则有</p>
<p>​ <span class="math inline">\(\delta^\alpha (\rho^s)^{\sum_{i=1}^{t-1}j_i*r^{t-1-i}}\)</span></p>
<p>为<span class="math inline">\(\delta\)</span>的r次剩余。</p>
<p>算法流程：</p>
<p><img src="/2020/07/06/Way-to-Crypto/way_to_crypto_2.png"></p>
<p>至于如何生成所有的r次剩余（即r个r次剩余），则可以通过以下公式：</p>
<p>​ <span class="math inline">\((x^{\frac{q-1}{r}}) ^ r \equiv 1 \pmod q\)</span></p>
<p>在q的剩余系内，取r个不相同的x，则得到r个r次剩余，即全部解：<span class="math inline">\(m_0 * x_i^{\frac{q-1}{r}}, \ i \in (1, 2, \dots, r)\)</span></p>
<h5 id="gcdp-1-q-1过大">gcd(p-1, q-1)过大</h5>
<p>此处关于<span class="math inline">\(x^{N-1} \pmod p\)</span> 最多有a个值，可以从ord考虑将<span class="math inline">\(x^b\)</span>看成一个整体，考虑其阶数为<span class="math inline">\(ord//g\)</span>，可知为原根时，可取到a，非原根时小于a。（本质是判断r次剩余的解有<span class="math inline">\(gcd(n, \phi(n))\)</span>个）</p>
<h5 id="rsa-crt体系攻击">RSA-CRT体系攻击</h5>
<p><a href="http://jianiau.blogspot.com/2014/05/rsa-decrypt-with-crt.html">RSA-CRT介绍</a></p>
<p>使用的LLL掌握矩阵构造即可，具体可以看这篇<a href="https://www.iacr.org/archive/pkc2006/39580001/39580001.pdf">paper</a></p>
<h5 id="copper-smith原理">Copper Smith原理</h5>
<p><em>soreatu师傅总结了一篇Copper Smith的编年的<a href="https://blog.soreatu.com/posts/case-study-coppersmith-related-attack-an-academical-approach/">paper索引</a>， 可以当作paper目录使用</em></p>
<p>Copper Smith 根本思想：</p>
<p>构造某个多项式商环（需要将<span class="math inline">\(GF(n)\)</span>上的多项式转换到<span class="math inline">\(Z\)</span> （实际上可能先是<span class="math inline">\(n^m\)</span>上）上），取其上所有的多项式的系数构造Lattice，之后进行某种初等变换，之后通过对其中某个block matrix（也可能是整体）的规约，得到一组性质好的等价的多项式的系数，从而求解。</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200916164008236.png"></p>
<p>推荐看<a href="https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/survey_final.pdf">这篇survey</a>，对一些概念讲的比较详细，相对于Copper Smith最初的论文更容易理解。</p>
<h6 id="copper-smith基础">Copper Smith基础</h6>
<p>理论基础：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200916162844698.png"></p>
<p>此即Howgrave-Graham定理，证明了构造符合规则的多项式<span class="math inline">\(g(x X)\)</span>后，最终欲求的性质较好的解向量可以通过格基约化找到。</p>
<p>在利用单元变量构造Lattice时，构造规则为：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200916200255569.png"></p>
<p>对于<span class="math inline">\(x^i*p(x)^j\)</span>中的<span class="math inline">\(i, j\)</span>，使用 $(i, j) = h<em>k + i + (j-1) </em> k <span class="math inline">\(， 来计算对应的列坐标，即对于\)</span>p(x), i = 0, j = 1<span class="math inline">\(，此多项式各个参数即在矩阵的第\)</span>(i, j) = h*k$ 列作为矩阵元素，具体的行坐标即为多项式内<span class="math inline">\(x\)</span> 不同指数相对应。</p>
<p>以原论文中第6列为例：</p>
<p><span class="math inline">\(p(x) = x^2 + ax + b\)</span> 对应<span class="math inline">\(h*k = 6\)</span>，观察可发现第六列的元素即为<span class="math inline">\(b, a, 1, 0, 0, 0, 0\)</span>， 即对应<span class="math inline">\(x^0, x^1, x^2, x^3, x^4, x^5\)</span> 的系数。</p>
<p>之后构造向量r，使得<span class="math inline">\(s = r M\)</span>，向量s的右部分全为0。</p>
<p>注意此后的矩阵<span class="math inline">\(\widetilde M\)</span> 为对M矩阵进行初等变换后的矩阵，而矩阵<span class="math inline">\(\hat M\)</span> 为矩阵<span class="math inline">\(\widetilde M\)</span> 左上角<span class="math inline">\(h k \times h k\)</span>的分块矩阵，而由于构造，故有<span class="math inline">\(det(\hat M) = det(\widetilde M) = det(M)\)</span>， 而格基约化的对象为矩阵$det(M) $。</p>
<p>论文的以下部分是在论证欲求的解向量在<span class="math inline">\(\hat M\)</span> 所形成的Lattice上</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200914160137408.png"></p>
<p>以下部分说明了必然存在一个线性组合<span class="math inline">\(f_g\)</span>，使得<span class="math inline">\(\sum_g f_g d_g = 0\)</span>，也就产生了一个格上的short vector，而最终通过LLL约简出的short vector即是<span class="math inline">\(f_g\)</span>， 之后正常解方程即可</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200914170840728.png"></p>
<p>需要注意的是对于不同的多项式，构造矩阵时存在着不同形式的优化，例如sage中集成的small_roots构造的单变量矩阵便与Copper Smith最初论文中的矩阵有所不同。</p>
<p>github的<a href="https://github.com/mimoo/RSA-and-LLL-attacks">这个项目</a>，便使用的是如下构造方法：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200916163818846.png"></p>
<h6 id="copper-smith延申">Copper Smith延申</h6>
<ol type="1">
<li><p>模N未知：</p>
<p>​ 其实最早学习Copper Smith的时候，对于partial_p和partial_d的情况我就很疑惑，不像partial_m，这两种情况似乎并没有给出一个模N上的等式，而事实上，Copper Smith确实是可以作用于不确定的有限域上的。</p>
<p>以partial p情况为例：</p></li>
</ol>
<p><span class="math display">\[
|\hat p - p| &lt; N^{\frac{1}{4}} \\
    \Rightarrow \hat p \equiv x_0 \mod p \\
    \Rightarrow f(x) = \hat p + x \equiv 0 \mod p\\
    known:\hat p, \quad p &gt; N^\beta , \ \beta \in (0, 1] \quad x &lt; X\\
\]</span></p>
<p>我们仍然按照之前的形式构造多项式：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200916163818846.png"></p>
<p>那么第一种多项式在模<span class="math inline">\(p^{m-i} N^i = p^m * q^i\)</span> 上为0，将<span class="math inline">\(q^i\)</span>看作常数，即为在<span class="math inline">\(p^m\)</span>上为0，第二种多项式亦为在模<span class="math inline">\(p^m\)</span> 上位0，符合Howgrave-Graham定理的条件，即可约简出一组较好的基。</p>
<p>而不同之处在于对根范围的计算，需要将<span class="math inline">\(p\)</span> 替换为<span class="math inline">\(N^\beta\)</span>，剩余步骤与已知N情况相同，最终得到约束：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200916193419716.png"></p>
<ol start="2" type="1">
<li><p>多变量情况</p>
<p>先从二元谈起，可以看这篇<a href="https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf">paper</a></p>
<p>​ 讲的很详细，虽然略去了不少证明，但是可以比较直观的认识到多元Copper Smith的本质也是先shift多项式的阶，再使用格基约化将模方程降维，从而更容易的求解，与单变量并没有本质的区别。</p>
<p>​ 多元的构造方法，可以参见这个<a href="https://gist.github.com/jhs7jhs/0c26e83bb37866f5c7c6b8918a854333">多元Copper Smith的脚本</a>，原blog是韩文写的，看着很难受，这里大致阐述一下构造方法，以2变量为例：</p>
<p>solve函数中的参数m代表shift的阶数，t代表初始多项式的阶数，这里使用</p>
<p><span class="math inline">\(p_1 * 2^{k_1} + p_2 *2^{k_2} + p_3*2^{k_3} = p\)</span></p>
<p>​ 已知<span class="math inline">\(p_2, p | N, N\)</span>，求p1，p3，可以看到多项式阶数为1，shift一般可选用变量数乘2，此处为4</p>
<p>​ 最终构造<span class="math inline">\(T\)</span> 个多项式，<span class="math inline">\(T\)</span> 为n个元素，和小于等于m的全排列数量（这点其实可以从n维空间去考虑，即在n维空间构造一个半径为m的球，取其中所有整数点，即返回了T个n维向量，每个向量即为<span class="math inline">\((e_1, e_2, \dots, e_n)\)</span>，其中<span class="math inline">\(e_i\)</span> 即为下式中<span class="math inline">\(e_i\)</span>）</p>
<p>构造n个多项式如下：</p>
<p><span class="math inline">\(g(x) = f(x)^k * \prod_{i = 1}^{n} x_i^{e_i} * N^{max(t-k, 0)}\)</span></p>
<p>以每个多项式中各个变量的系数为矩阵元素，可以看到构造的多项式是在<span class="math inline">\(GF(N^{max(k, t)})\)</span> 上的。</p>
<p>这里为了加深理解，推荐看看<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.40.2636&amp;rep=rep1&amp;type=pdf">这篇论文</a>，即是Boneh and Durfee attack</p>
<p>关于多元Copper的整体结构之后会单独写一篇文章来说。</p></li>
</ol>
<h3 id="lattice">Lattice</h3>
<h4 id="biu-crypto-lattice">2012 Biu Crypto Lattice</h4>
<p>b站有中英翻译视频，直接搜索即可</p>
<p>纠正：</p>
<ol type="1">
<li>Introduction，49：00，所乘幺模矩阵除对角线外应为0，而非1</li>
</ol>
<h5 id="introduction-to-lattice">Introduction to Lattice</h5>
<ol type="1">
<li><p>格基等价条件：</p>
<ol type="1">
<li>换序：<span class="math inline">\(V_i \leftrightarrow V_j\)</span></li>
<li>相反：<span class="math inline">\(-V_i \leftarrow V_i\)</span></li>
<li>齐次：<span class="math inline">\(V_i \leftarrow V_i + kV_j\)</span></li>
</ol>
<p>证明简单，此处略，此三种映射均可使用<a href="%5Bhttps://baike.baidu.com/item/%E5%B9%BA%E6%A8%A1%E7%9F%A9%E9%98%B5%5D(https://baike.baidu.com/item/幺模矩阵)">幺模矩阵</a>（幺模矩阵对乘法和求逆封闭）描述。</p></li>
<li><p>空间映射到格基：</p>
<p>通过规定基础平行多面体：<span class="math inline">\(P(B) = \{a_1x_1,a_2x_2,\dots, a_nx_n | a_i\in[0,1) \}\)</span>，将空间任意点均可映射到此结构中.</p></li>
<li><p>格的行列式定义：</p>
<p><span class="math inline">\(for\ L(B),\ det(L) = det(B) = S_B\)</span></p>
<p>B即为格的一组基，<span class="math inline">\(S_B\)</span>为基础平行多面体的面积，基础平行多面体中有且仅有一个格点，故可用来描述格的密度。</p></li>
<li><p>最短向量<span class="math inline">\(\lambda_1(L)\)</span> （这个定理非常重要，很多时候需要通过其算bound）:</p>
<p>利用正交化求出其下界<span class="math inline">\(min\{\hat{v_i}\}\)</span>，根据Minkowski's Theorem的推论得到上界<span class="math inline">\(n^{\frac{1}{2}} det(L)^{\frac{1}{n}}\)</span></p></li>
</ol>
<h5 id="reduction-for-sis">Reduction for SIS</h5>
<ol type="1">
<li><p>SIS问题：</p>
<p>$for  vectors:  a_1, , a_n, find  z_1, , z_n $</p>
<p><span class="math inline">\(meet: z_1*a_1 + \dots + z_n*a_n = 0 \ | \ z_i \ in\ \{-1, 0, 1\} \  \ \ a_i, z_i \ in\  Z_q^n\)</span></p>
<p><span class="math inline">\(z_i\)</span>的范围越小，越难解出，简单考虑可知整数解集对加法有封闭性，故而构成一个格</p>
<p>（容易想到利用LLL解决背包问题的情况）</p></li>
<li><p>格上的高斯分布：</p>
<ol type="1">
<li><p>对于区域A，若其选点上均匀分布，其Gram-Schmidit正交的基也均匀分布。</p></li>
<li><p>若一个基础平行多面体上均匀分布，则每个格基构成的基础平行多面体选点均均匀分布。 这里的含义是，对于整个<span class="math inline">\(R^n\)</span>空间上的某个高斯分布的点集，在每个满足以上条件之一的区域内均为均匀分布，即选到任何一个点的概率相同。可以结合以下MATLAB代码理解正态分布在一个方差上界下的光滑性：</p></li>
</ol>
<p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ceita = <span class="number">1.25</span>:<span class="number">0.005</span>:<span class="number">1.3</span></span><br><span class="line">    x=<span class="number">0.00</span>:<span class="number">0.01</span>:<span class="number">1.00</span>;</span><br><span class="line">    y = normpdf(x<span class="number">-100</span>,<span class="number">0</span>,ceita)</span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">-100</span>:<span class="number">1</span>:<span class="number">100</span></span><br><span class="line">        y = y + normpdf(x+n,<span class="number">0</span>,ceita);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">figure</span></span><br><span class="line">    <span class="built_in">plot</span>(x,y);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>基于高斯分布的规约算法：</p>
<p>​ 本质即是对于随机的一个格点，以其为高斯分布的原点（即期望），根据设定好的高斯分布在其附近取一点（此处由于格点是离散的，所以存在一个取整处理）。由于基于高斯分布，故所选向量距离原点的距离期望会较小，从而找到一个较小的向量。高斯分布的方差会在限定范围（即上面所提约束条件）内移动，直至找到一个足够短的向量为止，为了找到短的向量，同时满足点的随机性，方差应该较小，但又不能低于某个限度。</p>
<p>​ 讲座中其实已经足够直观了：</p>
<p><img src="/2020/07/06/Way-to-Crypto/way_to_crypto_1.png"></p></li>
</ol>
<h4 id="introduction-to-mathematical-chapter-6">Introduction-to-Mathematical Chapter 6</h4>
<p><em>如果BIU冬令营都听懂了，其实中间（指6.3-6.5）关于格的介绍部分就可以都不看了，直接跳到6.6就行，也可也结合6.5具象化的理解基于高斯分布的规约算法。</em></p>
<h5 id="babais-cvp-solve-algorithm">Babai's CVP solve algorithm</h5>
<p>基于正交基的解决CVP算法，只有基底正交性足够好时，才可以解决CVP问题。</p>
<p>算法过程即是将目标向量表示成正交性好的基底的组合，对系数求最接近取整，得到的向量即为一个与目标向量非常接近的格上向量。</p>
<p>Hadamard's ratio：描述基底正交性的量，越接近于1，正交性越好。</p>
<h5 id="ggh">GGH</h5>
<p>GGH基于了CVP问题，利用Babai's Algorithm来实现，需要在较高维度实现，否则可以使用规约算法（如LLL）找出一组正交性很好的基底。</p>
<h5 id="卷积多项式环">卷积多项式环</h5>
<p>多项式环上的乘积运算，其实可看成级数乘法（梦回史济怀）：</p>
<p><img src="/2020/07/06/Way-to-Crypto/way_to_crypto_4.png"></p>
<p>N控制指数的域，q控制系数的域。</p>
<p>将<span class="math inline">\(R_q\)</span>上环lift到<span class="math inline">\(R\)</span>上环，常采用的方法：将<span class="math inline">\(0, 1, \dots, q-1\)</span>映射到<span class="math inline">\(\lceil-\frac{q}{2}\rceil, \dots, \lceil\frac{q}{2}\rceil\)</span>上。</p>
<h5 id="ntru">NTRU</h5>
<p>NTRU系统本身其实代表着一个较为泛的理念，实现较为简单，且其可以在多个层面实现，多项式/整数等等，可以参见书中描述或<a href="https://blog.csdn.net/sinat_36742186/article/details/83689529">此篇博文</a>，即可以基于多项式，也可也基于整数。</p>
<p>NTRU的q估值问题（根本原因是因为先后所处有限域为p，q，不相同，故而a(x)需要小于q，否则会被截断），由于往往很难达到最大情况，所以其实一般取一个较小q以提高效率，并保证错误率较低即可。</p>
<p>NTRU系统的破解可以从自构造私钥入手，通过推导不难发现，如果找到一组<span class="math inline">\(f(x), g(x)\)</span>，满足<span class="math inline">\(f(x)*h(x) \equiv g(x) \pmod q\)</span>，并且<span class="math inline">\(f(x), g(x)\)</span>的系数较小（为了使<span class="math inline">\(f(x)*m(x) + p * g(x)*r(x)\)</span>较小，不被截断），且在<span class="math inline">\(Z_p\)</span>下可逆，则可以解密，但需要注意的是，碰撞的概率非常小，且得到不是原有私钥簇内元素（即通过乘<span class="math inline">\(x^k, k=1,2,\dots,q-1\)</span>生成的簇）的概率更加小。</p>
<p><em>NTRU系统的安全重点在于前后不同有限域（<span class="math inline">\(G_p, G_q\)</span>），故而需要考虑截断问题</em></p>
<h5 id="格基约化">格基约化</h5>
<ol type="1">
<li><p>二维上的高斯约化：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200712120740513.png"></p>
<p>这样可以求得一组最小且正交性好的基，不过仅适用于二维情况。极小性由<span class="math inline">\(v_1,v_2\)</span>之间大小及系数m保证，正交性由每次的系数m保证，具体证明看书上的即可，写的很详细。</p></li>
<li><p>LLL算法：</p>
<p>通过施密特正交化和condition判断，得到一组正交性好的基，同时其中的最短向量为格上的较短向量，可以解决近似SVP和近似CVP。</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200712174936772.png"></p>
<p>扩展LLL：BKZ-LLL，sage中也有集成:</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用格式如下，L为格矩阵，通常取格维度的1/10左右作为block大小即可</span></span><br><span class="line">L.BKZ(block_size)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h5 id="密码分析中的格基约化">密码分析中的格基约化</h5>
<p>包括NTRU、背包、GGH等问题的格基约化破解，书上例子较为详细，结合习题理解即可。</p>
<h4 id="ctf中遇到的其他格相关问题">CTF中遇到的其他格相关问题</h4>
<h5 id="hnp问题">HNP问题</h5>
<p>可以通过[这篇文章][https://kel.bz/post/hnp/#:~:text=The%20Hidden%20Number%20Problem%20(HNP,compute%20as%20the%20entire%20secret%3F&amp;text=They%20also%20demonstrate%20an%20efficient,a%20significant%20enough%20bit%20leakage.]认识HNP问题，下为简单的测试代码（p需要大于x，但不能超出太多，因为可能会使其本身小于误差值的绝对值）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msb_oracle</span>(<span class="params">x, k, p</span>):</span></span><br><span class="line">    delta = p &gt;&gt; (k + <span class="number">1</span>)</span><br><span class="line">    ui = random.randint(x - delta, x + delta)</span><br><span class="line">    <span class="keyword">return</span> ui</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_hnp</span>(<span class="params">t, u, col, k, p</span>):</span> </span><br><span class="line">    M = Matrix(RationalField(), col, col)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(col<span class="number">-1</span>):</span><br><span class="line">        M[i, i] = p</span><br><span class="line">        M[col<span class="number">-1</span>, i] = t[i]</span><br><span class="line"></span><br><span class="line">    M[col<span class="number">-1</span>, col<span class="number">-1</span>] = <span class="number">1</span> / (<span class="number">2</span> ** (k + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">babai</span>(<span class="params">A, w</span>):</span></span><br><span class="line">        A = A.LLL(delta=<span class="number">0.75</span>)</span><br><span class="line">        G = A.gram_schmidt()[<span class="number">0</span>]</span><br><span class="line">        t = w</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(A.nrows())):</span><br><span class="line">            c = ((t * G[i]) / (G[i] * G[i])).round()</span><br><span class="line">            t -= A[i] * c</span><br><span class="line">        <span class="keyword">return</span> w - t</span><br><span class="line"></span><br><span class="line">    closest = babai(M, vector(u+[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> (closest[<span class="number">-1</span>] * (<span class="number">2</span> ** (k + <span class="number">1</span>))) % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base_1 = <span class="number">256</span></span><br><span class="line">base_2 = <span class="number">270</span></span><br><span class="line">hidden_num = random_prime(<span class="number">2</span>^base_1, <span class="number">2</span>^(base_1<span class="number">-1</span>))</span><br><span class="line">p = random_prime(<span class="number">2</span>^base_2, <span class="number">2</span>^(base_2<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">k = ceil(sqrt(base_2)) + ceil(log(base_2, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">t = [random.randint(<span class="number">1</span>, p<span class="number">-1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">u = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">	u.append(msb_oracle(hidden_num * t[i], k, p))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(k)</span><br><span class="line">print(solve_hnp(t, u, n+<span class="number">1</span>, k, p))</span><br><span class="line">print(hidden_num)</span><br></pre></td></tr></table></figure>
<p>相关题目writeup链接：</p>
<ol type="1">
<li><a href="https://www.jianshu.com/p/2d7aa18677a0">2018 BCTF guess_number</a></li>
<li><a href="https://www.anquanke.com/post/id/204846">2020 XCTF 高校战役 NHP</a></li>
</ol>
<h5 id="相关心得">相关心得</h5>
<p>其实基于LLL算法的Crypto破解本质都是相似的，即构造一个合适的矩阵，其中可能包含题中的已知参数，通过一系列初等变换，找到一个范数较小的向量，将未知数转移到这个小范数向量中，从而求解。</p>
<p>以碰到的一个mix_bag为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">secret = int(secret.encode(<span class="string">&#x27;hex&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">p = getPrime(<span class="number">2040</span>)</span><br><span class="line">pub = []</span><br><span class="line">key = []</span><br><span class="line">tmp_key = getPrime(<span class="number">1024</span>)</span><br><span class="line">dec_key = getPrime(<span class="number">1024</span>)</span><br><span class="line">enc_key = inverse(dec_key,p)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    key.append(tmp_key)</span><br><span class="line">    pub.append(tmp_key * enc_key % p)</span><br><span class="line">    tmp_key = getPrime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">tmp_key = sum(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(flag.bit_length() - <span class="number">30</span>):</span><br><span class="line">    tmp_key *= <span class="number">2</span></span><br><span class="line">    pub.append(tmp_key * enc_key % p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;pub = &quot;</span>+str(pub).replace(<span class="string">&quot;L&quot;</span>,<span class="string">&quot;&quot;</span>)+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">S = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> flag &gt; <span class="number">0</span>:</span><br><span class="line">    S += (secret &amp; <span class="number">1</span>) * pub.pop()</span><br><span class="line">    flag &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&quot;data.txt&quot;</span>,<span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;S = &quot;</span> + str(S)+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&quot;p = &quot;</span> + str(p))</span><br></pre></td></tr></table></figure>
<p>审题后发现，是一个混合背包，由两部分组成，前30为无序背包，后面则为超递增序列构成的正常背包，但只给了总的和，故需要计算出前面的随机序列key，才能获得flag，根据题意，有：</p>
<p><span class="math display">\[key_i * enc  = K_i + T_i * p\]</span></p>
<p><span class="math inline">\(K_i\)</span>（此处K数列即为pub数列前30项）已知，p已知，想到可以构建矩阵，利用格基约化解决问题，构造矩阵如下：</p>
<p><span class="math inline">\(p \quad 0 \quad \dots \quad 0 \quad 0 \\ 0 \quad p \quad \dots \quad 0 \quad 0 \\ \vdots \quad \ \vdots \quad \ddots \quad p \quad 0 \\ k_1 \ k_2 \ \ \ \dots \ \ \  k_n \ \ \ x\)</span></p>
<p>容易发现，在此矩阵构造的格上有二向量（在这种构造的时候，不应该在有限域下去考虑问题）：</p>
<p><span class="math inline">\((T_1 p + K_1, \ T_2p+K_2, \ \dots, \ T_np+K_n, \ x)\)</span></p>
<p><span class="math inline">\((key_1 *enc, \ key_2 * enc, \ \dots, \ key_n * enc, \ enc * x)\)</span></p>
<p>将两向量相减，并把<span class="math inline">\(key_i * enc = K_i + T_i * p\)</span>代入，则可以得到：</p>
<p><span class="math inline">\((0, \ 0, \ \dots, \ 0, (enc - 1) * x)\)</span></p>
<p>再将此式乘以dec(enc在模p上的逆)，则得到：</p>
<p><span class="math inline">\((0, \ 0, \ \dots, \ 0, -dec * x)\)</span></p>
<p>如果将x的值控制得当，则此向量范数将很小，可以通过LLL得到， 此部分exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_seed</span>(<span class="params">t, col, k, p</span>):</span> </span><br><span class="line">    <span class="comment"># 在有理数域上也可构造格，并使用格基约化</span></span><br><span class="line">	M = Matrix(RationalField(), col, col)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(col<span class="number">-1</span>):</span><br><span class="line">		M[i, i] = p</span><br><span class="line">		M[col<span class="number">-1</span>, i] = t[i]</span><br><span class="line"></span><br><span class="line">	M[col<span class="number">-1</span>, col<span class="number">-1</span>] = <span class="number">1</span> / (<span class="number">2</span> ** k)</span><br><span class="line"></span><br><span class="line">	final_vector = M.LLL(delta=<span class="number">0.75</span>)[<span class="number">0</span>]</span><br><span class="line">	print(final_vector)</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">-1</span> * final_vector[<span class="number">-1</span>] * (<span class="number">2</span> ** k)) % p</span><br><span class="line">dec = find_seed(pub[:<span class="number">30</span>], <span class="number">31</span>, <span class="number">1</span>,p)</span><br></pre></td></tr></table></figure>
<p>其中k的选取不宜过大，较小的值均可找到正确的dec，有了dec之后就变成了简单的背包问题，不再详述。</p>
<h3 id="ecc">ECC</h3>
<h4 id="introduction-to-mathematical-chapter-5">Introduction-to-Mathematical Chapter 5</h4>
<h5 id="椭圆曲线基础概念">椭圆曲线基础概念</h5>
<p>理解椭圆曲线上的基本运算，重点理解O点（所有与y轴垂直线的交点）是为了使椭圆曲线上的加法群完备而虚构的点，为其上加法单位元，至于具体运算公式，如两点相加的泛式等，从原理上理解即可。</p>
<p>至于约束条件，其实本质上是为了使三次方程无解，使得不存在孤立点。</p>
<p>加法规则：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200719221158307.png"></p>
<h5 id="有限域上的椭圆曲线基础概念">有限域上的椭圆曲线基础概念</h5>
<p>Hasse Theorem:</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200715203211389.png"></p>
<p>SEA算法可以在较短时间内计算一个椭圆曲线的阶（椭圆曲线上点的个数），在sage中的cypari2模块有集成，ellcard函数和ellsea函数均有涉及，可通过官方文档决定具体使用情况（需要根据有限域的阶是否为素数判断）。</p>
<h5 id="有限域上椭圆曲线的dlp问题">有限域上椭圆曲线的DLP问题</h5>
<p>某个点作为生成元的集合的阶是曲线上点集合阶的因子，通过拉格朗日定理易得：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200715212418259.png"></p>
<p>具体证明看75页即可。</p>
<p>The Double-and-Add Algorithm：思想其实就是快速幂算法，在椭圆曲线上，或可称为快速加算法。如果允许三元扩张（即2的幂次的系数不仅可以为0/1，还可以为-1），在期望上会更快，会有<span class="math inline">\(\frac{3}{2}k +1\)</span> 的上界。</p>
<p>解决ECDLP问题的复杂度为<span class="math inline">\(O(n^{\frac{1}{2}})\)</span></p>
<p>Lenstra 算法：利用椭圆曲线的倍数分布分解n，算法的复杂度取决于n最小的因子。</p>
<h5 id="k上的椭圆曲线"><span class="math inline">\(2^k\)</span>上的椭圆曲线</h5>
<p>注意这里的<span class="math inline">\(2^k\)</span>不是指椭圆曲线上点的模数为<span class="math inline">\(2^k\)</span>，而是指其在<span class="math inline">\(F(2^k)\)</span>上，即k维度的，系数在<span class="math inline">\(F(2)\)</span>上的向量（即可映射为多项式）。</p>
<p>为了满足之前的无孤立点条件，需要进一步平衡曲线（原因是<span class="math inline">\(\Delta= -16 (4A^3 + 27B^2)\)</span>，而现在在<span class="math inline">\(F(2)\)</span>上讨论时前面的系数16即等价于0，则<span class="math inline">\(\Delta \equiv 0\)</span>）：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200719220641020.png"></p>
<p>平衡后计算规则大体不变，对于一个点的对称点的公式会变为：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200719220911438.png"></p>
<p>加法公式：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200719221419061.png"></p>
<p>在<strong>Koblitz曲线</strong>（<span class="math inline">\(E_a : Y_2 + XY = X^3 + aX^2 + 1\)</span>）上，通过Frobenius映射得到（<span class="math inline">\(t \leq \sqrt{p}\)</span>应为<span class="math inline">\(t \leq 2\sqrt{p}\)</span>，且这里<span class="math inline">\(\alpha,\beta\)</span>的绝对值有误，并不一定为<span class="math inline">\(\sqrt{p}\)</span>，）：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200720135121300.png"></p>
<p>Frobenius映射提供了一种更高效的计算<span class="math inline">\(nQ, Q \in E\)</span>的算法，由5.29.(b)可以得到<span class="math inline">\(\tau^2 = t\tau - p\)</span></p>
<p>由此可以将n表示为<span class="math inline">\(n = v_0 + v_1\tau+v_2\tau^2 + \dots + v_l\tau^l\)</span>，使用类似Double-and-Add Algorithm的方法可以在较短时间内计算出<span class="math inline">\(nQ\)</span>。</p>
<h5 id="bilinear-pairings">Bilinear pairings</h5>
<p>双线性对看作一个函数<span class="math inline">\(f\)</span>的话，其实本质即是对输入<span class="math inline">\(v, w\)</span> 两个向量，有输出$f(v, w) $ 为一数，且映射<span class="math inline">\(f\)</span> 对于<span class="math inline">\(v\)</span> 和<span class="math inline">\(w\)</span> 都是线性映射。</p>
<p>一个比较泛的例子：</p>
<p><span class="math inline">\(A_{n * n}\)</span> 为一n阶方阵，v和w为n阶向量，则<span class="math inline">\(f(v, w) = v * A * w^t\)</span> 为一<span class="math inline">\(R^n\)</span> 上的Bilinear pairings</p>
<p>椭圆曲线上，可定义双线性对，先用点阶做一个划分，即有<span class="math inline">\(E[m] = \{P|mP=O, P \in E\}\)</span>，<span class="math inline">\(\forall P \in E[m], P = aP_1 + bP_2\)</span></p>
<p><span class="math inline">\(P_1, P_2\)</span> 即 <span class="math inline">\(E[m]\)</span>上一组基</p>
<p>则对一双线性对<span class="math inline">\(f\)</span>，有<span class="math inline">\(f(P_1+P_2, P&#39;) = f(P_1, P&#39;) \times f(P_2, P&#39;)\)</span></p>
<p>(此处的<span class="math inline">\(\times\)</span>是未定义算子)</p>
<h5 id="divisor">Divisor</h5>
<p>对于一个有理多项式<span class="math inline">\(f(x) = \frac{a\prod_{i=1}^r(X-\alpha_i)^{e_i}}{b\prod_{i=1}^s(X-\beta_i)^{d_i}}\)</span></p>
<p>其中<span class="math inline">\(\alpha_i\)</span> 为零点（zeros），<span class="math inline">\(\beta_i\)</span> 为极点（poles），顾名思义即是让<span class="math inline">\(f(x) = 0/ \infin\)</span> 的点</p>
<p>定义<span class="math inline">\(div(f(x)) = \sum_{i=1}^re_i[\alpha_i] - \sum_{i=1}^rd_i[\beta_i]\)</span></p>
<p>这里的$[_i] <span class="math inline">\(，并不是一个具体的操作，中括号只是提供一个形式和，即将\)</span>_i, _i<span class="math inline">\(映射到一个abelian上，从而使得\)</span>div$ 为一个free abelian，具体的映射是不定的，关键在于定义了一个有理多项式上的零点和极点关系的刻画。</p>
<p>对于椭圆曲线E上的<span class="math inline">\(f\)</span>，有<span class="math inline">\(div(f) = \sum_{P\in E}n_P [P]\)</span></p>
<p>其中<span class="math inline">\(n_P\)</span> 为使得<span class="math inline">\(P\)</span>为<span class="math inline">\(f\)</span> zeros/poles的次数，以<span class="math inline">\(GF(7)\)</span>上曲线 <span class="math inline">\(E: Y^2= X^3 +1 = (x-6)(x-3)(x-5)\)</span> 为例，其点集为：</p>
<figure>
<img src="/2020/07/06/Way-to-Crypto/image-20201030005553374.png" alt="image-20201030005553374"><figcaption aria-hidden="true">image-20201030005553374</figcaption>
</figure>
<p>可知当x坐标使得<span class="math inline">\(y=0\)</span> 共有三点，皆不同，故$div(y) = [P_1] + [P_2] + [P_3] - 3O, P_1 =(3,0),P_2 = (5,0),P_3=(6,0) $</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20201030211900778.png"></p>
<p>这里的分析是考虑对于<span class="math inline">\(div(f_P) = m[P]-m[O]\)</span> 的情况只有P为<span class="math inline">\((\alpha, 0)\)</span>此种形式时，<span class="math inline">\(f_p = X-\alpha\)</span> 才可以满足，因为对于正常的<span class="math inline">\(P = (\alpha, \beta)\)</span>， 有<span class="math inline">\(-P = (\alpha, -\beta)\)</span>，故<span class="math inline">\(div[X-\alpha] = [P] + [-P] - 2[O]\)</span>。</p>
<p><em>需要注意区分多项式的原始情形和椭圆曲线上的情形，因为多项式原始情形是基于单变量定义的，而椭圆曲线上有两个变量，且使用点来表示div，故存在一些不同，这也是要使用[ ]来做形式和的原因。</em></p>
<h5 id="weil-pairing">Weil pairing</h5>
<p>Weil pairing 其实即是定义了一个ECC上的Bilinear pairing，如下</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20201030224528430.png"></p>
<p><em><span class="math inline">\(e_m(P, Q)\)</span> 的值与<span class="math inline">\(f_P, f_Q, S\)</span> 无关，他们本质上只是凑出一个自洽的映射</em></p>
<p>回顾双线性对的定义：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20201103221217410.png"></p>
<p>考虑到有<span class="math inline">\(e_m(aP, bQ) = ab \ e_m(PQ)\)</span>，即等价于第一条。</p>
<p>Weil pairing有性质如下：</p>
<ol type="1">
<li><span class="math inline">\(e_m(P,Q)^m = 1 | P, Q\in E[m]\)</span></li>
<li><span class="math inline">\(e_m\)</span> 为一双线性对</li>
<li><span class="math inline">\(e_m(P, P) = 1|P \in E[m]\)</span>， 即<span class="math inline">\(e_m(P, Q) e_m(Q,P) =1 | P, Q\in E[m]\)</span></li>
<li>如果对于<span class="math inline">\(\forall Q \in E[m], e_m(P, Q) = 1\)</span>， 则<span class="math inline">\(P= O\)</span></li>
</ol>
<p>由性质四知，<span class="math inline">\(\forall P, Q \in E[m], P \not= O, Q\not=O\)</span>，则有<span class="math inline">\(e_m(P, Q) \not=1\)</span>，即对于双线性对的条件2。</p>
<p>这里可以以前面order为2时的多项式<span class="math inline">\(f = X-\alpha\)</span>举例：<span class="math inline">\(\frac{(Q+S).x - \alpha}{S.x-\alpha}/\frac{(P+S).x -\beta}{(-S).x-\beta}\)</span></p>
<p>仍然以<span class="math inline">\(GF(7)\)</span>上曲线 <span class="math inline">\(E: Y^2= X^3 +1 = (x-6)(x-3)(x-5)\)</span> 为例，其点集为：</p>
<figure>
<img src="/2020/07/06/Way-to-Crypto/image-20201030005553374.png" alt="image-20201030005553374"><figcaption aria-hidden="true">image-20201030005553374</figcaption>
</figure>
<p>这里取<span class="math inline">\(\alpha = 5, P=(5, 0), \beta = 6, Q = (6,0), S = (2, 4)\)</span></p>
<p>则<span class="math inline">\((Q+S).x = 0, (P+S).x = 1, S.x =-S.x = 2\)</span></p>
<p>则<span class="math inline">\(e_m(P, Q) = \frac{-5}{-3} / \frac{-5}{-4} = \frac{4}{3}\)</span></p>
<p>取<span class="math inline">\(S = (4, 3)\)</span>， 则<span class="math inline">\((Q+S).x = 1, (P+S).x = 0, S.x = -S.x = 4\)</span></p>
<p>则<span class="math inline">\(e_m(P, Q) = \frac{-4}{-1}/\frac{-6}{-2} = \frac{4}{3}\)</span></p>
<p>可知，确实相等，具体的公式推导也可以结合Example5.40理解。</p>
<p><em>到这里其实可以泛的理解一下，我们定义divsor来刻画极点和零点关系，就是为了构造出<span class="math inline">\(m[P]-m[O]\)</span>这样的多项式，使其是阶是‘0’，则再构造出来的Weil pairing即是双线性对了</em></p>
<h5 id="jacobian-coordinates">Jacobian Coordinates</h5>
<p>Jacobian坐标是不同于仿射坐标的另一种表示椭圆曲线的方式，好处是使得加，乘，求逆等运算的复杂度大幅降低，不过其只能在模为素数的曲线上表示。</p>
<p>Jacobian坐标使用三个分量<span class="math inline">\((X, Y, Z)\)</span>，对应仿射坐标中的<span class="math inline">\((\frac{X}{Z^2}, \frac{Y}{Z^3})\)</span>，之前其实一直也有些疑惑为什么sage中的椭圆曲线坐标都是<span class="math inline">\((x,y,1)\)</span>，现在才知道其实这是取Z=1，则前两个分量等同于在仿射坐标系下的值。Jacobian坐标下的add和double提供了更低复杂度的算法，通常我们先将仿射坐标系的点转化为Jacobian坐标下的点，计算结束后再转为仿射坐标。</p>
<p>具体算法参见<a href="https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates">wiki</a> 。</p>
<h4 id="超椭圆曲线">超椭圆曲线</h4>
<p>椭圆曲线为亏格等于1的代数曲线，而<a href="https://baike.baidu.com/item/超椭圆曲线">超椭圆曲线</a>指亏格大于1的代数曲线，但仅有亏格为2的超椭圆曲线有与椭圆曲线相同的安全性。</p>
<p>推荐看这篇<a href="https://www.math.uwaterloo.ca/~ajmeneze/publications/hyperelliptic.pdf">文章</a>，对超椭圆曲线的基础概念介绍的非常详细（可以只看1，2，5，9章，即可有个大概了解了）。</p>
<p>超椭圆曲线定义如下，其天然不存在孤立点：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200930140124578.png"></p>
<h5 id="jacobian-variety">Jacobian variety</h5>
<p>超椭圆曲线上的加法群完备性源自于其Jacobian variety（雅克比簇）加法群为Abelian group，其点的运算也是需要先转化为Jacobian variety后再运算，环Jacobian variety的阶记为<span class="math inline">\(\#J\)</span>，即类似于<span class="math inline">\(GF(n)\)</span>上欧拉函数的意义。</p>
<p><span class="math inline">\(\#J\)</span> 是基于超椭圆曲线的密码学中重要的安全参数，有如下限制：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200930170010402.png"></p>
<p>其计算方法如下（此为亏格为2的情况，其余情况类比即可，其中<span class="math inline">\(M_i\)</span> 为<span class="math inline">\(F_{q^i}\)</span>下曲线阶数）：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200930185253258.png"></p>
<p>化为代码（使用的曲线为TCTF2020 Simple Curve）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Paramters and curve</span></span><br><span class="line">q = <span class="number">2</span></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line">genus = <span class="number">2</span></span><br><span class="line"><span class="comment"># h(x) = x^2 + x</span></span><br><span class="line"><span class="comment"># f(x) = x^5 + x^3 + 1</span></span><br><span class="line">h = <span class="keyword">lambda</span> x: x ^ <span class="number">2</span> + x</span><br><span class="line">f = <span class="keyword">lambda</span> x: x ^ <span class="number">5</span> + x ^ <span class="number">3</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc M_i</span></span><br><span class="line">M = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus):</span><br><span class="line">    P.&lt;x&gt; = PolynomialRing(GF(q ^ (i + <span class="number">1</span>)))</span><br><span class="line">    C = HyperellipticCurve(f(x), h(x))</span><br><span class="line">    M.append(C.cardinality())</span><br><span class="line">print(<span class="string">&quot;Calc M done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc a_i</span></span><br><span class="line">a = [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus):</span><br><span class="line">    a.append((M[i] - <span class="number">1</span> - q ^ (i + <span class="number">1</span>) + a[i] ^ (i + <span class="number">1</span>)) / (i + <span class="number">1</span>))</span><br><span class="line">a = [<span class="number">1</span>] + a[<span class="number">1</span>:]</span><br><span class="line">print(<span class="string">&quot;Calc a done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc gamma_i</span></span><br><span class="line">var(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">function = -genus * q</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus + <span class="number">1</span>):</span><br><span class="line">    function += a[i] * X ^ (genus - i)</span><br><span class="line">gamma = list(map(<span class="keyword">lambda</span> x: x.rhs(), solve([function == <span class="number">0</span>], X)))</span><br><span class="line">print(<span class="string">&quot;Calc gamma done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc alpha_i</span></span><br><span class="line">alpha = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus):</span><br><span class="line">    function = X ^ <span class="number">2</span> - gamma[i] * X + q</span><br><span class="line">    alpha.append(list(map(<span class="keyword">lambda</span> x: x.rhs(), solve([function == <span class="number">0</span>], X))))</span><br><span class="line">print(<span class="string">&quot;Calc alpha done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calc #J</span></span><br><span class="line">order = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(genus):</span><br><span class="line">    order *= abs(<span class="number">1</span> - alpha[i][<span class="number">0</span>] ^ n) ^ <span class="number">2</span></span><br><span class="line">print(<span class="string">&#x27;#J =&#x27;</span>, int(order))</span><br></pre></td></tr></table></figure>
<h3 id="stream">Stream</h3>
<h4 id="prng">PRNG</h4>
<h5 id="lcg">LCG</h5>
<p>已知（a，b，m）的直接通过解同模方程就行（方法很多，也可以利用格），已知（a，b），但m未知可以通过淘宝师傅博客的方法：</p>
<p><img src="/2020/07/06/Way-to-Crypto/image-20200728185617021.png"></p>
<p>也比较简单，至于有截断的泄露，其实就是普通的HNP问题，直接套用HNP脚本求解即可，附上NPUCTF2020中baby_LCG的求解seed部分exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">153582801876235638173762045261195852087</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">107763262682494809191803026213015101802</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">226649634126248141841388712969771891297</span>&#125;</span><br><span class="line">data = [<span class="number">7800489346663478448</span>,</span><br><span class="line">            <span class="number">11267068470666042741</span>,</span><br><span class="line">            <span class="number">5820429484185778982</span>,</span><br><span class="line">            <span class="number">6151953690371151688</span>,</span><br><span class="line">            <span class="number">548598048162918265</span>,</span><br><span class="line">            <span class="number">1586400863715808041</span>,</span><br><span class="line">            <span class="number">7464677042285115264</span>,</span><br><span class="line">            <span class="number">4702115170280353188</span>,</span><br><span class="line">            <span class="number">5123967912274624410</span>,</span><br><span class="line">            <span class="number">8517471683845309964</span>,</span><br><span class="line">            <span class="number">2106353633794059980</span>,</span><br><span class="line">            <span class="number">11042210261466318284</span>,</span><br><span class="line">            <span class="number">4280340333946566776</span>,</span><br><span class="line">            <span class="number">6859855443227901284</span>,</span><br><span class="line">            <span class="number">3149000387344084971</span>,</span><br><span class="line">            <span class="number">7055653494757088867</span>,</span><br><span class="line">            <span class="number">5378774397517873605</span>,</span><br><span class="line">            <span class="number">8265548624197463024</span>,</span><br><span class="line">            <span class="number">2898083382910841577</span>,</span><br><span class="line">            <span class="number">4927088585601943730</span>]</span><br><span class="line"></span><br><span class="line">u = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">19</span>):</span><br><span class="line">	u.append((data[i+<span class="number">1</span>] - data[i]) &lt;&lt; <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">t = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">19</span>):</span><br><span class="line">	t.append(key[<span class="string">&#x27;a&#x27;</span>] ** i)</span><br><span class="line"></span><br><span class="line">k = <span class="number">64</span></span><br><span class="line">n = <span class="number">19</span></span><br><span class="line">print(solve_hnp(t, u, n+<span class="number">1</span>, k, key[<span class="string">&#x27;m&#x27;</span>]))</span><br></pre></td></tr></table></figure>
<p>其中的solve_hnp函数即是我之前HNP示例中的函数。</p>
<h5 id="梅森旋转">梅森旋转</h5>
<p>如果是已知624位以上的序列，可以直接使用rand_crack破解，如果知道的序列下标之间有<span class="math inline">\(a \equiv (b + t) \mod(m)\)</span>（其中m为梅森旋转的状态数，t为旋转步骤中的参数），则也可以破解，具体例题可参见NPUCTF2020 Mersenne twister，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify , unhexlify</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XOR = <span class="keyword">lambda</span> s1 ,s2 : bytes([x1 ^ x2 <span class="keyword">for</span> x1 ,x2 <span class="keyword">in</span> zip(s1 , s2)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mt73991</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self , seed</span>):</span></span><br><span class="line">        self.state = [seed] + [<span class="number">0</span>] * <span class="number">232</span></span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        self.srand()</span><br><span class="line">        self.generate()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">srand</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">232</span>):</span><br><span class="line">            self.state[i+<span class="number">1</span>] = <span class="number">1812433253</span> * (self.state[i] ^ (self.state[i] &gt;&gt; <span class="number">27</span>)) - i</span><br><span class="line">            self.state[i+<span class="number">1</span>] &amp;= <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">            y = (self.state[i] &amp; <span class="number">0x80000000</span>) | (self.state[(i+<span class="number">1</span>)%<span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            temp = y &gt;&gt; <span class="number">1</span></span><br><span class="line">            temp ^= self.state[(i + <span class="number">130</span>) % <span class="number">233</span>]</span><br><span class="line">            <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">                temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">            self.state[i] = temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getramdanbits</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.flag == <span class="number">233</span>:</span><br><span class="line">            self.generate()</span><br><span class="line">            self.flag = <span class="number">0</span></span><br><span class="line">        bits = self.Next(self.state[self.flag]).to_bytes(<span class="number">4</span>, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> bits</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_num</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.flag == <span class="number">233</span>:</span><br><span class="line">            self.generate()</span><br><span class="line">            self.flag = <span class="number">0</span></span><br><span class="line">        num = self.state[self.flag]</span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Next</span>(<span class="params">self , tmp</span>):</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9ddf4680</span></span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc65400</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x34adf670</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">key , plain</span>):</span></span><br><span class="line">    tmp = md5(plain).digest()</span><br><span class="line">    <span class="keyword">return</span> hexlify(XOR(tmp , key))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">c, m</span>):</span></span><br><span class="line">    tmp = md5(m).digest()</span><br><span class="line">    bits = XOR(tmp, c)</span><br><span class="line">    <span class="keyword">return</span> [bytes_to_long(bits[<span class="number">4</span> * _:<span class="number">4</span> * (_+<span class="number">1</span>)]) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">true_decrypt</span>(<span class="params">c, key</span>):</span></span><br><span class="line">    tmp = XOR(c, key)</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">0x20</span>, <span class="number">0x7f</span>):</span><br><span class="line">        <span class="keyword">if</span> md5(chr(a).encode()).digest() == tmp:</span><br><span class="line">            <span class="keyword">return</span> chr(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__kMaxBits = <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__inverse_right_shift_xor</span>(<span class="params">value, shift, mask</span>):</span></span><br><span class="line"></span><br><span class="line">    i, result = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        part_mask = ((__kMaxBits &lt;&lt; (<span class="number">32</span> - shift)) &amp; __kMaxBits) &gt;&gt; (i * shift)</span><br><span class="line">        part = value &amp; part_mask</span><br><span class="line">        <span class="keyword">if</span> mask != <span class="number">0</span>:</span><br><span class="line">            value ^= (part &gt;&gt; shift) &amp; mask</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value ^= part &gt;&gt; shift</span><br><span class="line">        result |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__inverse_left_shift_xor</span>(<span class="params">value, shift, mask</span>):</span></span><br><span class="line">    i, result = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        part_mask = (__kMaxBits &gt;&gt; (<span class="number">32</span> - shift)) &lt;&lt; (i * shift)</span><br><span class="line">        part = value &amp; part_mask</span><br><span class="line">        value ^= (part &lt;&lt; shift) &amp; mask</span><br><span class="line">        result |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from_mt_to_state</span>(<span class="params">tmp</span>):</span></span><br><span class="line">    tmp = __inverse_right_shift_xor(tmp, <span class="number">18</span>, <span class="number">0x34adf670</span>)</span><br><span class="line">    tmp = __inverse_left_shift_xor(tmp, <span class="number">15</span>, <span class="number">0xefc65400</span>)</span><br><span class="line">    tmp = __inverse_left_shift_xor(tmp, <span class="number">7</span>, <span class="number">0x9ddf4680</span>)</span><br><span class="line">    tmp = __inverse_right_shift_xor(tmp, <span class="number">11</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess</span>(<span class="params">state_103, state_0</span>):</span></span><br><span class="line">    possible = state_103</span><br><span class="line">    possible ^= state_0</span><br><span class="line">    <span class="keyword">if</span> possible.bit_length() &gt; <span class="number">31</span>:</span><br><span class="line">        possible ^= <span class="number">0x9908f23f</span></span><br><span class="line">    possible &lt;&lt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> possible</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">final_inverse</span>(<span class="params">enc</span>):</span></span><br><span class="line">    tmp = enc &amp; <span class="number">0x7fffffff</span></span><br><span class="line">    <span class="keyword">return</span> tmp | (<span class="number">0x7fffffff</span>+<span class="number">1</span>), tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_srand</span>(<span class="params">value, i</span>):</span></span><br><span class="line">    value += i</span><br><span class="line">    value *= inverse(<span class="number">1812433253</span>, <span class="number">0xffffffff</span>+<span class="number">1</span>)</span><br><span class="line">    value = __inverse_right_shift_xor(value, <span class="number">27</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_init_seed</span>(<span class="params">state_103</span>):</span></span><br><span class="line">    last_state = state_103</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">103</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        last_state = inverse_srand(last_state, i)</span><br><span class="line">    <span class="keyword">return</span> last_state</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    flag_start = <span class="string">&#x27;npuctf&#123;&#x27;</span></span><br><span class="line">    flag_end = <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    cipher = unhexlify(open(<span class="string">&quot;cipher.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>).read())</span><br><span class="line">    random = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        random.extend(decrypt(cipher[<span class="number">16</span> * i: <span class="number">16</span> * (i+<span class="number">1</span>)], flag_start[i].encode()))</span><br><span class="line">    print(random)</span><br><span class="line"></span><br><span class="line">    state = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">28</span>):</span><br><span class="line">        state.append(from_mt_to_state(random[i]))</span><br><span class="line">    print(state)</span><br><span class="line"></span><br><span class="line">    random_last = decrypt(cipher[<span class="number">-1</span>*<span class="number">16</span>:], flag_end.encode())</span><br><span class="line">    state_last = [from_mt_to_state(i) <span class="keyword">for</span> i <span class="keyword">in</span> random_last]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(state_last)</span></span><br><span class="line">    mid = guess(state_last[<span class="number">-1</span>], state[<span class="number">0</span>])</span><br><span class="line">    old_104 = []</span><br><span class="line">    old_104.extend(final_inverse(mid))</span><br><span class="line">    <span class="keyword">if</span> inverse_srand(old_104[<span class="number">0</span>], <span class="number">103</span>) &amp; <span class="number">0x80000000</span> == mid &amp; <span class="number">0x80000000</span>:</span><br><span class="line">        <span class="keyword">if</span> inv_srand(old_104[<span class="number">1</span>], <span class="number">103</span>) &amp; <span class="number">0x80000000</span> == mid &amp; <span class="number">0x80000000</span>:</span><br><span class="line">            print(<span class="string">&quot;two cases found&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            old_104 = old_104[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        old_104 = old_104[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;old state 104 = &#x27;</span> + str(old_104))</span><br><span class="line"></span><br><span class="line">    seed = find_init_seed(old_104)</span><br><span class="line">    print(<span class="string">&#x27;seed = &#x27;</span> + str(seed))</span><br><span class="line"></span><br><span class="line">    random = mt73991(seed)</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        tmp = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            tmp += random.getramdanbits()</span><br><span class="line">        flag += true_decrypt(cipher[<span class="number">16</span> * i: <span class="number">16</span> * (i+<span class="number">1</span>)], tmp)</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure>
<h4 id="lfsr">LFSR</h4>
<h5 id="given-n-bits-mask">Given n bits, mask</h5>
<p>如果可以泄露LFSR的n位并且知晓抽头序列，则可以直接破解，方法可以参见<a href="https://www.anquanke.com/post/id/181811">这篇博客</a>，给出通用的exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_lfsr</span>(<span class="params">out, mask</span>):</span></span><br><span class="line">    out = out[::<span class="number">-1</span>]</span><br><span class="line">    mask = mask[::<span class="number">-1</span>]</span><br><span class="line">    index = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mask)):</span><br><span class="line">        <span class="keyword">if</span> mask[i] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            index.append(i)</span><br><span class="line">    print(index)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(out)):</span><br><span class="line">        mid = int(out[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(index)<span class="number">-1</span>):</span><br><span class="line">            mid ^= int(out[index[j]+<span class="number">1</span>])</span><br><span class="line">        out = out[<span class="number">1</span>:] + str(mid)</span><br><span class="line">    <span class="keyword">return</span> out[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h5 id="nlfsr">NLFSR</h5>
<p>n个LFSR并行，最终结果通过每个LFSR输出的代数运算获得密钥流，设输入为<span class="math inline">\(a_1, \dots, a_n\)</span>，输出为<span class="math inline">\(b\)</span>，则<span class="math inline">\(p_i = P\{a_i=b\}\)</span>，则当<span class="math inline">\(p_i\)</span>较大时（大于0.6即可），我们可以通过足够多的密钥流，通过统计找到概率相近的，作为备选值，之后依次爆破即可，可参见De1CTF2020 NLFSR的exp。</p>
<h5 id="given-2n-bits">Given 2n bits</h5>
<p>如果已知至少2n位的密钥流，但不知道抽头序列，则即为KPA问题，因为只要把前n个bit <span class="math inline">\(a_1,\dots,a_n\)</span>看成原本状态，则对后n个bit <span class="math inline">\(b_1, \dots, b_n\)</span>均有<span class="math inline">\(b_i = \sum_{i=1}^{n}a_i\&amp;p_i\)</span>，<span class="math inline">\(p_i\)</span>即为抽头序列，有n个这样的表达式，即为解n元一次方程，故而一定有解，通用exp如下（其中inverse_lfsr即为之前例子中函数）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_stream</span>(<span class="params">known_plain, known_cipher</span>):</span></span><br><span class="line">    <span class="keyword">assert</span>(len(known_plain) == len(known_cipher) <span class="keyword">and</span> len(known_plain) &lt;= <span class="number">24</span>)</span><br><span class="line">    known_plain_dec = int(known_plain, <span class="number">16</span>)</span><br><span class="line">    known_cipher_dec = int(known_cipher, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> bin(known_plain_dec ^ known_cipher_dec)[<span class="number">2</span>:].rjust(<span class="number">4</span> * len(known_plain), <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr_crack_key</span>(<span class="params">stream, key_length, p</span>):</span></span><br><span class="line">    <span class="keyword">assert</span>(len(stream) &gt;= <span class="number">2</span> * key_length)</span><br><span class="line">    solver = Solver()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream) - key_length):</span><br><span class="line">        cur = stream[i: i + key_length + <span class="number">1</span>]</span><br><span class="line">        equation = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(key_length):</span><br><span class="line">            <span class="keyword">if</span> cur[j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                equation += <span class="string">&#x27;p[&#x27;</span> + str(j) + <span class="string">&#x27;]+&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> len(equation):</span><br><span class="line">            equation = equation[:<span class="number">-1</span>] + <span class="string">&#x27; == &#x27;</span> + str(cur[<span class="number">-1</span>])</span><br><span class="line">            solver.add(eval(equation))</span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">        m = solver.model()</span><br><span class="line">        feedback = <span class="string">&#x27;&#x27;</span>.join([str(m[p[i]]) <span class="keyword">for</span> i <span class="keyword">in</span> range(key_length)])</span><br><span class="line">        <span class="keyword">return</span> stream[:key_length], feedback</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_lfsr_kpa</span>(<span class="params">stream</span>):</span></span><br><span class="line">    <span class="keyword">for</span> key_length <span class="keyword">in</span> tqdm(range(<span class="number">2</span>, len(stream)//<span class="number">2</span> + <span class="number">1</span>)):</span><br><span class="line">        p = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            p.append(<span class="string">&#x27;p%d&#x27;</span> % i)</span><br><span class="line">        p = [BitVec(i, <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> p]</span><br><span class="line">        key, mask = lfsr_crack_key(stream, key_length, p)</span><br><span class="line">        <span class="keyword">if</span> (key, mask) != (<span class="literal">False</span>, <span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">return</span> inverse_lfsr(key, mask)</span><br></pre></td></tr></table></figure>
<h3 id="block">Block</h3>
<p>推荐书目：《分组密码攻击实例》</p>
<p><strong>咕咕咕</strong></p>
<h3 id="推荐题单">推荐题单</h3>
<table>
<thead>
<tr class="header">
<th>题目</th>
<th>考点</th>
<th>难度(?/100)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>De1CTF2020 ECDH</td>
<td>筛法构造低阶椭圆曲线--ECC</td>
<td>60</td>
</tr>
<tr class="even">
<td>De1CTF2020 NLFSR</td>
<td>根据布尔表达式计算概率--Stream</td>
<td>35</td>
</tr>
<tr class="odd">
<td>RCTF2020 infant_ECC</td>
<td>多元Copper Smith--ECC</td>
<td>70</td>
</tr>
<tr class="even">
<td>SCTF2020 Lattice</td>
<td>基础NTRU攻击--Lattice</td>
<td>30</td>
</tr>
<tr class="odd">
<td>NCTF2019 easy_RSA</td>
<td>有限域开高次方--AMM algorithm</td>
<td>60</td>
</tr>
<tr class="even">
<td>watevrCTF2019 Swedish_RSA</td>
<td>多项式上的RSA--RSA&amp;Polynomial</td>
<td>30</td>
</tr>
<tr class="odd">
<td>watevrCTF2019 ECC_RSA</td>
<td>多项式分解--ECC&amp;RSA</td>
<td>50</td>
</tr>
<tr class="even">
<td>MIXCTF2020 mix_bag</td>
<td>HNP--Knapsack</td>
<td>65</td>
</tr>
<tr class="odd">
<td>NPUCTF2020 baby_LCG</td>
<td>HNP--PRNG（可以先做这道，再做上面的）</td>
<td>55</td>
</tr>
<tr class="even">
<td>NPUCTF2020 Mersenne twister</td>
<td>梅森旋转--PRNG</td>
<td>55</td>
</tr>
<tr class="odd">
<td>WMCTF2020 piece_of_a_cake</td>
<td>NTRU攻击&amp;私钥重复攻击--Lattice</td>
<td>65</td>
</tr>
<tr class="even">
<td>天翼杯2020 hard_RSA</td>
<td>Copper Smith--RSA</td>
<td>40</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Learning Notes</category>
      </categories>
      <tags>
        <tag>Way to Crypto</tag>
      </tags>
  </entry>
</search>
